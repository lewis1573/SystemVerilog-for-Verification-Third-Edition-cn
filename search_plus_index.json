{"./":{"url":"./","title":"说明","keywords":"","body":"当前状态 目前使用翻译软件完成了初步翻译，需要大量的人力做检查，优化以及校对工作，如果你也感兴趣，非常欢迎一起参与，下面表格中相应章节空白即表示当前章节的工作尚未开始，你可以挑选你感兴趣的一章，通过github的issue或给我发邮件知会我，我需要将你的名字和翻译的章节信息记录在这个贡献者列表中。 章节 机器初译 人工精译 序言 完成 完成 第一章 完成 第二章 完成 第三章 完成 第四章 完成 翻译中 第五章 完成 第六章 完成 第七章 完成 第八章 完成 第九章 完成 第十章 完成 第十一章 完成 第十二章 完成 "},"articles/chapter-00.html":{"url":"articles/chapter-00.html","title":"序言","keywords":"","body":"前言 这本书是关于什么的? 这本书应该是您学习SystemVerilog验证语言结构的第一本书。它描述了该语言如何工作，并包含了许多关于如何使用面向对象编程(OOP)构建一个基本的覆盖驱动、约束随机、分层测试平台的测试示例。这本书有许多关于构建testbench的指导方针，帮助您理解如何以及为什么使用类、随机化和函数覆盖。一旦你学会了这门语言，你可以从参考资料部分列出的一些方法论书籍中获得更多关于构建测试平台的信息。 谁应该读这本书? 如果您创建了testbench，您需要这本书。如果您只使用Verilog或VHDL编写测试，并且想学习SystemVerilog，这本书将向您展示如何升级到新的语言特性。Vera和Specman用户可以学习一种语言如何同时用于设计和验证。您可能已经尝试阅读SystemVerilog语言参考手册，但发现它塞满了语法，但没有关于选择哪种结构的指导方针。 Chris最初写这本书的原因是，像他的许多客户一样，他在职业生涯的大部分时间里都在使用C和Verilog等过程性语言来编写测试，而当OOP验证语言出现时，他不得不重新学习所有东西。他犯了所有典型的错误，所以写了这本书，你就不用再重复它们了。 在阅读本书之前，您应该熟悉Verilog-1995。不过您不需要了解Verilog-2001或SystemVerilog设计构造或SystemVerilog断言。 第三版有什么新内容? 这个用于验证的SystemVerilog新版本比分别于2006年和2008年编写的前两个版本有许多改进。 我们的大学需要在验证技术方面培养未来的工程师。这个版本适合教学环境，在每一章的最后有练习问题，以测试你的理解。 有资格的老师可以访问http://extras.springer.com 来获取更多的素材，比如幻灯片、考试、家庭作业、解决方案，以及适合一个学期的课程的教学大纲样本。 2009年版本的IEEE 1800 SystemVerilog语言参考手册(LRM)有很多变化，有大有小。这本书尽量包括最新的相关信息。 Accellera利用来自VMM(验证方法手册)、OVM(开放验证方法)、eRM (e重用方法)和其他方法的思想创建了UVM(通用验证方法)。本书中的许多例子都是基于VMM的，因为如果您是验证新手，那么VMM对阶段的显式调用更容易理解。同时提供了一些新的例子来展示UVM的概念，比如测试注册表和配置数据库。 当寻找一个特定的主题时，工程师从索引开始逆向阅读书籍，所以我们增加了索引的数量。 最后，非常感谢所有在前几版中发现错误的读者，从糟糕的语法到明显是在从亚洲飞往波士顿的18小时飞行后的早晨写的代码，或者更糟糕的是，在换尿布时写的代码。这个版本已经经过多次检查和审核，但再次强调，所有错误都是我们的。 为什么创建SystemVerilog ? 在20世纪90年代后期，Verilog硬件描述语言(HDL)成为用于描述仿真和合成硬件的最广泛的语言。然而，IEEE标准化的前两个版本(1364-1995和1364- 2001)只有简单的结构，用于创建测试。随着设计规模超出了该语言的验证能力，商业化的硬件验证语言（HVLs）如OpenVera和e应运而生。而不想为这些工具付费的公司，花了几百个人年的时间来创建自己的定制工具。 这种生产力危机以及设计方面的类似危机导致了Accellera的成立，这是一个由EDA公司和用户组成的联盟，他们希望创造下一代的Verilog。OpenVera语言的捐赠构成了SystemVerilog的HVL特性的基础。2005年11月，随着IEEE标准1800-2005 for SystemVerilog的通过，Accellera的目标得以实现，IEEE（2005）。2009年12月，最新的Verilog LRM 1364- 2005与上述2005年SystemVerilog标准合并，创建了IEEE标准1800-2009 for SystemVerilog。将这两个标准合并为一个标准，意味着现在设计和验证都只有一种语言——SystemVerilog。 统一语言的重要性 验证通常被视为与设计根本不同的活动。这种分裂导致了用于验证的狭隘语言的发展，并将工程师分成了两个基本上独立的学科。这种专业化在两组之间的交流方面造成了很大的瓶颈。SystemVerilog通过其针对两个阵营的功能解决了这个问题。两个团队都不需要放弃成功所需的任何功能，但是设计和验证工具的语法和语义的统一改善了交流。例如，虽然一个设计工程师可能不能编写一个面向对象的testbench环境，但是阅读这样的测试并理解发生了什么是相当简单的，使设计和验证工程师能够一起工作来识别和修复问题。同样，设计人员了解他或她的模块的内部工作原理，并且是编写有关它的断言的最佳人选，但是验证工程师可能有更广泛的视野来创建模块之间的断言。 在单一语言中包含design、testbench和断言构造的另一个优点是，testbench可以轻松访问环境的所有部分，而不需要专门的应用程序编程接口(API)。HVL的价值在于它能够创建高级的、灵活的测试，而不是它的循环结构或声明风格。SystemVerilog是基于Verilog、VHDL和工程师已经使用了几十年的C/C++结构的。 方法的重要性 学习一门语言的语法和学习如何使用一种工具是有区别的。这本书着重于使用受约束的随机测试的验证技术，该测试使用功能覆盖来度量进度并指导验证。随着章节的展开，语言和方法论的特点被并排显示出来。有关方法论的更多信息，请参见Bergeron等人(2006)。 SystemVerilog最有价值的好处是，它允许用户以一致的语法构建可靠的、可重复的验证环境，可以跨多个项目使用。 本书概述 SystemVerilog语言包括用于设计、验证、断言等功能。本书重点介绍用于验证设计的结构。使用SystemVerilog有许多方法可以解决问题。这本书解释了不同解决方案之间的权衡。 第1章，验证指南，介绍了验证技术作为学习和使用SystemVerilog语言的基础。这些指导方针强调了在分层的testbench环境中覆盖率驱动的随机测试。 第2章，数据类型，介绍了新的SystemVerilog数据类型，如数组、结构、枚举类型以及压缩数组和结构。 第3章，过程语句和例程，展示了新的过程语句以及对任务和函数的改进。 第4章，连接testbench和设计，展示了新的SystemVerilog验证结构，例如程序块、接口和时钟块，以及如何使用它们构建您的测试工作台并将其连接到被测试的设计中。 第5章，基本面向对象编程，介绍面向对象编程，解释如何构建类，构造对象和使用句柄。 第6章，随机化，向您展示了如何使用SystemVerilog中受约束的随机激励产生机制，包括许多技术和示例。 第7章，线程和线程间通信，展示了如何在你的测试台中创建多个线程，使用线程间通信在这些线程之间交换数据并同步它们。 第8章，高级OOP和测试工作台指南，展示了如何用OOP构建一个分层的测试工作台，以便所有测试都可以共享组件。 第9章，功能覆盖率，解释了不同类型的覆盖率，以及在您遵循验证计划时如何使用功能覆盖率来度量您的进度。 第10章，高级接口，展示了如何使用虚拟接口来模拟扩充您的测试工作台代码，连接到多个设计配置，并使用过程代码创建接口，使您的测试工作台和设计可以在更高的抽象级别上工作。 第11章，一个完整的SystemVerilog测试平台，展示了一个使用第8章中所示准则的约束性随机测试平台。本章展示了几个测试，以说明如何在不编辑原始代码的情况下轻松扩展测试本的行为，因为编辑原始代码总是有引入新错误的风险。 第12章，C / C++接口，描述了如何使用直接编程接口将C或C++代码连接到SystemVerilog。 本书中使用的图标 表1 书中的图标 这个指南针图标展示了验证方法，以指导您使用SystemVerilog testbench特性。 这个虫子图标显示了常见的编码错误，如语法错误、逻辑问题或线程问题。 关于作者 Chris Spear在ASIC设计和验证领域工作了30年。他的职业生涯始于Digital Equipment Corporation (DEC)，担任DECsim的CAD工程师，连接了有史以来第一个Zycad盒子，然后是VAX 8600的硬件验证工程师，以及硬件行为仿真加速器。然后他转到Cadence公司，在那里他是Verilog-XL的应用工程师，随后在Viewlogic工作。Chris目前受雇于Synopsys公司，担任验证顾问，这个职位是他在十几年前开始的。他撰写了《SystemVerilog for Verification》的第一版和第二版。Chris于1981年获得康奈尔大学的BSEE学位。业余时间，Chris喜欢在山区骑公路自行车和与妻子一起旅行。 Greg Tumbush从事ASIC和FPGA的设计和验证已有13年。在空军研究实验室（AFRL）担任研究员后，他搬到美丽的科罗拉多州，在Astek公司担任首席ASIC设计工程师。随后，他在Starkey实验室、AMI半导体和安森美半导体开始了6年的职业生涯，在那里他是SystemC和SystemVerilog的早期使用者。2008年，Greg离开安森美半导体成立了Tumbush公司，在那里他一直为客户提供设计、验证和后端咨询，以确保首次成功。他也是科罗拉多大学科罗拉多斯普林斯分校的兼职讲师，教授高级和研究生级别的数字设计和验证课程。他有许多出版物，可以在www.tumbush.com 找到。Greg于1998年获得辛辛那提大学博士学位。 最后的注解 如果你想了解更多关于SystemVerilog和验证的信息，你可以在以下网站找到许多资源：http://chris.spear.net/systemverilog 。这个网站有本书中许多例子的源代码。想在课堂上使用本书的学者可以在http://extras.springer.com 获取幻灯片、测试、作业题、解决方案和样本大纲。 本书中的大部分代码示例都是用Synopsys公司的Chronologic VCS、Mentor的QuestaSim和Cadence Incisive验证的。任何错误都是由Chris的邪恶双胞胎Skippy造成的。如果你认为你在本书中发现了错误，请查看他的网站上的勘误页面。如果您是第一个发现某一章中的技术错误的人，我们将免费送您一本亲笔签名的书。请在电子邮件的主题行中注明 \"SystemVerilog\"。 克里斯·斯皮尔，格雷格·唐布什 "},"articles/chapter-01.html":{"url":"articles/chapter-01.html","title":"第一章　　验证指南","keywords":"","body":"第一章 验证指南 有些人认为我们缺乏描述完美世界的编程语言…… (《黑客帝国》,1999) 想象一下，你被指派给某人盖一所房子。你应该从哪里开始呢?你从选择门窗开始，选择油漆和地毯的颜色，还是选择浴室设备?当然不是!首先，你必须考虑业主将如何使用空间，以及他们的预算，这样你就可以决定建造什么类型的房子。你应该考虑的问题是:他们喜欢烹饪，想要一个高端厨房，还是更喜欢在家庭影院看电影，吃外卖披萨?他们想要一间家庭办公室还是一间额外的卧室?还是他们的预算限制了他们在一个更普通的房子? 在开始学习SystemVerilog语言的细节之前，您需要了解您计划如何验证特定的设计，以及这如何影响testbench结构。就像所有的房子都有厨房、卧室和浴室一样，所有的测试工作台都有一些共同的刺激产生和反应检查结构。本章介绍了一组指导方针和编码风格，用于设计和构建满足您特定需求的测试平台。这些技术使用了SystemVerilog (VMM)、Bergeron等人(2006)的验证方法手册中显示的一些相同的概念，但没有基类。其他方法，如UVM和OVM，都有相同的概念。 作为一个验证工程师，你可以学到的最重要的原则是:“bug是好的。“不要羞于发现下一个漏洞，不要在每次发现漏洞时犹豫地敲响警钟，更重要的是，要始终跟踪发现的每个漏洞的细节。整个项目团队都假定设计中存在bug，因此在tape-out之前发现的每个bug都会减少一个最终落入客户手中的bug。在设计周期的每一个阶段，如规格说明、编码、合成、制造，修复错误的成本会增加10倍，所以要尽早并经常找到这些错误。你需要尽可能地扭曲和折磨设计现在就提取所有可能的bug，尽管它们仍然很容易修复。不要让设计师偷走所有的荣耀——没有你的工艺和狡猾，设计可能永远不会成功!本书假设您已经了解Verilog语言，并且希望学习Verilog硬件验证语言(HVL)系统。HVL的一些典型特征将其与硬件描述语言区分开来，例如 Verilog或VHDL是: Constrained-random刺激一代 功能覆盖 更高级的结构，特别是面向对象的编程和事务级建模 多线程和进程间通信(IPC) 支持HDL类型，如Verilog的4状态值 与事件模拟器紧密集成，以控制设计 还有许多其他有用的特性，但是这些特性允许您在更高的抽象级别上创建testbench，而不是使用HDL或编程语言(如C)所能实现的。 1.1 验证过程 核实的目的是什么?如果你的回答是“寻找bug”，你只说对了一部分。硬件设计的目标是根据设计规范创建一个执行特定任务的设备，如DVD播放器、网络路由器或雷达信号处理器。作为验证工程师，你的目的是确保设备能够成功地完成这项任务——也就是说，设计是对规格的准确描述。当存在差异时，就会出现bug。设备在其原始用途之外的使用行为不是你的责任，尽管你想知道这些界限在哪里。 验证过程与设计创建过程并行。设计者阅读一个块的硬件规范，解释人类语言描述，并以机器可读的形式(通常是RTL代码)创建相应的逻辑。为此，他或她需要理解输入格式、转换函数和输出格式。这种解释总是含糊不清，可能是由于原始文件中的含糊不清、缺少细节或描述相互矛盾。作为一个验证工程师，您还必须阅读硬件规范，创建验证计划，然后按照它来构建测试，显示RTL代码正确地实现了特性。因此，作为一个验证工程师，你不仅要理解设计和它的意图，而且，你必须考虑所有的角落测试用例，设计者可能没有想到。通过让多个人员执行相同的解释，您已经为设计过程增加了冗余。作为验证工程师，您的工作是阅读相同的硬件规范，并对它们的含义做出独立的评估。然后您的测试将测试RTL，以显示它与您的解释相匹配。 1.1.1 不同水平的测试 在设计中潜伏着什么类型的bug ?最容易检测的是块级别，即由单个人创建的模块。ALU是否正确地将两个数字相加?是否每个总线事务都成功完成了?所有的包都通过网络交换机的一部分了吗?编写定向测试来发现这些bug几乎是微不足道的，因为它们完全包含在设计块中。 在块水平之后，下一个寻找差异的地方是块之间的边界。这就是所谓的集成阶段。当两个或更多的设计师阅读相同的描述却有不同的解释时，有趣的问题就出现了。对于一个给定的协议，什么信号会在什么时候改变?第一个设计器使用规范的一个视图构建总线驱动程序，而第二个设计器使用稍微不同的视图构建接收器。你的工作是找到逻辑上有争议的领域，甚至可能帮助调和这两种不同的观点。 为了模拟单个设计块，您需要创建从周围所有块产生刺激的测试——这是一项困难的工作。好处是这些低级别模拟运行得非常快。然而，您可能会在设计和测试工作台中都发现bug，因为后者需要大量代码来从丢失的块中提供刺激。当您开始集成设计模块时，它们可以相互刺激，从而减少您的工作量。这些多块模拟可能会发现更多的错误，但它们也运行得更慢。在更高的级别上，分析行为以确定错误的根本原因会花费更多的时间。 在被测设计(DUT)的最高水平上，对整个系统进行测试，但仿真性能大大降低。您的测试应该努力让所有块并发地执行感兴趣的活动。所有的I/O端口都处于活动状态，处理器正在处理数据，缓存正在被填满。有了这些操作，数据对齐和计时错误肯定会发生。 在这个级别上，您可以运行复杂的测试，这些测试让DUT并发执行多个操作，从而使尽可能多的块处于活动状态。如果MP3播放器正在播放音乐，而用户试图从主机上下载新的音乐，会发生什么情况?然后，在下载过程中，用户按下播放器上的几个按钮?你知道，当真正的设备被使用时，有人会做所有这些，所以为什么不在它建成之前试用一下呢?这种测试将决定一个产品是容易使用还是反复锁定。 验证DUT正确执行其指定的功能之后，您需要了解在出现错误时它是如何工作的。设计能否处理部分事务，或数据或控件字段损坏的事务?仅仅试图列举出所有可能的问题是困难的，更不用说确定设计应该如何从这些问题中恢复。错误注入和处理可能是验证中最具挑战性的部分。 当您转移到系统级的验证时，挑战也转移到更高的级别。在块级别，您可以显示单个单元正确地流经ATM路由器的块，但在系统级别，您可能必须考虑如果存在不同优先级的流会发生什么情况。接下来选择哪个单元格在最高级别上并不总是很明显。您可能必须分析来自数千个单元格的统计数据，以查看聚合行为是否正确。 最后一点:你永远无法证明没有bug留下，所以你需要不断地想出新的验证策略。 1.1.2 验证计划 验证计划来源于硬件规范，并包含需要执行哪些特性和要使用的技术的描述。这些步骤可能包括定向或随机测试、断言、软硬件协同验证、仿真、形式证明和验证IP的使用。关于验证的更完整的讨论见Bergeron(2006)。 1.2 验证方法手册 您手中的这本书借鉴了VMM，它植根于由Janick Bergeron和Qualis Design的其他人开发的方法论中。他们从行业标准的实践开始，并根据他们在许多项目中的经验来完善它们。VMM的技术最初是为与OpenVera语言一起使用而开发的，并在2005年为SystemVerilog进行了扩展。VMM及其前身，用于Vera的参考验证方法(RVM)，已经成功地用于验证广泛的硬件设计，从网络设备到处理器。新的方法，如OVM和UVM，使用了许多类似的思想。这本书是基于许多相同的概念，所有这些方法，虽然大大简化。 这本书是SystemVerilog语言的用户指南。它描述了许多语言结构，并为选择最适合您需要的语言提供了指导方针。如果你是验证的新手，对面向对象编程(OOP)缺乏经验，或者不熟悉约束随机测试(CRT)，这本书可以告诉你选择正确的路径。一旦熟悉了它们，您就会发现UVM和VMM是很容易的一步。 那么，为什么这本书没有教你UVM或VMM呢?像任何先进的工具一样，这些方法是为有经验的用户而设计的，并且擅长解决困难的问题。您是否负责验证一个拥有许多通信协议、复杂错误处理和IP库的1亿门设计?如果是这样，那么UVM或VMM是合适的工具。然而，如果您正在使用单一协议处理较小的模块，则可能不需要如此健壮的方法。记住，你的街区是一个更大系统的一部分;符合UVM或vmm的代码在项目期间和以后的设计中都可以重用。验证的成本超出了您当前的项目。 UVM和VMM有一组用于数据和环境的基类，以及用于管理日志文件和进程间通信的实用程序，等等。这本书是SystemVerilog的简介，展示了涉及这些类和实用程序的技术和技巧，让您深入了解它们的构造。 1.3 基本的Testbench功能 测试台的目的是确定DUT的正确性。这可以通过以下步骤完成。 产生刺激 刺激DUT 捕获的响应 检查正确性 根据总体的验证目标来衡量进展 有些步骤由testbench自动完成，而其他步骤则由您手动确定。您选择的方法决定了如何执行上述步骤。 1.4 直接测试 传统上，当面临验证设计正确性的任务时，您可能会使用定向测试。使用这种方法，您可以查看硬件规范，并编写一个带有测试列表的验证计划，每个测试都集中于一组相关特性。有了这个计划，您可以编写在DUT中实践这些特性的刺激向量。然后用这些矢量模拟DUT，并手动检查生成的日志文件和波形，以确保设计符合您的预期。一旦测试正常工作，您就可以在验证计划中进行检查，然后进行下一个测试。 这种渐进的方法可以取得稳定的进展，这总是受到希望看到项目取得进展的经理们的欢迎。它还能产生几乎立竿见影的效果，因为当你在指导创建每个刺激载体时，几乎不需要什么基础设施。给定充足的时间和人员，直接测试足以验证许多设计。 图1.1显示了定向测试如何增量地覆盖验证计划中的特性。每个测试都针对一组非常特定的设计元素。如果您有足够的时间，您可以编写整个验证计划100%覆盖所需的所有测试。 如果您没有必要的时间或资源来执行定向测试方法，该怎么办?正如你所看到的，虽然你可能总是在前进，但斜率是不变的。当设计复杂度翻倍时，完成它需要的时间也翻倍，或者需要两倍的人来实现它。 图1.1有方向性的测试进度随时间的变化 这两种情况都不可取。为了达到100%覆盖率的目标，您需要一种能够更快地发现bug的方法。蛮力不起作用;如果您试图验证32位加法器的输入的每个组合，您的模拟将仍然运行多年后的项目应该已经发货。 图1.2显示了被定向测试用例覆盖的总体设计空间和特性。在这个领域中有许多功能，其中一些有bug。您需要编写覆盖所有特性的测试，并找到bug。 图1.2定向测试覆盖率 1.5 方法论基础 这本书采用了以下原则。 Constrained-random刺激 功能覆盖 使用事务处理器的分层测试工作台 用于所有测试的公共测试台架 特定于测试用例的代码与testbench分离 所有这些原则都是相互关联的。随机刺激对于复杂的设计是至关重要的。定向测试会发现你预期在设计中出现的bug，而随机测试则会发现你从未预料到的bug。当使用随机刺激时，您需要功能覆盖来测量验证过程。此外，一旦你开始使用自动生成的刺激，你就需要一种自动的方法来预测结果——通常是记分板或参考模型。构建testbench基础设施，包括自我预测，需要大量的工作。一个分层的测试台通过将问题分解成可管理的部分来帮助您控制复杂性。事务处理程序为构建这些部分提供了一个有用的模式。通过适当的计划，您可以构建一个testbench基础设施，它可以被所有的测试共享，并且不需要不断地修改。你只需要留下“挂钩”，让测试执行某些操作，如塑造刺激和注入干扰。相反，特定于单个测试的代码必须与测试工作台分离，以防止使基础设施复杂化。 构建这种风格的测试平台比传统的定向测试平台需要更长的时间——特别是自检部分。因此，在运行第一个测试之前可能会有很大的延迟。这种差距会让经理感到恐慌，所以把这种努力作为你日程的一部分吧。在图1.3中，你可以看到第一次随机测试运行前的初始延迟。 图1.3随时间变化的约束随机测试进度与定向测试进度 虽然这一前期工作似乎令人生畏，但回报却很高。您创建的每个随机测试都共享这个公共测试工作台，而不是从头编写每个测试的定向测试。每个随机测试都包含几十行代码，以在特定方向约束刺激，并导致任何所需的异常，如创建协议违背。结果是，您的单个受限随机测试平台现在比许多定向测试平台更快地找到bug。 当发现速度开始下降时，您可以创建新的随机约束来探索新的区域。最后几个bug可能只能通过定向测试找到，但是绝大多数的bug可以通过随机测试找到。如果您创建了一个随机测试平台，您总是可以将其约束为创建的定向测试，但是定向测试平台永远不会变成一个真正的随机测试平台。 1.6 Constrained-Random刺激 虽然您希望模拟器生成刺激，但您不想要完全随机的值。您可以使用SystemVerilog语言来描述刺激的格式(“地址是32位;操作码是ADD, SUB或STORE;长度 图1.4显示了约束随机测试在整个设计空间的覆盖范围。首先，请注意随机测试通常比定向测试覆盖更广的空间。这个额外的覆盖范围可能会与其他测试重叠，或者可能会探索您没有预料到的新领域。如果这些新区域发现了一个bug，那么你就很幸运了!如果新的区域是不合法的，你需要编写更多的约束来防止随机生成产生非法的设计功能。最后，您可能仍然需要编写一些定向测试，以找到任何其他约束随机测试所不覆盖的案例。 图1.5显示了实现完全覆盖的路径。从左上角的基本约束随机测试开始。用许多不同的种子运行它们。 图1.4约束随机测试覆盖率 约束的随机测试 导演 很多次跑步，不同的种子 添加约束 导演testcase 最少的代码修改 功能覆盖 图1.5覆盖收敛 当您查看功能覆盖率报告时，请找到覆盖率中存在缺口的漏洞。然后，可以通过使用新的约束，或者向DUT中注入错误或延迟，进行最小的代码更改。把大部分时间花在这个外部循环上，只为随机测试不太可能达到的少数特性编写定向测试。 1.7 你应该随机化什么? 当您考虑对设计的刺激因素进行随机化时，您可能首先选择数据字段。这些值是最容易创建的-只需调用$random()。问题是，这种选择在漏洞发现方面的回报非常低。随机数据发现的主要错误类型是数据路径错误，可能是位级错误。您需要找到控制逻辑中的错误，这是最棘手问题的根源。 广义地考虑所有的设计输入，例如下面的内容。 设备配置 环境配置 输入数据 协议异常 错误和违规 延迟 这些将在第1.7.1到1.7.4节中讨论。 1.7.1 设备与环境配置 在测试RTL设计时遗漏bug最常见的原因是什么?没有尝试足够多的不同配置。大多数测试只是在重新设置后使用设计，或者应用一组固定的初始化向量将其置于已知状态。这就像在PC安装完之后测试它的操作系统，但是没有安装任何应用程序。当然，性能很好，没有任何崩溃。 在真实的环境中，DUT的配置随着使用时间的延长而变得更加随机。例如，我帮助一家公司验证了一个有2000个输入通道和12个输出通道的时分多路复用开关。验证工程师说:“这些通道可以映射到另一边的各种配置。每个输入可以作为单个通道使用，也可以进一步划分为多个通道。棘手的是，尽管在大多数情况下使用了一些标准的分解方法，但任何分解组合都是合法的，留下了大量可能的客户配置。” 为了测试这个设备，工程师必须编写几十行直接的测试平台代码来配置每个通道。因此，她永远无法尝试使用超过几个频道的配置。我们一起编写了一个测试平台随机的参数为一个单一的通道，然后把它放在一个循环来配置所有的开关的通道。现在她有信心她的测试将发现配置相关的错误，这些错误在以前可能会被忽略。 在现实世界中，您的设备在一个包含其他组件的环境中运行。在验证DUT时，它连接到一个模拟此环境的测试平台。您应该随机化整个环境配置，包括模拟的长度、设备的数量以及它们的配置方式。当然，您需要创建约束来确保配置是合法的。 在Synopsys的另一个客户示例中，一家公司创建了一个I/O开关芯片，将多个PCI总线连接到内部内存总线。在模拟开始时，他们随机选择了PCI总线的数量(1-4)、每个总线上的设备数量(1-8)以及每个设备的参数(主或从、CSR地址等)。他们使用功能覆盖来跟踪测试的组合，这样他们就可以确定他们已经覆盖了几乎所有可能的组合。 其他环境参数包括测试长度、错误注入速率和延迟模式。更多的例子见Bergeron(2006)。 1.7.2 输入数据 当您阅读有关随机刺激的内容时，您可能会想到处理一个事务，例如总线写入或ATM单元格，并用随机值填充数据字段。实际上，只要您像第5章和第8章中所示的那样仔细准备事务类，这种方法就相当简单。您需要预测任何分层协议和错误注入，以及计分板和功能覆盖。 1.7.3 协议异常、错误和违反 没有什么比电脑或手机等设备上锁更令人沮丧的了。很多时候，唯一的解决办法就是关闭它，然后重新启动。很有可能在产品内部有一个逻辑，经历了某种错误条件，它不能恢复，从而阻止了设备的正确工作。 如何防止这种情况发生在正在构建的硬件上?如果在实际的硬件中可能出现错误，您应该尝试模拟它。看看所有可能发生的错误。如果总线事务未完成会发生什么?如果遇到无效操作?设计规范是否说明两个信号是相互排斥的?同时驱动它们，并确保设备继续正常运行。 正如您试图用格式不良的命令触发硬件一样，您也应该尝试捕捉这些事件。例如，相互回忆 独家的信号。您应该添加检查器代码来查找这些违规行为。当发生这种情况时，您的代码至少应该打印一条警告消息，最好生成一个错误并结束测试。花几个小时跟踪代码，试图找到故障的根源，这是令人沮丧的，特别是当您可以通过一个简单的断言在源代码附近捕获故障时。参见Vijayaraghavan[2005]，了解更多关于在测试平台和设计代码中编写断言的指导方针。只要确保您可以禁用在出现错误时停止模拟的代码，这样您就可以轻松地测试错误处理。 1.7.4 延迟和同步 您的测试平台应该以多快的速度发送刺激?您应该选择随机的延迟来帮助捕获协议bug。具有最短延迟的测试很容易编写，但不会创建所有可能的刺激组合。当选择实际的延迟时，围绕边界条件的微妙bug往往会被揭示出来。 一个区块可以正确地处理来自单一界面的所有可能的刺激排列，但当事务流入多个输入时，可能会出现微妙的错误。试着协调不同的司机，使他们能够以不同的时间速率交流。如果输入以可能最快的速度到达，但输出被限制回较慢的速度，那该怎么办?如果刺激同时到达多个输入点会怎样?如果是交错的，有不同的延迟呢?使用功能覆盖(将在第9章中讨论)来度量随机生成的组合。 1.7.5 并行随机测试 如何运行测试?定向测试有一个测试平台，它产生一组独特的刺激和反应向量。为了改变刺激，你需要改变测试。一个随机测试由testbench代码和一个随机种子组成。如果你做同样的测试50次，每次都用一种独特的种子，你会得到50种不同的刺激。使用多种种子可以扩大测试的覆盖范围，并扩展工作。 您需要为每个模拟选择一个唯一的种子。有些人使用一天中的时间，但这仍然会导致重复。如果您正在使用跨CPU场的批处理队列系统，并告诉它在午夜启动10个作业，该怎么办?多个作业可以在不同的计算机上同时启动，因此将获得相同的随机种子并运行相同的刺激。您应该在种子中加入处理器名称。如果您的CPU场包括多处理器机器，那么您可以使用相同的种子让两个作业在午夜开始运行，因此您还应该添加进程ID。现在所有作业都有唯一的种子。 你需要计划如何组织你的文件来处理多个模拟。每个作业都创建一组输出文件，比如日志文件和功能覆盖率数据。您可以在不同的目录中运行每个作业，或者尝试为每个文件指定唯一的名称。最简单的方法是将随机种子值附加到目录名。 1.8 功能覆盖 第1.6节和第1.7节展示了如何创建能够随机穿越整个可能输入空间的刺激。使用这种方法，您的测试工作台经常访问一些区域，但是要到达所有可能的状态需要花费太长时间。即使给予无限的模拟时间，无法到达的状态也永远不会被访问。为了核对验证计划中的项目，您需要度量已验证的内容。 度量和使用功能覆盖率的过程由几个步骤组成。首先，向测试台中添加代码，以监视进入设备的刺激及其反应和响应，以确定执行了哪些功能。运行几个模拟，每个模拟使用不同的种子。接下来，将这些模拟的结果合并到一个报告中。最后，你需要分析结果，并决定如何创造新的刺激，以达到未经测试的条件和逻辑。第9章描述SystemVerilog中的功能覆盖。 1.8.1 从功能覆盖到刺激的反馈 随机测试使用反馈进行发展。初始测试可以使用许多不同的种子运行，从而创建许多惟一的输入序列。最终，即使使用了新的种子，测试也不太可能产生能够到达设计空间的刺激。随着功能覆盖逐渐接近其极限，您需要更改测试，以找到新的方法来达到设计的未覆盖区域。这就是所谓的“覆盖驱动验证”，如图1.6所示。 图1.6有反馈和没有反馈的测试进度 如果您的测试工作台足够聪明，可以为您完成这些工作，那会怎样呢?在以前的工作中，我编写了一个测试，该测试为处理器生成每个总线事务，并在每个周期中额外触发每个总线终止程序(成功、奇偶校验错误、重试)。这是在HVLs之前，所以我编写了一套很长的定向测试，并花了几天时间排列终止代码，以便在适当的周期触发。经过大量的手分析，我宣布成功- 100%的覆盖率。然后处理器的时间发生了轻微的变化!现在我必须重新分析测试，改变刺激因素。 更高效的测试策略使用随机事务和终止器。你运行的时间越长，覆盖率就越高。作为奖励，即使设计的时间改变了，测试也可以足够灵活地创造有效的刺激。你可以通过添加一个反馈循环来实现这一点，该循环着眼于到目前为止所创造的刺激(生成了所有的写周期吗?)，然后改变约束权重(将写权重降为0)。这种改进将极大地减少实现完全覆盖所需的时间，很少有人工干预。 然而，这不是一个典型的情况，因为从功能覆盖到刺激的琐碎反馈。在真实的设计中，你应该如何改变刺激来达到理想的设计状态?这需要深入的设计知识和强大的形式化技术。没有简单的答案，所以动态反馈很少用于受限随机刺激。相反，您需要手动分析功能覆盖率报告，并更改您的随机约束。 反馈被用于形式分析工具，如麦哲伦(Synopsys 2003)。它分析一个设计，以找到所有唯一的、可到达的状态。然后它运行一个简短的模拟来查看访问了多少个状态。最后，它从状态机搜索到设计输入，计算达到任何剩余状态所需的刺激，然后麦哲伦将其应用到DUT。 1.9 Testbench组件 在模拟中，测试台包覆被测单元，就像一个硬件测试器连接到一个物理芯片，如图1.7所示。测试台和测试人员都提供刺激并捕获响应。它们之间的区别是，您的testbench需要在广泛的抽象级别上工作，创建事务和序列，这些事务和序列最终被转换为位向量。测试人员只是在位级上工作。 图1.7试验台设计环境 什么会进入这个testbench块?它由许多总线功能模型(BFM)组成，你可以把它们看作是测试平台组件——对DUT来说，它们看起来像真实的组件，但它们是测试平台的一部分，而不是RTL设计。如果实际设备连接到AMBA、USB、PCI和SPI总线，则必须在测试台上构建能够产生刺激并检查响应的等效组件，如图1.8所示。这些不是详细的、可综合的模型，而是遵循协议并执行得更快的高级事务处理程序。另一方面，如果你是使用fpga或仿真进行原型设计，BFMs确实需要是可合成的。 图1.8试验台组件 1.10 分层Testbench 任何现代验证方法的关键概念都是分层的testbench。虽然这个过程可能看起来使测试工作台更复杂，但它实际上有助于将代码分成可以单独开发的更小的部分，从而使您的任务更容易。不要试图编写一个可以随机生成所有类型刺激的例程，包括合法的和非法的，以及用多层协议注入错误。这个例行程序很快就会变得复杂和不可维护。此外，一种分层的方法允许重用和封装验证IP (VIP)，这是面向对象的概念。 1.10.1 一个平面Testbench 当您第一次学习Verilog并开始编写测试时，它们可能看起来像示例1.1中的底层代码，该代码进行了简化的APB (AMBA外围总线)编写。(VHDL用户可能也写过类似的代码)。 样本1.1驱动APB引脚 在编写了几天这样的代码之后，您可能会意识到它非常重复，因此您为总线编写等常见操作创建了任务，如示例1.2所示。 例1.2一个驱动APB引脚的任务 现在您的测试平台变得更简单了，如示例1.3所示 示例1.3低级Verilog测试 通过采取常见操作(如重置、总线读取和写入)并将它们放入例程中，您将变得更有效率，犯的错误也更少。物理层和命令层的创建是分层测试工作台的第一步。 1.10.2 信号层和命令层 图1.9显示了测试台的底层。 图1.9信号层和命令层 底部是包含被测设计和连接到测试台的信号层。 再上一层是命令层。DUT的输入由运行单个命令的驱动程序驱动，例如总线读或写。DUT的输出驱动接受信号转换的监视器，并将它们组合成命令。断言也跨越命令/信号层，因为它们查看单个信号，也跨越整个命令进行更改。 1.10.3 功能层 图1.10显示了添加了功能层的testbench，该层向下提供给命令层。代理块(在VMM中称为事务处理程序)接收更高级别的事务，如DMA读或写，并将它们分解为单独的命令或事务。这些命令也被发送到预测事务结果的记分牌。该检查器将来自监视器的命令与记分板上的命令进行比较。 图1.10添加功能层的测试台架 1.10.4 层的场景 功能层由场景层的generator驱动，如图1.11所示。什么是情景?请记住，作为一名验证工程师，你的工作是确保该设备完成其预期任务。一个示例设备是MP3播放器，它可以同时从其存储中播放音乐，从主机下载新音乐，并响应用户的输入，例如调整音量和音轨控制。每一个操作都是一个场景。下载一个音乐文件需要几个步骤，比如控制寄存器的读写设置操作，多路DMA写入传输歌曲，然后再进行另一组读写操作。测试工作台的场景层使用参数(如跟踪大小和内存位置)的约束随机值编排所有这些步骤。 图1.11添加场景层的测试台架 testbench环境中的区块(在图1.11中的虚线内)是在开发开始时编写的。在项目期间，它们可能会发展，您可能会添加功能，但是这些块不应该因单个测试而改变。这是通过在代码中留下“钩子”来实现的，这样测试就可以改变这些块的行为，而不必重写它们。您可以使用工厂模式(第8.2节)和回调(第8.7节)创建这些钩子。 1.10.5 测试层和功能覆盖 现在你在测试台的顶部，在测试层，如图1.12所示。在DUT块之间发生的设计错误很难发现，因为它们涉及到多个人员阅读和解释多个规范。 这个最高层次的测试是指挥:他不演奏任何乐器，而是引导别人的努力。测试包含创建刺激的约束条件。 功能覆盖度量在完成验证计划需求过程中的所有测试的进度。功能覆盖代码在项目中发生变化随着各种标准的完成。这段代码经常被修改，因此它不是环境的一部分。 您可以在一个受限随机环境中创建一个定向测试。只需将一段定向测试代码插入到随机序列的中间，或者将两段代码并行放置。定向代码执行你想要的工作，但是随机的“背景噪音”可能会导致一个bug变得可见，也许是在一个你从未考虑过的块中。 图1.12所有层的完整测试台架 您的测试台中需要所有这些层吗?答案取决于你的DUT是什么样的。一个复杂的设计需要一个复杂的测试平台。您总是需要测试层。对于简单的设计，场景层可能非常简单，您可以将其与代理合并。在评估测试设计的工作量时，不要计算门的数量;数一数设计师的数量。每当您向团队中添加另一个人时，您就增加了对规范的不同解释的机会。典型的硬件团队需要为每个设计师配备两个以上的验证工程师。 你可能需要更多的层。如果你的DUT有几个协议层，每个都应该在testbench环境中有自己的层。例如，如果您有用IP包装并以以太网数据包发送的TCP流量，请考虑使用三个单独的层进行生成和检查。更好的是，使用现有的验证组件。 关于图1.12的最后一点说明。它显示了块之间的一些可能的连接，但您的测试工作台可能有不同的设置。测试可能需要深入到驱动层以强制产生物理错误。这里所描述的只是指导方针——让你的需求指导你所创造的东西。 1.11 构建分层测试平台 现在是时候看看前面的图并学习如何将组件映射到SystemVerilog结构中了。 1.11.1 创建简单的驱动程序 首先，仔细看看其中一个街区，司机。 图1.13驱动器连接 如图1.13所示的驱动程序接收代理的命令。驱动程序可能会注入错误或增加延迟。然后，它将命令分解为单独的信号更改，如总线请求和握手。这种testbench块的通用术语是“事务处理器”，其核心是一个循环。示例1.4中显示了事务处理程序的示例代码。 示例1.4基本事务处理代码 第五章介绍了基本的面向对象编程以及如何创建一个对象，该对象包含事务处理程序的程序和数据。事务处理程序的另一个例子是代理。它可以将一个复杂的事务(如DMA)分解为多个总线命令。同样在第5章，您将看到如何构建一个包含数据和例程组成命令的对象。这些对象是使用SystemVerilog邮箱在事务器之间发送的。在第7章中，您将了解在不同层之间交换数据和同步事务的许多方法。 1.12 模拟环境阶段 到目前为止，您已经了解了环境的组成部分。这些部件什么时候执行?您需要清楚地定义协调测试工作台的阶段，以便项目的所有代码一起工作。三个主要阶段是构建、运行和总结。每个步骤都分为更小的步骤。这三个阶段是UVM和VMM许多阶段的一个子集。 构建阶段分为以下几个步骤: 生成配置:随机化DUT和周围环境的配置。 构建环境:根据配置分配和连接testbench组件。testbench组件只存在于testbench中，与使用RTL代码构建的设计中的物理组件相反。例如，如果配置选择了三个总线驱动程序，testbench将在这个步骤中分配和初始化它们。 重置DUT。 配置DUT:根据第一步生成的配置，加载DUT命令寄存器。 运行阶段是测试实际运行的阶段。它有以下步骤: 启动环境:运行测试工作台组件，如BFMs和刺激生成器。 运行测试:开始测试，然后等待它完成。判断一个定向测试何时完成是很容易的，但是这样做对于一个随机测试来说可能很复杂。您可以使用testbench层作为指南。从顶层开始，等待一层从上一层(如果有的话)耗尽所有的输入，等待当前层变为空闲，然后等待下一个较低的层。您还应该使用超时检查器来确保DUT或testbench不会锁定。 总结阶段有两个步骤: 清扫:在最低层完成后，您需要等待最终的事务从DUT中清空。 报告:一旦DUT空闲，清理测试台中丢失的数据。有时记分牌上保存着从未公开的交易，可能是因为它们被DUT丢弃了。有了这些信息，您可以创建关于测试是通过还是失败的最终报告。如果失败，请确保删除所有功能覆盖结果，因为它们可能不正确。 如图1.12所示，测试启动环境，环境依次运行每个步骤。更多细节可在第8章中找到。 1.13 最大代码重用 为了验证具有数百个特性的复杂设备，你必须编写数百个定向测试。如果使用受限随机刺激，就会编写更少的测试。相反，真正的工作是构建testbench，它包含所有较低的testbench层:场景、功能、命令和信号。所有测试都使用这个测试平台代码，所以它仍然是通用的。 这些指导方针似乎是在推荐一个过于复杂的测试平台，但是请记住，您在测试平台中放入的每一行都可以在每个测试中删除一行。如果您知道您将创建几十个测试，那么创建一个更复杂的测试平台将有很高的回报。当你读第八章的时候要记住这一点。 1.14 Testbench性能 如果这是您第一次看到这种方法，那么与直接测试相比，您可能会对它的工作方式感到不安。一个常见的反对意见是testbench的性能。定向测试通常在几秒钟内模拟，而约束随机测试将在状态空间中徘徊几分钟甚至几小时。这个论证的问题是它忽略了一个真正的验证瓶颈:您创建测试所需的时间。您可以在一天内手工制作一个定向测试，然后在一到两天内调试它，手工验证结果。与您个人投入的时间相比，实际的模拟运行时间显得微不足道。 创建约束随机测试需要几个步骤。第一步也是最重要的一步是构建分层测试平台，包括自检部分。这项工作的好处是由所有测试共享的，因此值得付出努力。第二步是创建特定于验证计划中的目标的刺激。您可能会制造随机的约束，或者以迂回的方式注入错误或违反协议。构建其中一个可能比进行几个定向测试需要更多的时间，但回报将会更高。一个尝试不同协议变体的受限随机测试比在相同时间内创建的少量定向测试更有价值。 约束随机测试的第三个步骤是功能覆盖。这个任务从创建一个强大的验证计划开始，该计划有明确的目标，可以很容易地衡量。接下来，您需要创建SystemVerilog代码，该代码将检测添加到环境中并收集数据。最后，您必须分析结果，以确定您是否达到了目标，以及，如果没有，您应该如何修改测试。 1.15 结论 电子设计的复杂性不断增长，需要一个现代的、系统的、自动化的方法来创建测试工作台。随着项目从规范的每个步骤到RTL编码、gate合成、制造，最后到用户手中，修复bug的成本会增长十倍。定向测试一次只测试一种功能，不能产生设备在现实世界中会受到的复杂刺激和配置。为了产生健壮的设计，您必须使用受限的随机刺激与功能覆盖相结合，以创建尽可能广泛的刺激范围。 1.16 练习 编写算术逻辑单元(ALU)的验证计划: 异步主动高输入复位 输入时钟 4位符号输入，A和B 在输入时钟的正边缘注册的5位有符号输出C。 4操作码 Add: A + B Sub: A−B 位操作转化: 减少或:B 块级测试的优点和缺点是什么?为什么? 在系统级进行测试的优点和缺点是什么?为什么? 定向测试的优点和缺点是什么?为什么? 受限随机测试的优点和缺点是什么?为什么? "},"articles/chapter-02.html":{"url":"articles/chapter-02.html","title":"第二章　　数据类型","keywords":"","body":"第二章 数据类型 与Verilog相比，SystemVerilog提供了许多改进的数据结构。其中一些是为设计人员创建的，但也可以用于testbench。在本章中，您将了解对验证最有用的数据结构。 System Verilog引入了具有以下优点的新数据类型。 两种状态:更好的性能，减少内存使用 队列、动态数组和关联数组:减少内存使用，内置搜索和排序支持 类和结构:支持抽象数据结构 联合和打包结构:允许对同一数据的多个视图 string:内置字符串支持 枚举类型:代码更容易编写和理解 2.1 内置的数据类型 Verilog-1995有两种基本数据类型:变量和网络，它们都包含4种状态值:0、1、Z和x。RTL代码使用变量来存储组合值和序列值。变量可以是无符号的单位或多位(reg [7:0] m)、有符号的32位变量(整数)、无符号的64位变量(时间)和浮点数(实数)。变量可以被组合成具有固定大小的数组。网络用于连接设计的各个部分，如门原语和模块实例。网有多种形式，但大多数设计人员使用标量和向量线来连接设计块的端口。最后，所有的存储都是静态的，这意味着在整个模拟中所有的变量都是活的，例程不能使用堆栈来保存参数和局部值。Verilog-2001允许您在静态和动态存储(比如堆栈)之间切换。 SystemVerilog添加了许多新的数据类型，以帮助硬件设计人员和验证工程师。 2.1.1 逻辑类型 在Verilog中，总是让新用户摸不着头脑的一件事是reg和wire之间的区别。当驾驶一个端口时，你应该使用哪个?那么当你连接方块的时候呢?SystemVerilog改进了经典的reg数据类型，除了作为一个变量外，它还可以由连续赋值、门和模组驱动。它被赋予了同义词逻辑，就像一些刚接触Verilog的人认为的那样，reg声明了一个数字寄存器，而不是一个信号。逻辑信号可以在任何使用网络的地方使用，除非逻辑变量不能由多个结构驱动程序驱动，例如当你为双向总线建模时。在本例中，变量需要是net类型，比如wire，以便SystemVerilog能够解析多个值以确定最终值。 样例2.1显示了SystemVerilog逻辑类型。 使用逻辑类型的示例2.1 您可以使用逻辑类型来查找网络列表bug，因为这种类型只能有一个驱动程序。与其尝试在reg和wire之间进行选择，不如将所有信号声明为逻辑，如果有多个驱动程序，就会得到编译错误。当然，任何你想要有多个驱动程序的信号，比如一个双向总线，应该用一个网络类型来声明，比如wire或tri。 2.1.2 国数据类型 与声明为4状态类型的变量相比，SystemVerilog引入了几种2状态数据类型，以改进模拟器性能并减少内存使用。最简单的类型是位，它总是无符号的。有四种有符号的两状态类型:byte、shortint、int和longint。如示例2.2所示。 示例2.2签名数据类型 您可能想使用byte之类的类型来替换更详细的声明，如logic[7:0]。硬件设计人员应该小心，因为这些新类型是有符号变量，所以字节变量最多只能数到127，而不能数到255 期望。(取值范围为−128 ~ +127)您可以使用无符号字节，但这比仅使用bit[7:0]要详细得多。如第6章所述，带符号的变量也会导致随机化的意外结果。 将2-状态变量连接到被测试的设计时要小心，特别是它的输出。如果硬件试图驱动X或Z，这些值将被转换为2状态值，您的testbench代码可能永远不会知道。不要试图记住它们是否被转换为0或1;相反，总是检查未知值的传播。 使用$isunknown()操作符，如果表达式的任意位是X或Z，则返回1，如示例2.3所示。 示例2.3检查4个状态的值 格式%0t和参数$time打印当前的模拟时间，用$timeformat()例程指定。时间值将在3.7节中更详细地讨论。 2.2 固定大小的数组 除了一维的、固定大小的Verilog-1995数组之外，SystemVerilog还提供了几种样式的数组。此外，还添加了许多新特性来支持这些数据类型。 2.2.1 声明和初始化固定大小的数组 Verilog要求必须在声明中给出数组的高低限制。由于几乎所有数组都使用0的低索引，因此SystemVerilog允许您使用只给出数组大小的快捷方式，这类似于C的风格，如示例2.4所示。 示例2.4声明固定大小的数组 如何计算处理给定数组大小所需的位数?SystemVerilog具有$clog2()函数，用于计算以2为基数的log的上限，如示例2.5所示。 示例2.5计算内存的地址宽度 通过在变量名之后指定维度，可以创建多维固定大小的数组。样例2.6创建几个整数的二维数组，8个条目乘4，并将最后一个条目设置为1。多维数组是在Verilog-2001中引入的，但是紧凑声明样式是新的。 样例2.6声明和使用多维数组 如果您的代码意外地尝试从越位地址读取，System- Verilog将返回数组元素类型的默认值。这只是意味着包含4种状态类型的数组(如logic)将返回X，而包含2种状态类型的数组(如int或bit)将返回0。这适用于所有的数组类型-固定的，动态的，关联的，或队列，如果你的地址有X或Z，也适用。 许多SystemVerilog模拟器将每个元素存储在32位的单词边界上。因此，byte、shortint和int都存储在单个单词中，而longint则存储在两个单词中。 未打包的数组，例如示例2.7中所示的数组，将值存储在单词的下半部分，而上半部分是未使用的。字节数组b_unpack以三个单词的形式存储，如图2.1所示。 样例2.7解包的数组声明 b_unpack [0] b_unpack [1] b_unpack [2] 图2.1未封装阵列存储 打包的数组在2.2.6节中解释。 模拟器通常在两个或多个连续的单词中存储4种状态类型，如逻辑和整数，使用两倍的存储作为2状态变量。 2.2.2 数组的文字 示例2.8展示了如何使用数组字面量初始化数组，该字面量是一个apos- trophe，后跟花括号中的值。(这不是用于编译器指令和宏的重音表。)您可以一次设置一些或所有元素。您可以通过在花括号前放置一个计数来复制值。 样例2.8初始化数组 注意，在示例2.8中，数组ascend的声明包含了一个初始值。2009 LRM声明这些变量必须在静态块中声明，或者使用static关键字。因为这本书建议总是声明你的测试模块和程序为自动，你需要添加静态关键字的声明加上初始化，当它是在一个初始块。 2009年LRM的一个很棒的新特性是使用%p格式说明符进行打印。这将打印一个与数据对象的值等价的赋值模式。您可以在SystemVerilog中打印任何数据类型，包括数组、结构、类等等。样例2.9演示了如何打印带有%p格式说明符的数组。 样品2.9打印，%p打印说明 2.2.3 基本的数组操作——for和Foreach 操作数组最常见的方法是使用for或foreach循环。在样例2.10中，变量i被声明为for循环的局部变量。SystemVerilog函数$size返回数组的大小。在foreach循环中，您在方括号中指定数组名称和索引，然后SystemVerilog自动遍历数组的所有元素。索引变量会自动为您声明，并且是循环的局部变量。 示例2.10使用带有for-和foreach循环的数组 注意，在样例2.11中，多维数组的foreach循环的语法可能与您预期的不同。不是用单独的方括号[i][j]列出每个下标，而是用逗号:[i,j]组合起来。 样例2.11初始化并逐步遍历多维数组 示例2.11的输出如示例2.12所示。 示例2.12打印多维数组值的输出 如果不需要单步遍历所有维度，可以省略foreach循环中的某些维度。示例2.13打印一个矩形中的二维数组。它在外部循环中执行第一个维度，然后在内部循环中执行第二个维度。 示例2.13打印多维数组 示例2.13产生示例2.14中所示的输出。 示例2.14打印多维数组值的输出 最后，foreach循环使用原始声明中的范围进行迭代。数组f[5]等价于f[0:4]， foreach (f[i])等价于for (int i=0;我+ +)。对于数组rev[6:2]， foreach(rev[i])语句等价于for(int i=6;我> = 2;我——)。 2.2.4 基本的数组操作-复制和比较 您可以在没有循环的情况下执行数组的聚合比较和复制。(聚合操作适用于整个数组，而不是仅适用于单个元素。)比较仅限于公正的平等和不平等。示例2.15展示了几个比较示例。的吗?:条件运算符是一个小型的if-else状态。在样例2.15中，它用于在两个字符串之间进行选择。最后的比较使用了一个数组切片src[1:4]，它创建了一个包含4个元素的临时数组。 样例2.15数组复制和比较操作 在不同大小的固定数组之间复制会导致编译错误。不能在数组上执行加法或减法等聚合算法，例如a = b + c。相反，使用foreach循环。对于像xor这样的逻辑操作，必须使用循环或者使用2.2.6节中描述的打包数组。 2.2.5 位和数组下标，终于在一起了 在Verilog-1995中，一个常见的问题是不能同时使用数组和位子脚本。Verilog-2001取消了对固定大小数组的这一限制。样本 输出数组的第一个元素(二进制101)、它的最低位(1)和后面两个更高位(二进制10)。 样例2.16同时使用字和位下标 尽管这个更改对SystemVerilog并不新鲜，但许多用户可能不知道Verilog-2001中的这个有用的改进。供你参考- a中的双逗号 $display语句插入一个空格。 2.2.6 拥挤的数组 对于某些数据类型，您可能既希望访问整个值，又希望将其划分为更小的元素。例如，您可能有一个32位寄存器，有时您希望将其作为4个8位值处理，而在其他时候则希望将其作为一个单独的无符号值处理。SystemVerilog打包的数组被视为数组和单个值。与未打包的数组不同，它被存储为一个没有未使用空间的连续位集。 2.2.7 包装数组的例子 填充的位和数组尺寸作为类型的一部分指定在变量名之前。这些尺寸必须指定为[msb:lsb]格式，而不是[size]。样例2.17显示了可变的bytes，一个由四个字节组成的数组，存储在一个32位的单词中，如图2.2所示。 示例2.17打包的数组声明和使用 字节 字节[3][7] 图2.2排列排列 你可以混合包装和未包装的尺寸。您可能想要创建一个表示可以以位、字节或长字访问的内存的数组。样本 2.18显示了barray，这是一个由5个封装元素组成的未封装数组，每个元素宽4个字节，如图2.3所示存储在内存中。 示例2.18混合打包/未打包数组的声明 barray [0] [3] barray [0] [1] [6] 巴林[0]巴林[1]巴林[2]巴林[3]巴林[4] 图2.3封装阵列位布局 使用单个下标，可以得到一个数据字barray[0]。有了两个下标，你得到一个字节的数据，barray[0][3]。通过三个下标，你可以访问一个单独的位，barray[0][1][6]。因为维度是在名称barray[5]之后指定的，所以该维度是未打包的，所以必须至少给出一个下标。 示例2.18的最后一行拷贝在两个打包的数组之间。因为底层的值只是位，所以即使数组有不同的维数，也可以复制。 2.2.8 选择已打包和未打包的数组 你应该选择哪个——一个已打包的数组还是一个未打包的数组?如果需要转换为标量或从标量转换，打包的数组是很方便的。例如，您可能需要将内存作为字节或单词引用。图2.3中的阵列可以满足这一要求。任何类型的数组都可以打包，包括动态数组、队列和关联数组，这些将在2.3、2.4和2.5节中解释。 如果你需要等待数组的变化，你必须使用一个打包的数组。当内存值发生变化时，您的测试工作台可能需要唤醒，所以您需要使用@操作符。这只适用于标量值和已打包数组。在2.18示例中，你可以阻塞变量lw或barray[0]，但不能阻塞整个数组barray，除非你将其展开:@(barray[0]或barray[1]或barray[2]或barray[3]或barray[4])。 2.3 动态数组 到目前为止显示的基本Verilog数组类型被称为固定大小的数组，因为它的大小是在编译时设置的。如果直到运行时才知道数组的大小，该怎么办?例如，您可能希望在模拟开始时生成随机数量的事务。如果将事务存储在一个固定大小的数组中，那么该数组必须足够大，以容纳最大数量的事务，但通常会容纳更少的事务，从而浪费内存。SystemVerilog提供了一个动态数组，可以在模拟期间分配和调整数组大小，从而使模拟消耗的内存最少。 动态数组用空的字下标[]来声明。这意味着你不需要在编译时指定数组大小;相反，在运行时给出它。数组最初是空的，因此必须调用new[]构造函数来分配空间，并在方括号中传递条目的数量。如果将数组名称传递给新的[]构造函数，这些值将被复制到新的元素中，如示例2.19所示。 示例2.19使用动态数组 在样例2.19中，A行调用new[5]来分配5个数组元素。动态数组dyn现在拥有5个int值。行B将数组中每个元素的值设置为其索引值。第C行分配另一个数组并将dyn的内容复制到其中。行D和行E表示数组dyn和d2是分开的。第F行分配20个新元素，并将dyn现有的5个元素复制到数组的开头。然后重新分配原来的5个元素的dyn数组。结果是dyn指向一个20个元素的数组。最后一次调用new[]会分配100个元素，但不会复制现有的值。旧的20个元素的数组被重新分配。最后，第H行删除dyn数组。 函数的作用是:返回一个固定数组或动态数组的大小。动态数组有几个内置例程，比如delete和size。 如果您想声明一个常量数组的值，但不想麻烦地计算元素的数量，则使用带有数组字面量的动态数组。在样例2.20中有9个8位掩码元素。您应该让SystemVerilog计算它们，而不是创建一个固定大小的数组，然后意外地选择了错误的数组大小。 示例2.20为未计数列表使用动态数组 你可以在固定大小的数组和动态数组之间赋值，只要它们具有相同的基类型(比如int)。你可以将动态数组赋值给固定数组，只要它们的元素数量相同。 将固定大小的数组复制到动态数组时，SystemVerilog将调用 新建[]构造函数来分配空间，然后复制值。 您可以拥有多维动态数组，只要您在构建子数组时小心谨慎。请记住，SystemVerilog中的多维数组可以看作是其他数组的数组。首先，您需要构造最左边的维度。然后构造子数组。在示例2.21中，每个子数组都有不同的大小。 示例2.21多维动态数组 2.4 队列 SystemVerilog引入了一种新的数据类型队列，它结合了链表和数组的优点。与链表一样，您可以在队列中的任何位置添加或删除元素，而不会像动态数组那样影响性能，因为动态数组必须分配一个新的元素 数组并复制整个内容。与数组一样，您可以直接访问带有索引的任何元素，而不用像链表那样在前面插入元素的情况下进行步进操作。 队列使用包含美元符号:[$]的单词下标声明。队列的元素从0到$编号。样例2.22展示了如何使用方法从队列中添加和删除值。注意，队列字面量只有花括号，并且没有数组字面量的第一个撇号。 SystemVerilog队列类似于标准模板库的deque数据类型。您可以通过添加元素来创建队列。SystemVerilog通常会分配额外的空间，以便您可以快速插入额外的元素。如果添加的元素足够多，以至于队列耗尽了多余的空间，则SystemVerilog会自动分配更多的元素。因此，您可以在不影响动态数组性能的情况下增加或减少队列，并且SystemVerilog会为您跟踪空闲空间。注意，永远不要为队列调用new[]构造函数。 示例2.22队列方法 LRM不允许使用上述方法将队列插入到另一个队列中，尽管有些模拟器允许这样做。 可以使用单词下标和连接来代替方法。作为一种捷径，如果你把$放在一个范围的左边，例如[$:2]，$代表最小值[0:2]。右边的$，如[1:$]，代表最大值[1:2]，在样本2.23的初始块的第一行。 示例2.23队列操作 队列元素存储在相邻的位置，因此可以有效地前后推入和弹出元素。无论队列有多大，这都需要固定的时间。在队列中间添加和删除元素需要移动现有数据以腾出空间。这样做的时间会随着队列的大小线性增长。 可以将固定或动态数组的内容复制到队列中。 2.5 关联数组 如果你偶尔想要创建一个大数组，动态数组很好，但如果你想要更大的数组呢?也许您正在为一个具有数gb地址范围的处理器建模。在一个典型的测试中，处理器可能只触及几百或几千个包含可执行代码和数据的内存位置，因此分配和初始化千兆字节的存储是浪费的。 SystemVerilog提供了关联数组，将条目存储在稀疏矩阵中。这意味着，虽然可以寻址一个非常大的地址空间，但SystemVerilog只在写入元素时为其分配内存。在下面的图片中，关联数组的值为0:3、42、1000、4521和200,000。用于存储这些数据的内存远远小于存储一个包含20万个条目的固定或动态数组所需的内存，如图2.4所示。 数据索引 0…3 42 1000 4521 200000年 图2.4关联数组 关联数组可以被模拟器存储为树或哈希表。当您需要存储具有广泛分隔的索引值的数组(例如用32位地址或64位数据值索引的数据包)时，这种额外开销是可以接受的。关联数组是用方括号中的数据类型声明的，比如[int]。或(包)。样例2.24演示了如何声明、初始化、打印和步进执行关联数组。 声明、初始化和使用关联数组 样本2.24有关联数组assoc，它的元素非常分散:1、2、4、8、16等。简单的for循环不能单步遍历它们;您需要使用foreach循环。如果你想要更好的控制，你可以在do…while循环中使用first和next函数。这些函数修改index参数，并根据数组中是否还有元素返回0或1。可以使用num或size函数查找关联数组中的元素数量。 关联数组也可以通过字符串索引寻址，类似于Perl的散列数组。样例2.25读取带有字符串的文件并构建关联数组 切换，这样您就可以快速地从字符串值映射到数字。字符串将在2.15节中得到更详细的解释。 如果试图读取尚未写入的关联数组的元素，SystemVerilog将返回数组基类型的默认值，例如0 (bit或int)表示2状态类型，X (logic)表示4状态类型。模拟器也可以给出警告信息。可以使用exists()函数检查是否分配了元素，如示例2.25所示。 示例2.25使用带有字符串索引的关联数组 可以使用数组字面量和index:element对初始化关联数组，如示例2.26所示。当您打印带有%p的数组时，元素将以相同的格式显示。 样例2.26初始化和打印关联数组 也可以使用通配符下标声明关联数组，如wild[*]。但是，不推荐使用这种样式，因为您几乎允许任何数据类型的索引。由此产生的众多问题之一是foreach循环:foreach(wild[j])中的变量j是什么类型的?整数、字符串、位还是逻辑? 2.6 数组的方法 有许多数组方法可以用于任何未打包的数组类型:固定的、动态的、队列的和关联的。这些例程可以像给出当前数组大小一样简单，也可以像对元素排序一样复杂。如果没有参数，括号是可选的。 2.6.1 数组还原方法 基本的数组缩减方法接受一个数组并将其缩减为单个值，如示例2.27所示。您可以计算所有元素的和、积或执行逻辑操作。 样例2.27数组缩减操作 其他的数组约简方法有or和xor。 SystemVerilog没有专门用于从数组中选择随机元素的方法，因此对于队列和动态数组使用索引$urandom_range(array.size()−1)，对于固定数组、队列、动态和关联数组使用索引$urandom_range($size(array)−1)。关于$urandom_range的更多信息，请参阅6.10节。 如果您需要从关联数组中选择一个随机元素，则需要逐个遍历这些元素，因为没有单行方法可以访问第n个元素。样例2.28展示了如何从关联数组中选择一个随机元素 按整数索引，首先选择一个随机数，然后步进遍历数组。如果数组以字符串为索引，只需将idx的类型更改为字符串。 从关联数组中随机选择一个元素 2.6.2 数组定位方法 数组中最大的值是多少?数组是否包含特定的值?数组定位器方法在未打包的数组中查找数据。首先，您可能会想知道为什么这些函数返回一个值队列。毕竟，数组中只有一个最大值。但是，SystemVerilog需要一个队列来处理从空队列或动态数组请求值的情况。 示例2.29显示了数组定位器方法:min和max函数查找数组中最小和最大的元素。这些方法也适用于关联数组。unique方法返回数组中唯一值的队列——重复值不包括在内。 示例2.29阵列定位器方法:min, max, unique 您可以使用foreach循环搜索数组，但是SystemVerilog可以使用locator方法在一个操作中完成这一操作。with表达式告诉SystemVerilog如何执行搜索，如示例2.30所示。如果要搜索的值在数组中不存在，这些方法将返回一个空队列。 示例2.30数组定位器方法:find 在with子句中，name项被称为迭代器参数，表示数组中的单个元素。您可以将自己的名字放在数组方法的参数列表中，如示例2.31所示。 例2.31声明迭代器实参 样例2.32展示了汇总数组中值子集的各种方法。第一行将项目与7进行比较。该关系返回1 (true)或0 (false)，因此计算结果是数组{1,0,1,0,0}的和。第二个函数将bool- ean结果与被测试的数组元素相乘。所以总数是{9,0,8,0,0,0}的和，也就是17。第三个计算小于8的元素的总数。第四个总数是使用?:条件操作符。最后一个数的是4。 示例2.32数组定位器方法 当您使用with子句组合一个数组缩减(如sum)时，结果可能会让您吃惊。在样例2.32中，sum运算符对 这个表达是正确的。对于样例2.32中的第一个语句，有两个大于7(9和8)的数组元素，因此将count设置为2。 返回索引(如find_ index)的数组定位器方法返回int类型的队列，而不是integer类型的队列。如果在这些语句中使用了错误的队列类型，则代码可能无法编译。 注意SystemVerilog关于操作宽度的规则。通常，如果要添加一组单个位值，SystemVer- ilog将以足够的精度进行计算，不会丢失任何位。但是sum方法使用的是数组的宽度。所以, 如果添加单个位数组的值，结果是单个位，这可能不是您预期的结果。解决方案是使用示例2.33中所示的with表达式。 样例2.33创建单个位数组的和 2.6.3 数组排序和排序 SystemVerilog有几种方法可以更改数组中元素的顺序。您可以对元素排序、颠倒它们的顺序或打乱顺序，如示例2.34所示。注意，这些方法更改了原始数组，这与第2.6.2节中的数组定位器方法不同，后者创建一个队列来保存结果。 样例2.34对数组排序 reverse和shuffle方法没有with-子句，所以它们适用于整个数组。样例2.35展示了如何按子字段对结构排序。结构和填充结构在第2.9节中解释。 样例2.35对结构数组进行排序 只有固定和动态数组，再加上队列才能排序、反转或洗牌。 不能重新排序关联数组。 2.6.4 使用数组定位器方法构建记分牌 数组定位器方法可用于构建记分牌。样例2.36定义了包的结构，然后用这些结构组成的队列创建记分牌。第2.8节介绍如何使用typedef创建结构体。 示例2.36带有数组方法的记分牌 示例2.36中的check_addr()函数在记分板中查找地址。方法的作用是:返回一个int队列。如果队列为空(size==0)，则没有找到匹配。如果队列中有一个成员(size==1)，则找到一个匹配项，check_addr()函数将删除该匹配项。如果队列有多个成员(大小为> 1)，则计分板上有多个与请求地址匹配的报文。 存储数据包信息的更好选择是类，这在第5章中有描述。你可以在2.9节阅读更多关于结构的内容。 2.7 选择存储类型 以下是一些根据灵活性、内存使用、速度和排序选择正确存储类型的指导原则。这些只是经验法则，不同模拟器的结果可能不同。 2.7.1 灵活性 如果在编译时已知数组大小，则选择固定大小的数组;如果在运行时才知道数组大小，则选择动态数组。例如，可变大小的数据包可以很容易地存储在动态数组中。如果你正在编写操作数组的例程，可以考虑只使用动态数组，因为一个例程可以处理任意大小的动态数组，只要元素类型匹配:int、string等。同样，只要元素类型与queue参数匹配，就可以将任意大小的队列传递到例程中。关联数组也可以不考虑大小而传入。但是，带有固定大小数组参数的例程只接受指定长度的数组。 为非标准索引选择关联数组，例如由于值或地址是随机的，所以会被广泛分隔的值。关联数组还可以用于为内容寻址内存建模。 当元素数量在模拟过程中大幅增加或减少时，队列是存储值的一种好方法，例如保存期望值的记分牌。 2.7.2 内存使用情况 如果要减少模拟内存的使用，请使用2状态元素。您应该选择32位的倍数的数据大小，以避免浪费空间。模拟器通常将更小的数据存储在32位字中。例如，如果模拟器将每个元素放入一个32位字中，那么1024字节的数组将浪费3 / 4的内存。打包的数组也可以帮助节省内存。 对于最多容纳1000个元素的数组，您选择的数组类型不会对内存使用产生很大影响(除非这些数组有很多实例)。对于具有1000到100万个活动元素的数组，固定大小和动态数组是内存效率最高的。如果需要包含超过100万个活动元素的数组，您可能需要重新考虑您的算法。 由于添加了额外的指针，队列的访问效率比固定大小的数组或动态数组稍低一些。然而，如果你的数据集经常增长和收缩，并且你将它存储在动态内存中，你将不得不手动调用new[]来分配内存和复制。这是一个昂贵的操作，并且会抹掉使用动态内存的所有收益。 应该使用关联数组对大于几兆字节的内存进行建模。注意，由于指针开销，关联数组中的每个元素占用的内存可能是固定大小或动态大小的数倍。 2.7.3 速度 根据每个时钟周期对数组的访问次数选择数组类型。对于少量的读写操作，您可以使用任何类型，因为与DUT相比，开销较小。当您更频繁地使用数组时，数组的大小和类型很重要。 固定大小的数组和动态数组都存储在连续的内存中，因此无论数组大小如何，任何元素都可以在相同的时间内找到。 对于读写，队列具有与固定大小或动态数组几乎相同的访问时间。可以推入和弹出第一个和最后一个元素，几乎不需要任何开销。在中间插入或删除元素，需要将许多元素上下移动，以腾出空间。如果您需要将新元素插入到一个大队列中，您的测试工作台可能会变慢，因此考虑更改存储新元素的方式。 当读写关联数组时，模拟器必须在内存中搜索元素。LRM没有指定这是如何实现的，但流行的方法是散列表和树。这些数组比其他数组需要更多的计算，因此关联数组是最慢的。 2.7.4 数据访问 由于SystemVerilog可以对任何一维数组(固定大小的、动态的、关联数组加上队列)进行排序，所以您应该根据向数组中添加值的频率来选择数组类型。如果一次性接收到所有值，则选择固定大小或动态数组，这样您只需分配一次数组。如果数据缓慢地进入，那么选择一个队列，因为向头部或尾部添加新元素是非常高效的。 如果您有唯一的和不连续的值，例如{1,10,11,50}，您可以将它们作为索引存储在关联数组中。使用例程 首先，next和prev可以在关联数组中搜索一个值并找到连续的值。列表是双向链接的，因此可以找到比当前值大或小的值。这两种方法都支持删除值。然而，关联数组在访问给定的索引元素时要快得多。例如，可以使用位的关联数组来保存预期的32位值。创建值后，写入该位置。当需要查看给定值是否已写入时，请使用exists函数。当处理一个元素时， 使用delete将其从关联数组中删除。 2.7.5 选择最佳的数据结构 下面是一些关于选择数据结构的建议。 网络数据包。属性:固定大小，顺序访问。对于固定大小或可变大小的数据包，使用固定大小或动态数组。 计分板的期望值。属性:数组大小直到运行时才知道，通过值访问，并且大小不断变化。通常，当您在模拟过程中不断添加和删除元素时，请使用队列。如果可以给每个事务一个固定的ID，比如1、2、3、…，那么可以将其用作队列的索引。如果事务中充满了随机值，则可以将它们放入队列并搜索惟一值。如果记分板可能有数百个元素，而您经常从中间插入和删除它们，那么关联数组可能会更快。如果您将事务建模为对象，则记分牌可以是句柄队列。有关类的更多信息，请参阅第5章。 排序结构。如果数据以可预测的顺序出现，则使用队列;如果顺序未指定，则使用关联数组。如果记分牌从不需要搜索，那么只需将预期值存储在邮箱中，如第7.6节所示。 建模非常大的内存，超过一百万个条目。如果不需要每个位置，可以使用关联数组作为稀疏内存。如果您确实计划访问每个位置，请尝试不需要那么多实时数据的不同方法。确保使用压缩到32位的2状态值来保存模拟内存。 文件中的命令名或操作码。属性:将字符串转换为固定值。从文件中读取字符串，然后使用命令作为字符串索引在关联数组中查找命令或操作码。 使用typedef创建新类型 您可以使用typedef语句创建新的类型。例如，您可能有一个ALU，可以在编译时配置为使用8、16、24或32位操作数。在Verilog中，您将为操作数宽度定义一个宏，为示例2.37中所示的类型定义另一个宏。 示例2.37 Verilog中用户定义的类型宏 您实际上并不是在创建一个新类型;你只是在执行文本替换。在SystemVerilog中，您创建了一个新类型，如示例2.38所示。除了基本的uint之外，本书使用了用户定义类型使用后缀“_t”的惯例。 示例2.38 SystemVerilog中的用户定义类型 通常，SystemVerilog允许您在这些基本类型之间进行复制，而不会发出警告，如果宽度不匹配，则扩展或截断值。 请注意，parameter和typedef语句可以放在一个包中，这样它们就可以在设计和测试工作台之间共享，如2.10节所示。 您可以创建的最有用的类型之一是无符号、2状态、32位整数，如示例2.39所示。testbench中的大多数值都是正整数，比如字段长度或接收的事务数，因此使用带符号整数可能会导致问题。将uint的定义放在一个通用定义包中，这样它就可以在任何地方使用。 示例2.39 uint的定义 定义新数组类型的语法并不明显。您需要将数组下标放在新名称上。样例2.40创建了一个新类型fixed_array5_t，它是一个包含5个元素的固定数组。然后声明该类型的数组并初始化它。 样例2.40自定义数组类型 对于用户定义的类型，一个很好的用法是关联数组，它必须声明一个简单类型的索引。您可以将示例2.24更改为使用64位值，更改第一行，如示例2.41所示。 样例2.41用户定义的关联数组索引 2.8 创建用户定义的结构 Verilog最大的限制之一是缺乏数据结构。在SystemVer- ilog中，可以使用struct语句创建结构，这与c中可用的语句类似。然而，结构只是类功能的一个子集，所以在testbench中使用类，如第5章所示。正如Verilog模块结合了数据(信号)和代码(总是/初始块加上例程)一样，类结合了数据和例程，从而形成一个易于调试和重用的实体。结构只是将数据字段分组在一起。如果没有对数据进行操作的代码，您只创建了解决方案的一半。 由于结构体只是数据的集合，所以它可以被合成。如果希望在设计代码中为复杂数据类型(如像素)建模，请将其放入结构中。这也可以通过模块端口传递。最后，当您想生成受限随机数据时，请查看类。 2.8.1 创建一个结构和一个新类型 您可以将几个变量组合成一个结构。样例2.42创建了一个名为pixel的结构，它有三个无符号字节，分别为红色、绿色和蓝色。 样例2.42创建单个像素类型 前面声明的问题是它创建了这种类型的单个像素。为了能够使用端口和例程共享像素，您应该创建一个新类型，如示例2.43所示。 示例2.43像素结构体 在声明结构时使用后缀“_s”。这使得更容易发现用户定义的类型，简化了共享和重用代码的过程。 2.8.2 初始化结构 可以像数组一样将多个值赋给结构体，可以在声明中，也可以在过程赋值中。只需用撇号和大括号将值括起来，如示例2.44所示。 样例2.44初始化结构体 2.8.3 使几个类型的联合 在硬件中，寄存器中一组位的解释可能依赖于其他位的值。例如，一个处理器指令可能有许多基于操作码的布局。立即模式操作数可以在操作数字段中存储一个文字值。对于整数指令和浮点指令，这个值可能被不同的解码。样例2.45将无符号位向量b和整数i存储在同一个位置。 示例2.45使用typedef创建一个联合 在声明联合时使用后缀“_u”。 当你经常需要用几种不同的格式读写一个寄存器时，联合是很有用的。但是，不要太过火，尤其是为了节省内存。联合可以帮助从一个结构中挤出几个字节，但代价是必须创建和维护更复杂的数据结构。相反，创建一个带有判别变量的类，如8.4.4节所示。这个“类” 变量指示您拥有哪种类型的事务，以及要读、写和随机化哪些字段。如果您只需要一个值数组，加上所有的位，请使用2.2.6节中描述的打包数组 2.8.4 包装结构 SystemVerilog允许您通过使用打包的结构更多地控制位在内存中的布局。一个打包的结构被存储为一组连续的位，没有未使用的空间。示例2.43中像素的结构有三个值，所以它存储在三个长单词中，尽管它只需要三个字节。您可以使用packed关键字指定它应该被压缩到尽可能小的空间中，如示例2.46所示。 样品2.46包装结构 当底层位表示数值或试图减少内存使用时，使用打包结构。例如，您可以将几个位字段打包成一个寄存器。或者您可以将操作码和操作数字段打包在一起，生成一个包含整个处理器指令的值。 2.8.5 选择包装和未包装的结构 当您试图在已打包和未打包的结构之间进行选择时，请考虑该结构最常用的方式以及元素的对齐方式。如果您计划对结构进行聚合操作，比如复制整个结构，那么打包结构会更有效。但是，如果代码访问单个成员多于访问整个结构，则使用未打包结构。如果元素没有按字节对齐，则性能差异更大 边界、大小与典型的字节不匹配，或者有处理器使用的word指令。在封装结构中读取和写入奇数大小的元素需要昂贵的移位和掩码操作。 2.9 2.10包 在项目开始时，您需要创建新的类型和参数。例如，如果您的处理器与您公司的ABC总线通信，那么您的testbench需要定义ABC数据类型，以及指定总线宽度和时间的参数。另一个项目可能希望使用这些类型，以及XYZ总线的类型。 您可以为每个总线创建单独的文件，并在编译期间使用'include语句引入文件。但是，与每个总线相关联的每个名称必须是惟一的，即使是那些内部变量也必须是惟一的。如何组织这些类型以避免名称冲突? SystemVerilog包允许您在模块、包、外加程序和接口之间共享声明，这将在第4章中描述。样本 2.47显示了ABC总线的包。 样品2.47包装为ABC总线 使用import语句从包中导入符号。当一个符号没有在通常的搜索路径中定义时，编译器只在导入的包中查找。在样例2.48中，如果没有同名的局部变量，则第一个import语句将使符号abc_data_width、abc_data_t和timeout可见。ABC中的变量message被模块中的变量隐藏了。 样例2.48导入包 如果您真的想看到ABC中的消息变量，请使用ABC::message。您可以使用作用域操作符::从包中导入特定的符号。 样例2.49从ABC中导入所有符号，外加XYZ中的timeout变量。 样例2.49从包中导入选定的符号 包只能看到自己内部定义的符号，或者它们导入的包。你不能有对符号的层次引用，比如信号、程序或者来自包外部的模块。可以将包看作是完全独立的，能够在需要的地方插入，没有外部依赖项。 一个包可以包含例程和类，如5.4节所示。 2.10 类型转换 SystemVerilog有几个规则来确保表达式的计算很少或不会损失准确性。例如，如果添加两个8位的值，添加的精度为9位，以避免溢出。将两个8位值相乘，SystemVerilog将计算一个16位结果。 SystemVerilog中数据类型的激增意味着您可能需要在它们之间进行转换。如果源和目标变量之间的位布局相同(例如整数和枚举类型)，则在这两个值之间进行强制转换。如果位布局不同，例如字节和字的数组，使用流运算符来重新排列位，如2.12节所述。 2.10.1 静态铸造 静态强制转换操作在不检查值的情况下转换两种类型。指定目标类型、撇号和要转换的表达式，如示例2.50所示。注意，Verilog总是隐式地在类型(例如整数和实数)之间进行转换，也在不同的宽度向量之间进行转换。 使用静态类型转换int和real之间的转换 2.10.2 2.11.2 动态投 动态类型转换$cast允许检查越界值。参见 2.13.3查看枚举类型的解释和示例。 当您希望SystemVerilog使用更精确的类型时，如对单个位数组使用sum方法时，请使用静态强制转换。在从具有比目标更多值的类型(如int)转换为枚举变量时，请使用动态强制转换。 2.11 流媒体运营商 当在赋值操作的右侧使用时，流操作符>接受一个表达式、结构或数组，并将其打包到一个位流中。>>操作符从左向右流数据，而 示例2.51基本流操作符 您可以使用许多连接操作符{}来执行相同的操作，但流操作符更紧凑，更易于阅读。 如果需要打包或解包数组，请使用流操作符在不同元素大小的数组之间进行转换。例如，可以将字节数组转换为单词数组。您可以使用固定大小的数组、动态数组和队列。样例2.52在队列之间进行转换，但也可用于动态数组。数组元素会根据需要自动分配。 示例2.52使用流操作符在队列之间转换 数组之间的流的一个常见错误是数组下标不匹配。数组声明中的下标[256]等价于[0:255]，而不是[255:0]。由于许多数组都是用下标[high:low]来声明的， 将它们流到具有下标[size]的数组中会导致元素以相反的顺序结束。同样，将声明为bit [7:0] src[255:0]的未打包数组流到声明为bit [7:0] [255:0] dst的已打包数组将打乱值的顺序。打包的字节数组的正确声明是bit [255:0] [7:0] dst。 您还可以使用流运算符将结构(如ATM单元)打包和解包到字节数组中。在样例2.53中，一个结构被流到一个动态字节数组中，然后字节数组被流回该结构中。 示例2.53在结构体和带有流操作符的数组之间转换 2.12 枚举类型 枚举类型允许您创建一组相关但唯一的常量，比如状态机或操作码中的状态。在经典的Verilog中，你必须使用text mac- ros。它们的全局作用域太宽，它们的值可能在调试器中不可见。枚举创建限制为一组指定名称的强类型变量。例如，与使用8'h01或宏等文字相比，名称ADD、MOVE或row使代码更容易编写和维护。定义常量的一个较弱的选择是形参。这对于单独的值很好，但是枚举类型会自动为列表中的每个名称提供唯一的值。 最简单的枚举类型声明包含一个常量名称列表和一个或多个变量，如示例2.54所示。这将创建一个匿名枚举类型，但它不能用于除此声明中的变量之外的任何其他变量。 示例2.54一个简单的枚举类型，不推荐 建议创建一个命名枚举类型，这样您就可以声明多个相同类型的变量，特别是当这些变量被用作例程参数或模块端口时。首先创建枚举类型，然后创建该类型的变量，如示例2.55所示。您可以使用内置函数name()获得枚举变量的字符串表示形式。 示例2.55枚举类型，推荐的样式 在声明枚举类型名称时，使用后缀“_e”。 2.12.1 定义枚举值 实际值默认为int，从0开始，然后递增。您可以选择自己的枚举值。示例2.56中的代码使用默认值0表示INIT, 2表示DECODE, 3表示IDLE。 示例2.56指定枚举值 枚举常量，例如示例2.56中的INIT，遵循与变量相同的作用域规则。因此，如果在几个枚举类型中使用相同的名称(如不同状态机中的INIT)，则必须在不同的作用域(如模块、程序块、包、例程或类)中声明它们。 除非指定其他类型，否则枚举类型以int存储。给枚举常量赋值时要小心，因为int的默认值是0。在样例2.57中，position被初始化为0，这不是一个合法的序数变量。这 行为不是一个工具错误——它是语言如何被指定的。因此，总是指定一个值为0的枚举常量，如示例2.58所示，只是为了捕获testbench错误。 示例2.57错误地指定枚举值 示例2.58正确指定枚举值 2.12.2 枚举类型的例程 SystemVerilog提供了几个用于逐步遍历枚举类型的函数。 first()返回枚举的第一个成员。 last()返回枚举的最后一个成员。 next()返回枚举的下一个元素。 next (N)返回N th下一个元素。 prev()返回枚举的前一个元素。 prev(N)返回N th之前的元素。 当函数next和prev到达枚举的开头或结尾时，它们会绕行。 请注意，如果使用枚举循环变量，则没有干净的方法来编写遍历枚举类型的所有成员的for循环。你得到了第一个函数的起始元素和下一个元素。当循环变量超出定义范围时，for循环结束，但下一个函数总是返回枚举内的值。如果你用的是测试电流!= current.last()，循环在使用最后一个值之前结束。如果你使用current 你可以使用一个do…while循环来遍历所有的值，检查值何时换行，如样例2.59所示。 示例2.59逐步遍历所有枚举成员 2.12.3 与枚举类型之间的转换 枚举类型的默认类型是int (2-state)。您可以将枚举变量的值赋值给一个非枚举变量，比如一个简单的赋值int。但是，SystemVerilog不允许在不显式更改类型的情况下将整数值存储在enum中。相反，它要求您显式地强制转换值，以使您意识到您可能正在编写一个越界值。 示例2.60整数和枚举类型之间的赋值 如样例2.60所示，当作为函数调用时，$cast()试图将右边的值赋给左边的变量。如果赋值成功，$cast()返回1。如果由于越界值而赋值失败，则不进行赋值，函数返回0。如果使用$cast()作为任务，而操作失败，则SystemVerilog将打印一个错误。 您也可以使用示例中所示的类型'(val)强制转换值，但这并不执行任何类型检查，因此结果可能是越界的。例如, 在样例2.60中的静态强制转换之后，c2有了一个越界值。您应该避免使用枚举类型进行这种类型的强制转换。 2.13 常量 SystemVerilog中有几种类型的常量。Verilog创建常量的经典方法是使用文本宏。另一方面，宏具有全局作用域，可以用于位字段定义和类型定义。从消极的方面来说，宏是全局的，所以如果你只需要一个局部常量，它们可能会导致冲突。最后，宏需要'字符，这样编译器才能识别和扩展它。 Verilog参数是松散类型的，其作用域仅限于单个模块。Verilog-2001增加了类型化参数，但是它们有限的作用域使参数器不能被广泛使用。在SystemVerilog中，可以在包中声明参数，这样它们就可以跨多个模块使用。这种方法可以替换大多数作为常量使用的Verilog宏。 SystemVerilog还支持const修饰符，该修饰符允许您创建一个变量，该变量可以在声明中初始化，但不能由过程性代码编写。 示例2.61声明const变量 在样例2.61中，冒号的值在运行时初始化，当初始化 阻止进入。在下一章中，样例3.11展示了const例程参数。 2.14 字符串 如果您曾经尝试过使用Verilog reg变量来保存字符串，那么您的痛苦就结束了。SystemVerilog字符串类型包含可变长度的字符串。单个字符的类型是byte。长度为N的字符串的元素编号为0到N-1。注意，与C语言不同，字符串的末尾没有空字符，任何使用字符\" \\0 \"的尝试都会被忽略。字符串的内存是动态分配的，因此不必担心存储字符串的空间不够用。 样例2.62显示了各种字符串操作。函数getc(N)返回位置为N的字节，而toupper返回的是字符串的大写副本，tolower返回的是小写副本。花括号{}用于连接。任务putc(M, C)将字节C写入位置M的字符串中，该字符串必须在0之间 长度由len给出。函数的作用是:从起始位置到结束提取字符。 示例2.62字符串方法 注意动态字符串是多么有用。在C等其他语言中，您必须不断创建临时字符串来保存函数的结果。在样例2.62中，使用的是Verilog-2001中的$sformatf函数，而不是$sformat。这个新函数返回一个格式化的临时字符串，如上面所示，可以直接传递给另一个例程。这使您不必声明一个临时字符串，并在格式化语句和例程调用之间传递它。未记录的函数$psprintf与$sformatf具有相同的功能，但不在LRM中，尽管大多数供应商支持这个非标准的系统函数。 有两种方法来比较字符串，但是它们的行为不同。相等操作符s1==s2，如果字符串相同则返回1，反之返回0。字符串比较函数s1.compare(s2)，如果s1大于s2则返回1，如果大于s2则返回0 如果s1小于s2，则为−1。虽然这符合ANSI C strcmp()行为，但它可能不是您所期望的。 2.15 表达式的宽度 在Verilog中出现意外行为的一个主要来源是表达式的宽度。示例2.63使用四种不同的样式添加了1+1。加法A使用两个1位变量，因此精度为1+1=0。加法B使用8位精度是因为 在赋值的左侧有一个8位变量。在这种情况下，1+1=2。加法C使用一个虚拟常数来强制SystemVerilog使用2位精度。最后，除了D之外，第一个值通过转换操作符被转换为2位值，所以1+1=2。 表达式宽度取决于上下文 有一些技巧可以用来避免这个问题。首先，避免溢出丢失的情况，如a .使用临时的，如b8，具有所需的宽度。或者，您可以添加另一个值来强制最小精度，例如2'b0。最后，在SystemVerilog中，您可以将其中一个变量强制转换为所需的精度。 2.16 结论 SystemVerilog提供了许多新的数据类型和结构，这样您就可以创建高级的testbench，而不必担心位级表示。队列可以很好地创建记分牌，你需要不断地添加和删除数据。动态数组允许您在运行时选择数组大小，以获得最大的testbench灵活性。关联数组用于稀疏存储器和一些带有单个索引的记分牌。通过创建命名常量组，枚举类型使代码更易于阅读和编写。 不要仅仅使用这些结构来创建一个过程测试工作台。在第5章中探索SystemVerilog的OOP功能，学习如何在更高的抽象级别上设计代码，从而创建健壮和可重用的代码。 2.17 练习 给定以下代码示例: my_byte的取值范围是什么? my_int的十六进制值是什么? my_bit的十进制值是多少? my_short_int1的十进制值是多少? my_short_int2的十进制值是多少? 给定以下代码示例: 按给定顺序计算下列语句，并给出每次赋值的结果 my_mem [2] = my_logicmem [4]; my_logic = my_logicmem [4]; my_logicmem [3] = my_mem [3]; my_mem [3] = my_logic; my_logic = my_logicmem [1]; my_logic = my_mem [1]; my_logic = my_logicmem [my_logicmem [41]; 编写SystemVerilog代码: 声明一个2状态数组my_array，它包含4个12位的值 初始化my_array以便: * my_array[0] = 12'h012 * my_array[1] = 12'h345 * my_array[2] = 12'h678 my_array [3] = 12 'h9ab 遍历my_array并打印出每个12位元素的位[5:4] 使用for循环 用foreach环 声明一个5乘31的多维未打包数组my_array1。未打包数组的每个元素都保存一个4种状态的值。 下列哪个赋值语句是合法且不越界的? * my_array1[4][30] = 1'b1; * my_array1[29][4] = 1'b1; * my_array1[4] = 32'b1; 在合法赋值完成后绘制my_array1。 声明一个5乘31的多维打包数组my_array2。已打包数组的每个元素都保存一个2状态值。 下列哪个赋值语句是合法且不越界的? * my_array2[4][30] = 1'b1; * my_array2[29][4] = 1'b1; * my_array2[3] = 32'b1; 在赋值语句完成后绘制my_array2。 给定以下代码，确定将显示什么。 为以下问题编写代码。 为一个字宽为24位，地址空间为220字的处理器创建一个关联数组。假设重置时PC从地址0开始。程序空间从0400开始。ISR为最大地址。 请按照以下说明填充内存: 24 'ha50400;//主代码跳转到位置0400 24 'h123456;//指令1位于位置0400 24 'h789abc;//指令2位于位置0401 24 'h0f1e2d;// ISR = Return from interrupt 输出数组中的元素和元素数量。 为以下需求创建SystemVerilog代码 创建一个3字节队列，用2、−1和127初始化 输出以小数点为基数的队列的和 打印出队列中的最大值和最小值 对队列中的所有值进行排序并打印出结果队列 打印出队列中任何负值的索引 打印出队列中的正数 对队列中的所有值进行反向排序并打印出结果队列 定义一个用户定义的7位类型，并使用新类型将下列数据包的字段封装在一个结构中。最后，分配头部到7'h5A。 27 21 20 14 13 7 6 0 headercmddatacrc 为以下需求创建SystemVerilog代码 创建一个4位的用户定义类型nibble 创建一个真实的变量r，并将其初始化为4.33 创建一个简短的int变量i_pack 创建一个未打包的数组k，包含用户定义类型nibble的4个元素，并将其初始化为4'h0、4' hf、4' he和4' hd 打印出k 以位为基础，从右向左将k流到i_pack中，并将其打印出来 以一点的方式从右到左将k流到i_pack中并打印出来 类型转换实r为一个啃，赋值给k[0]，并打印出k ALU的操作码如表2.1所示。 表2.1 ALU操作码 操作码 编码 Add: A + B 2 'b00 Sub: A−B 2 'b01 位操作转化: 2 'b10 减少或:B 2 'b11 编写一个执行以下任务的测试平台。 创建操作码的枚举类型:opcode_e 创建一个opcode_e类型的变量opcode 每10ns循环遍历变量opcode的所有值 用一个2位输入操作码实例化ALU "},"articles/chapter-03.html":{"url":"articles/chapter-03.html","title":"第三章　　过程性语句和例程","keywords":"","body":"第三章 过程性语句和例程 当您验证您的设计时，您需要编写大量的代码，其中大部分是任务和函数。SystemVerilog引入了许多增量改进，使语言看起来更像C语言，特别是在参数传递方面，从而使这一点变得更容易。如果你有软件工程的背景，这些补充应该是非常熟悉的。 3.1 程序语句 SystemVerilog从C和c++中采用了许多操作符和语句。您可以在for循环中声明一个循环变量，从而限制循环变量的范围，并可以防止一些编码错误。新的自动自增++和自动自减−−操作符有前置和后置两种形式。复合赋值，+=，−=，ˆ=，以及更多使你的代码更紧凑。如果在begin或fork语句中有标签，则可以在匹配的end或join语句中放置相同的标签。这使得匹配块的开始和结束变得更容易。您还可以在其他SystemVerilog结束语句上添加标签，例如endmodule、end- task、endfunction以及您将在本书中学习的其他语句。样例3.1 demon-演示了一些新的构造。 样例3.1新的过程语句和运算符 两个新语句帮助处理循环。首先，如果您处于循环中，但希望跳过其余语句并执行下一次迭代，请使用continue。如果你想立即离开这个循环，使用break。 Sample 3.1中的复合赋值等价于sum = sum + array[j];示例3.2中的循环使用Verilog-2001中的文件I/O系统任务从文件读取命令。如果命令只是空行，则代码执行continue，跳过命令的任何进一步处理。如果命令“完成”，则代码执行断点以终止循环。 例3.2在读取文件时使用break和continue SystemVerilog展开case语句，这样您就不再需要给出每个可能的值，而是可以给出一个范围值，如示例3.3所示。这是inside操作符的一个版本，在6.4.5节中有更详细的介绍。 带有范围的Case-inside语句 3.2 任务、函数和Void函数 Verilog对任务和功能进行了非常明确的区分。最重要的区别是任务可以消耗时间，而函数不能。一个函数不能有一个延迟，#100，一个阻塞语句，比如@(posedge clock)或者wait (ready)，或者调用一个任务。此外，Verilog函数必须返回一个值，并且必须使用这个值，就像在赋值语句中一样。 SystemVerilog稍微放宽了这一规则，因为函数可以调用任务，但只能在fork…join_none语句衍生的线程中调用，这在7.1节中描述。 如果您有一个不消耗时间的SystemVerilog任务，则应该将其设置为void函数，这是一个不返回值的函数。现在可以从任何任务或函数调用它。为了获得最大的灵活性，任何调试例程都应该是空函数而不是任务，以便可以从任何任务或函数调用它。样例3.4打印来自状态机的值。 用于调试的样例3.4 Void函数 在SystemVerilog中，如果您想调用一个函数并忽略它的返回值，请将结果转换为void，如示例3.5所示。有些模拟器，比如VCS，允许您忽略返回值而不使用void语法。LRM说这应该是一个警告。 示例3.5忽略函数的返回值 3.3 任务与功能概述 SystemVerilog对任务和函数做了一些小小的改进，使它们看起来更像C或c++例程。通常，没有参数的例程定义或调用不需要空圆括号()。为了更清晰，本书包括了它们。 例程开始…结束删除 在SystemVerilog例程中，您可能注意到的第一个改进是begin…end块是可选的，而Verilog-1995在除单行例程外的所有例程中都要求使用它们。task / endtask和function / endfunction关键字足以定义例程边界，如示例3.6所示。 示例3.6没有begin…end的简单任务 3.4 常规参数 SystemVerilog对例程的许多改进使得声明参数和扩展向例程传递值和从例程传递值的方式变得更加容易。 3.4.1 c风格的常规参数 SystemVerilog和Verilog-2001允许您更清晰地声明任务和函数参数，减少重复。下面的Verilog任务要求您声明两个参数:一个是方向，一个是类型，如样例3.7所示。 示例3.7 Verilog-1995例程参数 使用SystemVerilog，您可以使用更简洁的c风格，如示例3.8所示。 请注意，您应该使用通用输入类型的逻辑。 样例3.8 c风格例程参数 3.4.2 论证方向 您可以使用声明例程参数的更多快捷方式。方向和类型默认为“input logic”，并且是粘性的，所以对于类似的参数，您不必重复这些。样例3.9显示了使用Verilog-1995风格和SystemVerilog数据类型编写的例程头。 示例3.9详细verilog风格的例程参数 您可以将其重写为示例3.10所示。 带有粘性类型的例程参数示例3.10 参数a和b是输入逻辑，1位宽。参数u和v是16位的输出位类型。既然您已经知道了这一点，那么就不要依赖于默认值，因为您的代码将充斥着微妙且难以发现的bug，正如3.4.6节中所解释的那样。总是为每个例程参数声明类型和方向。 3.4.3 先进的参数类型 Verilog有一种简单的方法来处理参数:在例程开始时将输入或inout复制到局部变量，而在例程退出时复制输出或inout。不能将内存传递到Verilog例程中，只能传递标量。 在SystemVerilog中，可以指定通过引用传递参数，而不是复制其值。相对于input、output和inout, ref参数类型有几个优点。首先，您现在可以将数组传递到例程中，这里的例程打印校验和。 示例3.11使用ref和const传递数组 示例3.11中的=复合赋值是编写语句的一种简写方式: SystemVerilog允许您在不使用ref方向的情况下传递数组参数，但是数组被复制到堆栈上，这对于除了最小的数组之外的所有数组都是一个昂贵的操作。 SystemVerilog LRM声明，ref参数只能在具有自动存储功能的例程中使用。如果您为程序和模块指定了automatic属性，那么里面的所有例程都是自动的。有关存储的更多细节，请参见3.6节。 样例3.11还展示了const修饰符。结果，数组a指向例程调用中的数组，但数组的内容不能被修改。如果尝试更改内容，编译器将打印一个错误。 为获得最佳性能，在将数组传递给例程时始终使用ref。如果不希望例程改变数组值，则使用const ref类型，这将导致编译器检查例程是否没有修改数组。 ref参数的第二个好处是，任务可以修改变量，并立即被调用函数看到。当您有几个线程同时执行，并且希望用一种简单的方式传递信息时，这是很有用的。关于使用fork-join的更多细节，请参见第7章。 在样例3.12中，只要断言启用，初始块中的thread2块就可以从内存中访问数据，即使bus_read任务直到总线事务完成才返回，这可能需要几个周期之后。 示例3.12在线程间使用ref data参数作为ref传递，因此，一旦任务中的数据发生变化，@data语句就会触发。如果已将数据声明为输出，则@data语句直到总线事务结束时才会触发。 3.4.4 参数的默认值 随着您的测试平台越来越复杂，您可能想要添加额外的控制到您的代码，但不破坏现有的代码。对于样例3.11中的函数，您可能想打印数组中间值的校验和。但是，您不希望返回并重写每个调用来添加额外的参数。在SystemVerilog中，如果在调用中省略了参数，可以指定一个默认值。样例3.13向print_csm函数添加了low和high参数，这样您就可以打印一系列值的校验和。 带有默认实参值的示例3.13函数 您可以通过以下方式调用这个函数，如示例3.14所示。注意，第一个调用与print_csm例程的两个版本兼容。 示例3.14使用默认实参值 使用缺省值−1(或任何超出范围的值)是查看调用是否指定了一个值的好方法。 在开始循环之前，Verilog for循环总是执行初始化(int i=low)和测试(i 3.4.5 按名称传递参数 您可能已经在SystemVerilog LRM中注意到，任务或函数的参数有时称为“端口”，就像模块的连接一样。如果您有一个带有许多参数(有些参数带有默认值)的任务或函数，并且您只想设置其中的一些参数，那么您可以通过使用类似于端口的语法指定例程参数的名称来指定一个子集，如示例3.15所示。 样例3.15按名称绑定参数 3.4.6 常见的编码错误 对于例程，最常见的编码错误是忘记参数类型与前一个参数相比是粘性的，并且第一个参数的默认类型是单位输入。从示例3.16中的简单任务头开始。 样例3.16原始任务标题 这两个参数是输入整数。在编写任务时，您意识到需要访问一个数组，因此添加了一个新的数组参数，并使用ref类型，这样它就不必被复制。例程头现在看起来像样例3.17。 样例3.17带有附加数组参数的任务头 a和b的参数类型是什么?它们采用前一个参数的方向，即ref。通常不需要对简单变量(如int)使用ref，但编译器甚至不会发出警告，因此不会意识到你使用了错误的方向。 如果例程的任何参数不是默认输入类型，请为所有参数指定方向，如样例3.18所示。 样例3.18带有附加数组参数的任务头 3.5 从例行程序返回 Verilog有一种结束例程的原始方法;在执行例程中的最后一条语句后，它返回到调用代码。此外，函数通过将该值赋给与函数同名的变量来返回该值。 3.5.1 的返回语句 SystemVerilog添加了return语句，使您更容易控制例程中的流。由于错误检查，样例3.19中的任务需要提前返回。否则，它将不得不将任务的其余部分放在一个else子句中，这将导致更多的缩进，并使阅读更加困难。 样例3.19在任务中返回 样例3.20中的return语句可以简化函数。 示例3.20在函数中返回 3.5.2 从函数返回一个数组 Verilog例程只能返回一个简单的值，比如位、整数或向量。如果想计算并返回一个数组，没有简单的方法。在System Verilog中，函数可以使用几种技术返回数组。 第一种方法是为数组定义类型，然后在函数声明中使用该类型。样例3.21使用样例2.40中的数组类型，并创建一个函数来初始化数组。 样例3.21从带有类型定义的函数返回数组 上述代码的一个问题是，函数init创建了一个数组，该数组被复制到数组f5中。如果数组很大，这可能是一个很大的性能问题。 另一种方法是通过引用传递例程。最简单的方法是将数组作为ref参数传递给函数，如示例3.22所示。 样例3.22将数组作为ref参数传递给函数 函数返回数组的最后一种方法是将数组包装在类中，并返回对象的句柄。第五章描述了类、对象和句柄。 3.6 本地数据存储 当Verilog在20世纪80年代创建时，它与描述硬件紧密联系在一起。因此，该语言中的所有对象都是静态分配的。特别是，例程参数和局部变量被存储在一个固定的位置，而不是像其他编程语言那样将它们推入堆栈。为什么尝试建模动态代码，如递归例程，当没有办法在硅构建这?然而，那些已经习惯了C等基于堆栈的语言行为的软件工程师，却被这些细微的错误所困扰，因此，他们在创建带有例程库的复杂testbench的能力上受到了限制。 3.6.1 自动存储 在Verilog-1995中，如果您试图从测试台上的多个位置调用任务，那么本地变量将共享公共的静态存储，因此不同的线程会使用彼此的值。在Verilog-2001中，您可以指定任务、函数和模块使用自动存储，这将导致模拟器使用本地变量的堆栈。 在SystemVerilog中，例程默认情况下仍然使用静态存储，包括模块和程序块。通过在程序语句中放入automatic关键字，您应该始终使程序块(及其例程)使用自动存储。在第4章中，您将了解保存testbench代码的程序块。第7.1.6节展示了在创建多个线程时自动存储是如何提供帮助的。 样例3.23展示了一个监视何时将数据写入内存的任务。 例例3.23指定程序块中的自动存储 您可以并发地多次调用这个任务，因为addr和expect_data参数分别存储在每个调用中。如果没有自动修饰符，如果第一次调用wait_f or_bus时第二次调用wait_f or_bus仍在等待，那么第二次调用将覆盖这两个参数。 3.6.2 变量初始化 当试图在声明中初始化局部变量时，也会发生类似的问题，因为它实际上是在开始模拟之前初始化的。一般的解决方案是避免在声明变量时将其初始化为常量以外的任何东西。使用单独的赋值语句可以更好地控制何时完成初始化。 样例3.24中的任务在五个周期后查看总线，然后创建一个局部变量并尝试将其初始化为地址总线的当前值。 样例3.24静态初始化错误 错误在于local_addr变量是静态分配的，所以它实际上是在模拟开始时被ini化的，而不是在进入begin…end块时。同样，解决方案是将程序声明为自动程序，如示例3.25所示。 样例3.25静态初始化修复:使用automatic 此外，您可以通过从不在声明中初始化变量来避免这一点，但这很难记住，特别是对于C程序员。样例3.26展示了将声明和初始化分开的推荐风格。 样例3.26静态初始化修正:将声明和初始化分开 3.7 时间值 SystemVerilog有几个新构造，允许您明确地指定系统中的时间值。 3.7.1 时间单位和精度 当你依赖' timescale compiler指令时，你必须按照正确的顺序编译文件，以确保所有的延迟使用正确的规模和精度。的一种方法 为了避免这种编译顺序问题，要求每个以“timescale compiler指令”开头的文件都应该以一个将其重置为特定公司默认值的指令结束，比如1ns/1ns。 timeunit和timeprecision声明通过精确指定每个模块的值来消除这种歧义。样例3.27显示了这些声明。注意，如果你使用这些而不是' timescale，你必须把它们放在每个有延迟的模块中。有关这些声明的更多信息，请参阅LRM。 3.7.2 时间的文字 SystemVerilog允许您明确地指定时间值和单位。你的代码可以使用0.1ns或20ps的延迟。记住要使用timeunit和timeprecision或者timescale。通过使用经典的Verilog $timeformat()、$time和$realtime系统任务，您可以让您的代码对时间更加敏感。$timeformat的四个参数是比例因子(纳秒为−9，皮秒为−12)、小数点右侧的数字数、时间值后要打印的字符串和最小字段宽度。 样例3.27显示了各种延迟，以及通过$timeformat()和%t说明符进行格式化时打印时间的结果。 示例3.27时间文字和$timeformat 3.7.3 时间和变量 您可以将时间值存储在变量中，并在计算和延迟中使用它们。这些值会根据当前的时间刻度和精度进行缩放和舍入。time类型的变量不能保留分数延迟，因为它们只是64位的整数，所以延迟将被舍入。如果这是一个问题，你应该使用实时变量。 样例3.28显示了当使用实时变量作为延迟时，如何四舍八入。 样本3.28时间变量和舍入 3.7.4 时间与实时美元 系统任务$time返回一个按当前mod的时间单位缩放的整数，但不包含任何小数单位，而$realtime返回一个具有完整时间值的实数，包括分数。为了简洁，本书在示例中使用了$time，但是您的testbench可能需要使用$realtime。 3.8 结论 新的SystemVerilog过程结构和任务/函数特性使该语言看起来更像C/ c++等其他编程语言，从而使您更容易创建testbench。SystemVerilog还有额外的HDL结构，比如定时控制、简单的线程控制和4状态逻辑。 3.9 练习 按照以下要求创建SystemVerilog代码: 创建一个512元素的整数数组 创建一个9位的address变量来索引数组 将数组中的最后一个位置初始化为5 调用一个任务my_task()，并传递数组和地址 创建my_task()，它接受两个输入:通过引用传递的包含512个元素的常量整数数组，以及一个9位地址。该任务调用一个函数print_ int()，并传递按地址索引的数组元素，并预减地址。 创建print_int()，输出模拟时间和输入值。该函数没有返回值。 对于以下SystemVerilog代码，如果任务my_task2（）是自动的，将显示什么？            对于练习2中的SystemVerilog代码，如果任务my_ task2()不是自动的，将显示什么? 创建SystemVerilog代码来指定时间应该以ps (picoseconds)格式打印，在小数点右侧显示2位数字，并使用尽可能少的字符 使用练习4中的格式化系统任务，下面的代码显示什么?            "},"articles/chapter_04_new.html":{"url":"articles/chapter_04_new.html","title":"第四章　　连接设计和Testbench","keywords":"","body":"第四章 连接Testbench和设计 验证一个设计需要几个步骤:产生激励、捕获响应、确定正确性和衡量进度。然而，首先你需要合适的testbench，并连接到设计，如图4.1所示。 图4.1 Testbench-DUT环境 testbench包裹着设计，发送激励并捕获设计的响应。试验平台围绕设计形成“真实世界”，模拟设计的整个运行环境。例如，处理器模型需要连接到各种总线和设备，这些总线和设备在testbench中被建模，即总线功能模型。对于网络设备，需要连接到基于标准协议建模的多个输入和输出数据流。对于视频芯片，需要连接到总线上对其发送指令，然后形成图像并写入存储器模型。总之，关键的概念是，testbench模拟所有不包含在被测设计中的东西。 由于Verilog的端口描述有时候长达数页，连接的时候容易出错，testbench需要一种更高级别的方法来与设计通信。需要一种健壮的方式来描述时序，以便始终在正确的时间驱动和采样同步信号，避免Verilog中常见的竞争状态。 4.1 分离Testbench和设计 在理想情况下，所有项目都有两个独立的组:一个组创建设计，一个组验证设计。在现实世界中，有限的预算可能要求你同时承担这两种角色。每个团队都有自己的一套专业技能，比如创建可合成的RTL代码，或者找出新的方法来发现设计中的错误。这两组人都阅读了原始的设计说明书，并做出了各自的解释。设计人员必须创建符合规范的代码，而验证工程师的工作是创建设计与描述不符的场景。 同样，您的testbench代码与设计代码在一个单独的块中。在经典的Verilog中，两种代码都放在单独的模块中。然而，使用一个模块来保存testbench通常会导致围绕驱动和采样的时序问题，因此SystemVerilog引入了程序块(program block),从逻辑上和时序上来分离testbench。更多细节请参见4.3节。 随着设计的复杂性增加，模块之间的联系也在增加。两个RTL模块可以共享几十个信号，这些信号必须以正确的顺序列出，以便它们能够正常通信。一个不匹配或错位的连接，将会导致设计将无法工作。可以通过使用按名称连接的方法来减少错误，但这将使输入负担增加一倍以上。如果这是一个微妙的错误，比如交换了只是偶尔切换的pin，那么可能在一段时间内不会注意到这个问题。更糟糕的是，当在两个块之间添加一个新信号时。不仅需要编辑当前模块以添加新端口，还需要编辑与其连接的上层模块。再一次地，在任何层次上只要有一个错误的连接，设计就会停止工作。或者更糟，系统只是间歇性地失效! 解决方案是使用接口，接口是代表一束连线的SystemVerilog构造。此外，您还可以指定时间、信号方向，甚至添加功能代码。接口像模块一样被实例化，但像信号一样连接到端口。 4.1.1 testbench与被测设备之间的通信 接下来的几节将展示连接到仲裁器的testbench，使用单独的信号和接口。图4.2是一个顶层的示意图，包括一个testbench，仲裁器，时钟发生器，以及连接它们的信号。这个DUT(测试中的设计)是一个很小 的设计，因此您可以将注意力集中在SystemVerilog概念上，而不会陷入设计中。在本章的最后，展示了一个ATM路由器。 图4.2testbench-没有使用接口的仲裁器 4.1.2 与端口的通信 下面的代码显示了将RTL模块连接到testbench所需的步骤。第一个是仲裁模型的端口描述，如例4.1所示。这使用了Verilog-2001风格的端口声明，其中类型和方向在文件头部。为了清晰起见，省略了一些代码。 正如第2.1.1节所讨论的，SystemVerilog扩展了经典的reg类型，这样您就可以像使用wire一样使用它来连接不同模块。为了表示到它的新功能，reg类型有了新的名称logic。唯一不能使用logic变量的地方是含有多个驱动的连线，在那里你必须使用线类型，比如wire。 例4.1使用端口的仲裁模型 例4.2中的testbench被保存在一个模块中，以将其与设计分离。 通常，它通过端口连接到设计。 例4.2使用端口的Testbench模块 顶层模块连接testbench和DUT，包括一个简单的时钟生成器。 例4.3 带有端口的顶层模块 在例4.3中，模块很简单，但是真正的设计需要数百个引脚，需要数页的信号和端口声明。所有这些连接都很容易出错。当信号在几个层次结构中移动时，必须反复声明并连接它。最糟糕的是，如果您只想添加一个新信号，则必须在多个文件中声明并连接它。SystemVerilog接口在这些情况下都有帮助。 4.2 接口结构 设计已经变得如此复杂，甚至块之间的通信可能需要分离成单独的实体。为了对此进行建模，SystemVerilog使用了接口结构，可以将其视为一个智能的连接束。它包含连接性、同步，以及(可选)两个或多个块之间通信的功能，以及(可选)错误检查。它们将设计块和/或testbench连接起来。 Sutherland(2006)讨论了设计级接口。这本书专注于连接设计块和testbench的接口。 4.2.1 使用接口简化连接 对仲裁器示例的第一个改进是将连接捆绑到一个接口中。图4.3是testbench和仲裁器使用接口进行通信的框图。注意接口是如何扩展到两个模块的，这两个模块分别代表testbench和DUT的驱动程序和接收器。时钟可以是接口的一部分，也可以是一个单独的端口。 图4.3一个接口跨越两个模块 最简单的接口是一个双向信号包，如例4.4所示。 使用logic数据类型，这样您就可以从过程语句驱动信号。 例4.4用于仲裁器的简单接口 例4.5是被测试的设备（DUT），仲裁器，它使用接口而不是端口。 例4.5使用简单接口的仲裁器 例4.6展示了testbench。通过使用实例名arbif.request创建分层引用来引用接口中的信号。接口信号应该总是使用非阻塞赋值来驱动。第4.4.3和4.4.4节对此进行了更详细的解释。 例4.6 Testbench使用一个简单的仲裁器接口 所有这些块都在顶部模块中实例化并连接，如例4.7所示。 例4.7顶层模块，带有一个简单的仲裁接口 使用接口的好处已经立刻体现出来了，即使在这个小设备上:连接变得更清晰，更不容易出错。如果您想在接口中放入一个新信号，您只需要将它添加到接口定义和实际使用它的模块中。您不必更改任何模块，比如不需要更改只传递接口的top模块。这种语言特性大大减少了布线错误的可能性。 这本书只展示了与一个时钟连接在顶层的接口。如果你的接口需要多个时钟，请将它们视为接口内的其他信号，并将接口连接到时钟生成器。如果你在高层次上工作，并将接口视为一个基于循环的构造，你的工作效率会更高。下一个级别是基于事务的，这超出了典型的RTL代码。 确保在模块和程序块之外声明接口。如果忘记了，就会有各种各样的麻烦。有些编译器可能不支持在模块中定义接口。即便允许，接口将是模块的本地的局部变量，因此，对设计的其余部分是不可见的。例4.8展示了在其他include语句之后紧接着包含接口定义的常见错误。 例4.8 错误示例 模块包括接口 4.2.2 连接接口和端口 如果您有一个带有端口的Verilog-2001遗留设计，不能通过更改端口来使用接口，那么您可以只将接口的信号连接到各个端口。例4.9将例4.1中的原始仲裁器连接到例4.4中的接口。 例4.9连接接口到使用端口的模块 4.2.3 使用Modports对接口中的信号进行分组 例4.5使用点对点连接方案，接口中没有信号方向。使用端口的原始模块具有编译器用来检查连接错误的信息。modport可以构造在一个接口让你分组信号和指定方向。例4.10中的MONITOR modport允许您将监控模块连接到接口。 例4.10接口与modports 例4.11显示了仲裁器模块和testbench, modport在他们的端口连接列表中。注意，你在接口名称arb_if后面加上modport名称，DUT或TEST。除了modport的名字，这些都是和前面的例子相同的。 例4.11使用modports接口的仲裁器模块 例4.12带有modports接口的Testbench 尽管代码没有太大的变化(除了接口变大了)，但这个接口更准确地表示了真实的设计，尤其是信号方向。 有两种方法可以在你的设计中使用这些modport名称。您可以在连接接口信号的模块中指定它们。在本例中，除了模块名之外，top模块与例4.7相比没有任何更改。这本书推荐这种风格，因为modport是一个实现细节，不应该使顶层模块变得混乱。 另一种方法是在实例化模块时指定modport，如例4.13所示。 例4.13顶层模块与modports 使用这种风格，你可以灵活地实例化一个模块不止一次，每个实例连接到不同的modport，也就是接口信号的不同子集。例如，一个字节范围的RAM模型可以连接到32位总线上的四个插槽之一。在这种情况下，你需要在实例化模块时指定modport，而不是在模块本身中。 注意，modports定义在接口中，并在模块端口列表中指定，但从不在信号名称中指定。arb_if.TEST.grant 是非法的! 4.2.4 在总线设计中使用Modports 并不是每个信号都需要在每个modport传输。考虑一个带有接口的CPU -内存总线。中央处理器是总线主设备，驱动信号的子集，如request、command和address。存储器是一个从设备，接收那些信号并准备好驱动ready信号。主从设备都会驱动data信号。总线仲裁器只查看request和grant信号，而忽略所有其他信号。因此，你的接口将有主、从和仲裁三个modport，外加一个可选的监视器modport。 4.2.5 新建接口监控器 您可以使用monitor modport创建总线监视器。例4.14展示了仲裁器的一个简单监视器。对于一个真实的总线，你可以解码命令并打印状态:完成，失败，等等。 例4.14使用modports接口的仲裁监视器 4.2.6 接口的权衡 接口不能包含模块实例，只能包含其他接口的实例。与使用信号连接的传统端口相比，使用modports接口有一些权衡。 使用接口的优点如下。 接口是设计重用的理想选择。当两个块使用两个以上的信号与指定的协议通信时，考虑使用一个接口。如果一组信号反复重复，就像在网络交换机中一样，你应该额外使用虚拟接口，如第十章所述。 接口接受您在每个模块或程序中反复声明的混乱信号，并将其放在一个中心位置，减少了错误连接信号的可能性。 要添加一个新信号，您只需在接口中声明一次，而不是在上层模块中，这再次减少了错误。 Modports允许模块很容易地从一个接口获取信号子集。您可以指定信号方向进行额外的检查。 使用接口的缺点如下: 对于点对点连接，带有modports的接口几乎和使用带有信号列表的端口一样冗长。接口的优点是所有声明仍然在一个中心位置，减少了出错的机会。 除了信号名之外，还必须使用接口名，这可能会使模块更冗长，但对于调试来说也更容易理解。 如果你用一个不会被重用的唯一协议连接两个设计块，接口可能比仅仅将端口连接在一起要做更多的工作。 连接两个不同的接口很困难。一个新的接口(bus_if)可能包含现有接口(arb_if)的所有信号，加上新的信号(地址、数据等)。你可能需要拆分出独立的信号，并适当地驱动它们。 4.2.7 更多信息和例子 SystemVerilog LRM为您指定了许多其他使用接口的方法。Sutherland(2006)提供了更多使用接口进行设计的例子。 4.2.8 接口中的logic与wire 本书建议将接口中的信号声明为logic，而VMM有一个规则要求使用wire。区别在于易用性和可重用性。 如果您的testbench在带有过程分配的接口中驱动异步信号，那么信号必须是logic类型。wire只能用连续赋值语句驱动。对于一个时钟块中总是同步的信号，可以声明为logic或wire。例4.15显示了如何直接驱动logic信号，而wire需要额外的代码。 例4.15在接口中驱 动logic和wire 接口信号使用logic的另一个原因是，如果你无意中使用了多个结构驱动程序，编译器将给出一个错误。 VMM采用了一种更长期的方法。以您所创建的测试代码为例，这些测试代码在当前项目上运行良好，并在以后的新设计中使用。 如果你的接口与它所有的logic信号连接，现在一个信号有多个驱动会怎样?工程师们将不得不把这个logic换成wire，如果信号没有通过一个时钟块，就改变过程赋值语句。这样就有两个版本的接口，现有的测试必须修改后才能重用。 重写好的代码违背了 VMM 原则。 4.3 刺激的时机 testbench和设计之间的时间安排必须精心安排。在周期水平上，您需要在与时钟相关的适当时间驱动和接收同步信号。开车太晚或测试太早，你的testbench就会停止循环。即使在单个时隙内(例如，在100ns时间发生的所有事情)，混合设计和testbench事件也可能导致竞争条件，例如当信号同时被读写时。你是读旧的值，还是刚写的值?在Verilog中，当测试模块驱动DUT时，非阻塞赋值会有帮助，但测试不能总是确保它采样了由设计驱动的最后一个值。SystemVerilog有几个结构可以帮助您控制通信的时间。 4.3.1 用一个时钟块控制同步信号的定时 一个接口应该包含一个时钟块来指定同步信号相对于时钟的时间。时钟块主要由testbench使用，但也允许您创建抽象的同步模型。时钟块中的信号是同步驱动或采样的，确保您的testbench在正确的时间与信号交互。合成工具不支持时钟块，所以您的RTL代码不能利用它们。计时块的主要好处是，您可以将所有详细的计时信息放在这里，而不会使您的testbench混乱。 一个接口可以包含多个时钟块，每个时钟域一个，因为每个时钟块中都有一个时钟表达式。典型的时钟表达式是@(posedge clk)为一个单边缘时钟和@(clk)为一个DDR(双数据速率)时钟。 您可以使用default语句在时钟块中指定一个时钟倾斜，但默认行为是在design exe- cutes之前对输入信号进行采样，并在当前时隙期间将输出驱动回设计中。下一节提供了关于设计和testbench之间的时间安排的更多细节。 一旦你定义了一个时钟块，你的testbench就可以用@arbif等待时钟表达式。而不是必须拼出准确的时钟和边缘。现在，如果您更改时钟块中的时钟或边缘，则不必更改您的testbench。 例4.16与例4.10相似，除了测试modport现在将请求和授予视为同步信号。时钟块cb声明信号在时钟的正边缘是活跃的。信号的方向是相对于他们使用的modport的。因此，在测试modport中，request是一个同步输出，grant是一个同步输入。在测试modport中，信号rst是异步的。 例4.16接口与一个时钟块 4.3.2 Verilog中的定时问题 您的testbench需要与设计分离，不仅是逻辑上，而且是暂时的。考虑一下硬件测试器如何与同步信号的芯片进行交互。在实际的硬件设计中，DUT的存储元素将来自测试器的输入锁存在主动时钟边缘。这些值通过存储元素的输出传播，然后逻辑云到下一个存储元素的输入。从第一个存储器的输入到下一个存储器的时间必须小于一个时钟周期。 因此，硬件测试人员需要在时钟边缘驱动芯片的输入，并在下一个边缘之前读取输出。 testbench必须模拟这个测试人员的行为。它应该在活动时钟边缘上或之后驱动，并且应该在协议计时规范允许的尽可能晚的时间采样，就在活动时钟边缘之前。 如果DUT和testbench仅仅由Verilog模块组成，那么这个结果几乎不可能实现。如果testbench在时钟边缘驱动DUT，可能会出现竞争条件。如果时钟在testbench刺激之前传播到一些DUT输入，但稍后传播到其他输入，那会怎样?从外部看，时钟边缘都到达相同的仿真时间，但是在设计中，一些输入得到的值是上一个周期驱动的，而其他输入得到的值是当前周期的。 解决这个问题的一种方法是给系统添加小的延迟，比如#0。这将迫使Verilog代码的线程在所有其他代码之后停止并重新调度。然而，大型设计总是有几个部分都需要最后执行。谁的#0胜出?它可能在不同的运行中变化，并且在不同的模拟器中是不可预测的。使用#0延迟的多个线程会导致不确定性行为。避免使用#0，因为它会使你的代码不稳定和不可移植。 下一个解决方案是使用更大的延迟，#1。RTL代码没有计时，除了时钟边缘，所以在时钟之后的一个时间单位，逻辑已经确定。然而，如果一个模块使用1ns的时间精度，而另一个模块使用10ps的分辨率，那会怎样?1是表示1ns, 10ps，还是别的什么?您希望在具有活动时钟边缘的时钟周期之后尽快驱动，而不是在这段时间内，并且在其他任何事情发生之前。更糟糕的是，你的DUT可能包含没有延迟的RTL代码和有延迟的gate代码。正如您应该避免使用#0一样，要避免使用#1延迟来修复时间问题。参见Cummings(2000)和他的其他论文获得额外的指导方针。 4.3.3 试验台-设计竞赛条件 例4.17显示了testbench和设计之间潜在的竞争条件。竞争条件发生在测试驱动启动信号，然后驱动其他端口。内存正在等待启动信号，并可以立即唤醒，而写入信号仍然有它的旧值，而addr和data有新值。根据LRM，这种行为是完全合法的。按照Cummings(2000)的建议，您可以使用非阻塞分配来稍微延迟所有这些信号，但是请记住，testbench和design都在使用这些分配。仍然有可能在testbench和设计之间获得竞争条件。 对设计输出进行抽样也有类似的问题。您希望在活动时钟边缘之前的最后一刻获取这些值。也许你知道下一个时钟边缘是100ns。你不能在时钟边缘的100ns采样，因为一些设计值可能已经改变了。你应该在时钟边缘之前在Tsetup取样。 例4.17试验台与设计的竞争条件 4.3.4 程序块和定时区域 问题的根源是设计和testbench事件在同一时间段的混合，即使在纯RTL中也可能发生同样的问题。正确使用非阻塞赋值等良好的cod指导方针可以减少这些争用条件，但编码不当的赋值有偷偷摸摸进入的习惯。如果有一种方法可以暂时分离这些事件，就像分离代码一样，会怎么样呢?在100ns下，您的testbench可以在时钟有机会更改和任何设计活动发生之前对设计输出进行采样。根据定义，这些值将是前一个时间段中最后一个可能的值。然后，在所有设计事件完成后，您的testbench将开始。 SystemVerilog如何知道将testbench事件与设计事件分开调度?在SystemVerilog中，testbench代码位于程序块中，它类似于模块，因为它可以包含代码和变量，并可以在其他模块中实例化。但是，一个程序不能有任何层次结构，比如模块、接口或其他程序的实例。 SystemVerilog中引入了一个新的时隙区域，如图所示。 4.4。在Verilog中，大多数事件都在活动区域中执行。还有几十个其他区域用于非阻塞赋值、PLI执行等，但它们可以是 图4.4 SystemVerilog时间步长的主要区域 从之前的时间段开始 活动(设计) 观察(断言) 回送 如果更多的事件 反应(testbench) 推迟(样本) 到下一时段 就本书而言，我们忽略了这一点。有关SystemVerilog事件区域的详细信息，请参见表4.1、LRM和Cummings(2006)。 在时间段内首先执行的是活动区域，设计事件在该区域运行。这些代码包括传统的RTL和门代码，以及时钟生成器。第二个区域是观察区域，在此对SystemVerilog断言进行评估。接下来是程序中testbench代码执行的反应区域。注意，时间并不严格地向前流动——在当前周期中，观察到的和反应性区域中的事件可以触发活动区域中的进一步设计事件。最后是延迟区，在设计活动完成后的只读期，在时隙结束时采样信号。 表4.1主要SystemVerilog调度区域 的名字 活动 活跃的 模拟设计代码在模块观察 SystemVerilog断言的响应式评估 推迟了程序中testbench代码的执行 testbench输入的采样设计信号 例4.18显示了用于仲裁的部分testbench代码。注意状态@arbif。cb等待时钟块的活动边缘，@(posedge clk)，如例4.16所示。这个例子表明您的testbench代码是 在稍高的抽象级别上编写，使用逐周期计时，而不是担心单个时钟边缘。 第4.4节解释了更多关于驱动和接口信号采样的内容。 例4.18 Testbench使用接口与时钟块 您的测试应该包含在一个单独的程序中。您应该使用OOP从对象而不是模块构建一个动态的、分层的testbench。如果您使用来自其他人的代码或组合多个测试，则模拟可能有多个程序块。 正如第3.6.1节所讨论的，你应该总是将你的程序块声明为自动的，这样它的行为就更像你可能使用过的基于堆栈的语言的例程，比如C语言。 注意，并不是所有的供应商都平等地对待程序块。参见Rich(2009)的另一种观点。 4.3.5 指定设计和testbench之间的延迟 时钟块的默认计时是对偏置为#1的输入进行采样，并驱动延迟为#0的输出。1步延迟指定信号在任何设计活动之前，在前一个时隙的延迟区域内采样。因此，您可以在时钟更改之前获得输出值。通过时钟块，testbench的输出是同步的，因此它们直接流向设计。在反应区运行的程序块产生刺激 这将应用于DUT，然后在同一时间段的活动区域中对DUT进行计算。DUT评估它的逻辑并驱动它的输出，这些输出是通过时钟块进入testbench的输入。然后在延迟的区域采样，循环重复。如果你有设计背景，你可以通过想象时钟块在设计和测试之间插入一个同步器来记住这一点，如图4.5所示。通过正确使用程序和时钟块，testbench和DUT之间的竞争条件几乎可以消除。 图4.5时钟块同步DUT和试验台 4.4 接口驱动和采样 您的testbench需要驱动和采样来自设计的信号，主要通过与时钟块的接口。下一节将使用例4.16中的仲裁器接口和例4.9中的顶级模块。 异步信号如rst通过接口没有延迟。时钟块中的信号得到同步，如下节所示。 4.4.1 接口同步 您可以使用Verilog @和wait构造来同步testbench中的信号。例4.19展示了各种构造。 例4.19信号同步 4.4.2 接口信号样本 当你从一个时钟块读取一个信号时，你得到的值刚好在最后一个时钟边缘之前采样，即。来自推迟的地区。例4.20显示了一个从DUT读取同步授予信号的程序块。在100ns周期的中间，arb模块驱动授予1和2，然后在时钟边缘准确地授予3。这段代码仅用于说明，并不是真实的、可合成的RTL。 例4.20同步接口例和驱动模块 图4.6波形图表明，在程序中，arbif.cb。grant从时钟边缘之前获取值。当接口输入在时钟边缘发生变化(例如250ns)时，该值直到下一个周期(从350ns开始)才会传播到testbench。 clk DUT arb。格兰特X 1 2 3. 测试arbif.cb.grant X 1 2 3 50纳秒 150纳秒 250纳秒 350纳秒 图4.6同步接口采样 4.4.3 接口信号驱动 例4.21有一个简化版的仲裁器测试程序，它使用例4.16中定义的仲裁器接口。 例4.21 Testbench使用带有时钟块的接口 当使用带有时钟块的modports时，一个同步的接口信号，如request必须以接口名arbif和时钟块名cb作为前缀。在样本4。21中，arbif。cb。请求合法，但无效。 不是要求。这是接口和时钟块最常见的编码错误。 4.4.4 驱动接口信号通过一个时钟块 您应该始终使用非阻塞分配使用同步驱动器在一个时钟块中驱动接口信号。这是因为设计信号不会在你分配完任务后立即改变——记住你的testbench会执行 在无功区，而设计规范在有源区。如果您的testbench驱动的是arbif.cb。请求100ns，与arbif同时。cb(根据时钟块是@(posedge clk))，要求在100ns时改变设计。然而，如果您的测试bench试图驱动arbif.cb。请求时间101ns，在时钟边缘之间，更改直到下一个时钟边缘才传播。这样，您的驱动器总是同步的。在例4.20中，arbif。grant由模块驱动，可以使用阻塞赋值。 如果testbench在时钟的活动边缘驱动同步接口信号，如例4.22所示，该值立即传播到设计。这是因为一个时钟块的默认输出延迟是#0。如果testbench在活动边缘之后驱动输出，则该值直到时钟的下一个活动边缘才会在设计中看到。 例4.22接口信号驱动器 例4.23展示了在时钟周期的不同点上驱动同步接口信号会发生什么情况。它使用了例4.16中的接口以及例4.9中的顶层模块和时钟生成器。 例4.23驱动一个同步接口 注意，在图4.7中，第一个周期中间驱动的值3在第二个周期开始时被DUT看到。值2在第二个循环的中间被驱动。当testbench在第二个周期结束时驱动1时，被测试人员不会看到它。 clk 测试arb.cb。请求DUT arbif.request 图4.7驱动同步接口 异步驱动时钟块信号会导致丢失值。相反，通过在驱动器上使用周期延迟前缀在时钟边缘驱动，如例4.24所示。 例4.24接口信号驱动器 如果你想在驱动信号之前等待两个时钟周期，你可以使用\" repeat (2) @arbif.cb; \"或者使用周期延迟##2。后一个延迟只作为一个时钟块中的信号驱动器的前缀，因为它需要知道使用哪个时钟来进行延迟。 如果时钟在这个时隙中断言，根据时钟块，在一个分配中的##0周期延迟将立即驱动该值。如果时钟没有被断言，信号被驱动在时钟的下一个活跃边缘。##1的周期延迟总是等待时钟的下一个活动边缘，即使时钟在当前时隙中断言。 裸周期延迟声明##3;如果你的程序或模块有一个默认的时钟块，它就可以工作。这本书只建议把一个时钟块放在一个接口，而不是创建一个默认的时钟块。您应该始终明确所引用的时钟。 4.4.5 接口的双向信号 在Verilog-1995中，如果希望从过程代码驱动双向信号(如端口)，则需要连续赋值来将reg连接到电线上。在SystemVerilog中，当为您添加连续赋值时，接口中的同步双向信号更容易使用，如例4.25所示。当您从一个程序写入网络时，SystemVerilog实际上写入一个驱动网络的临时变量。你的程序直接从线路上读取数据，看到从所有驱动程序解析出来的值。模块中的设计代码仍然使用经典的寄存器加连续赋值语句。 例4.25程序和接口中的双向信号 SystemVerilog LRM不清楚如何使用接口驱动异步双向信号。两种可能的解决方案是使用跨模块引用和连续赋值，或者使用第10章中所示的虚拟接口。 4.4.6 指定时钟块中的延迟 一个时钟块确保你的信号被驱动和采样在指定的时钟边缘。您可以使用默认语句或指定单个信号的延迟来调整这些时间。这在模拟具有真实延迟的网络列表时很有用。例4.26显示了一个带有default语句的时钟块，该语句对所有信号都具有倾斜度。在这个例子中，输入在时钟波塞dge之前采样15ns，输出在时钟波塞dge之后驱动10ns。 例4.26带有default语句的时钟块 例4.27显示了等效的时钟块，但是在单个信号上指定了延迟。 单个信号延迟的样本4.27时钟块 4.5 程序块的考虑 4.5.1 仿真结束 在Verilog中，模拟在有预定事件时继续，或者直到执行$finish。SystemVerilog增加了一种结束模拟的额外方法。一个程序块被当作包含一个测试来处理。如果只有一个程序，当你完成程序中每个初始块的最后一条语句时，模拟就结束了，因为这被认为是测试的结束。即使程序或模块中仍有线程在运行，模拟也会结束。因此，当测试完成时，你不必关闭所有的监视器和驱动程序。 如果有几个程序块，模拟在最后一个程序完成时结束。这样，当最后一个测试完成时，模拟就结束了。您可以通过执行$exit提前终止任何程序块。当然，您仍然可以显式调用 $finish结束模拟，但如果有多个程序，这可能会导致问题。 然而，模拟还没有结束。模块或程序可以有一个final块，其中包含要在模拟器终止之前运行的代码，如例4.28所示。这是执行清理工作的好地方，比如关闭文件，打印错误和警告的数量报告。您不能安排任何事件，也不能在最后一个块中有任何可能导致时间流逝的延迟。您不必担心释放任何已分配的内存，因为这将自动完成。 样本4.28最后一个块 4.5.2 为什么在程序中总是不允许块? 在SystemVerilog中，您可以在程序中放置初始块，但不总是放置块。如果您习惯了Verilog模块，这看起来可能有点奇怪，但与Verilog的许多并发执行的小块硬件相比，SystemVerilog程序更接近C语言的程序，具有一个(或多个)入口点，这有几个原因。在设计中，从模拟开始，一个always块可能会触发时钟的每个正边缘。相比之下，testbench有初始化、刺激和响应设计，然后结束仿真的步骤。连续运行的always块将无法工作。 当程序中最后一个初始块完成时，模拟将隐式结束，就像执行了$finish一样。如果您有一个always块，它将永远运行，因此您必须显式地调用$exit来通知程序完成。但不要绝望。如果你真的需要一个always块，你可以使用initial forever来完成同样的事情。 4.5.3 时钟发生器 现在您已经看到了程序块，您可能想知道时钟生成器是否应该在一个模块中。与testbench相比，时钟与设计的联系更为紧密，因此时钟生成器应该留在一个模块中。生成器应该在与DUT相同的级别上实例化，这样它就可以同时驱动DUT和testbench，当您细化设计、创建时钟树时，当时钟进入系统并通过块传播时，您必须小心地控制偏差。testbench就没有那么挑剔了。它只是想让时钟边缘知道何时驱动和采样信号。功能验证关心的是在正确的周期提供正确的值，而不是分数纳秒延迟和相对 时钟倾斜。 程序块不是放置时钟生成器的地方。例4.29试图将生成器放入程序块中，但只会导致竞争条件。clk和数据信号都从反应区传播到活动区的设计，并可能导致竞争条件取决于哪个先到达。 程序块中的坏时钟生成器 通过始终将时钟生成器放在模块中来避免竞争条件。如果你想要随机化生成器的属性，创建一个带有随机变量的类，如第6章所示，包括倾斜、频率和其他特征。您可以在generator模块或testbench中使用该类。 例4.30展示了模块中一个好的时钟生成器。它故意避免时刻0的优势，以防止竞争条件。在活动区域内，所有的时钟边缘都以阻塞分配来触发事件。如果你必须在时间0产生一个时钟边缘，使用一个非阻塞分配来设置初始值，这样所有的时钟敏感逻辑，如always块将在时钟改变值之前开始。 样品4.30良好的时钟发生器模块 最后，不要试图用功能验证来验证低级时间。本书中描述的testbench检查DUT的行为，而不是时间，使用静态时间分析工具更好。您的testbench应该足够灵活，以兼容使用反向注释时间运行的门级模拟。 4.6 把它们连在一起 现在，您有了模块中描述的设计、程序块中的testbench以及将它们连接在一起的接口。例4.31有一个顶级模块，它实例化并连接所有的片段。 例4.31带有隐式端口连接的Top模块 这和样本4。7几乎一样。它使用了一种快捷符号。*(隐式端口连接)，自动连接模块实例端口到当前级别的信号，如果它们具有相同的名称和数据类型。 4.6.1 端口列表中的接口必须已连接 SystemVerilog编译器不允许编译使用端口列表中的接口的单个模块或程序。为什么不呢?毕竟，带有由单个信号组成端口的模块或程序可以在不实例化的情况下编译，如例4.32所示。 例4.32模块只有端口连接 编译器创建连接并将其连接到悬空信号。但是，在端口列表中具有接口的模块或程序必须连接到该接口的实例。 带有接口的模块例4.33 对于例4.33，编译器甚至不能构建一个简单的接口。如果你有modports或程序块使用一个接口的时钟块，编译器有一个更困难的时间。即使您只是想消除语法错误，您也必须完成连接。这可以按照例4.34所示完成。 样品4.34顶部模块连接DUT和接口 4.7 顶级的范围 有时你需要在你的模拟中创建一些程序或模块之外的东西，以便所有的块都能看到它们。在Verilog中，只有宏可以跨模块边界扩展，因此可以用于创建全局常量。SystemVerilog引入了编译单元，它是一组被编译在一起的源文件。任何模块、宏模块、接口、程序、包或原语边界之外的作用域称为编译单元作用域，也称为$unit。在这个范围中定义的任何东西，比如参数，都类似于全局变量，因为它可以被所有低级块看到。然而，它并不是真正的全局参数，因为在编译其他文件时不能看到该参数。 这导致了一些困惑。一些模拟器将所有SystemVerilog代码编译在一起，因此$unit是全局的。其他模拟器和合成工具一次编译单个模块或一组模块，因此$unit可能只是一个或几个文件的内容。因此，$unit是不可移植的。包允许您在程序或模块之外编写代码，同时消除了同时编译所有模块的需求。 本书将block之外的作用域称为“顶级作用域”。“你可以在这个空间里定义变量、参数、数据类型甚至例程。例4.35声明了一个顶级参数TIMEOUT，它可以在层次结构中的任何地方使用。这个例子还有一个保存错误消息的const字符串。两种方式都可以声明顶级常量。 例4.35仲裁器设计的顶级范围 实例名$root允许您明确地引用系统中的名称，从顶级范围开始。在这方面，$root类似于Unix文件系统中的“/”。对于像VCS这样一次性编译所有文件的工具，$root和$unit是等价的。名称$root还解决了一个旧的Verilog问题。 当您的代码引用另一个模块中的名称时，例如i1。var，编译器首先查找局部作用域，然后查找下一个更高的作用域，以此类推，直到它到达顶部。你可能想用i1。var，但是中间作用域中名为i1的实例可能会使搜索分心，给您提供了错误的变量。通过指定绝对路径，您可以使用$root来确定明确的跨模块引用。 例4.36显示了一个在模块top中实例化的程序，该模块在顶级范围中隐式实例化。该程序可以使用模块中clk信号的相对或绝对引用。您可以使用宏来保存分层路径，这样当路径发生更改时，您只需更改一段代码。LRM不允许在顶级范围中显式地实例化模块。 例4.36使用$root跨模块引用 4.8 程序模块的交互 程序块可以读取和写入模块中的所有信号，也可以调用模块中的例程，但是模块对程序没有可见性。这是因为您的testbench需要查看和控制设计，但是设计不应该依赖于testbench中的任何东西。 程序可以调用模块中的例程来执行各种操作。例程可以在内部信号上设置值，也称为“后门负载”。接下来，因为当前的SystemVerilog stan- dard没有定义如何从程序块强制发送信号，您需要在设计中编写一个任务来执行强制，然后从程序调用它。 最后，对于您的testbench来说，使用函数从DUT获取信息是一个很好的实践。读取信号值在大多数情况下都可以工作，但是如果设计代码发生变化，您的testbench可能会错误地解释这些值。模块中的函数可以封装两者之间的通信，使您的testbench更容易与设计保持同步。第10章展示了如何在接口中嵌入函数和SystemVerilog断言。 4.9 SystemVerilog断言 您可以在设计中创建有关信号的时态断言，以检查它们的行为和与SystemVerilog断言(SVA)的时态关系。模拟程序跟踪已触发的断言，因此您可以收集有关它们的功能覆盖数据。 4.9.1 直接断言 当语句被exe切割时，立即断言检查表达式是否为真。您的testbench过程代码可以检查设计信号和testbench变量的值，并在出现问题时采取行动。例如，如果您已经断言总线请求，那么您希望在两个周期后断言grant。您可以使用例4.37中所示的if语句。 例4.37用if语句检查信号 断言比if语句更简洁。但是，请注意，与上面的if语句相比，逻辑是相反的。你想要括号内的表达式为真;否则，打印一个错误，如例4.38所示。 例4.38简单的即时断言 如果正确地断言了授予信号，则继续测试。如果信号没有期望的值，模拟器将生成一个类似于例4.39的消息。 例4.39来自失败的立即断言的错误 这是在文件test的第7行。sv，断言top.t1。a1在55ns开始检查信号arbif.cb。格兰特，但立即失败了。标签a1应该是唯一的，以便您可以快速定位失败的断言。 您可能想使用完整的SystemVerilog断言语法来检查一段时间内的复杂序列，但是要小心，因为它们很难调试。断言是声明性代码，而exe-与周围的过程性代码非常不同。只需几行断言，就可以验证时间关系;枚, alent过程代码将更加复杂和冗长，但当下一个人必须阅读您的代码时，他们更容易理解。 如果您是一名VHDL程序员，此时您可能会忍不住开始在代码中直接使用断言。抵制诱惑!您的代码将正确工作数周或数月，直到有人决定改进模拟性能 曼斯通过禁用断言。模拟器将不再执行断言中的表达式。如果表达式有副作用，如递增值或调用函数，则该表达式将不再发生。 4.9.2 自定义断言操作 immediate断言有可选的then-和else-子句。如果您想增强默认消息，您可以添加自己的消息，如例4.40所示。 例4.40在即时断言中创建自定义错误消息 如果grant没有预期的值，您将看到类似于例4.41的错误消息。 例4.41来自失败的立即断言的错误 SystemVerilog有四个函数可以打印消息:$info、$warning、$error和$fatal。这些操作只允许在断言中进行，而不允许在过程代码中进行，不过SystemVerilog的未来版本可能允许这样做。 可以使用then子句记录断言成功完成时的情况，如例4.42所示。 例4.42创建自定义错误消息 4.9.3 并发断言 另一种断言类型是并发断言，您可以将其视为一个持续运行的小模型，为整个模拟检查信号值。它们的实例化与其他设计块相似，在整个模拟过程中都是活跃的。您需要在断言中指定采样时钟。例4.43有一个小的断言来检查仲裁请求信号除了复位期间没有X或Z值。该代码被放置在过程块(如initial和always)之外。样本4.43仅供说明。查看下面列出的其中一本书以获取更多信息。 例4.43检查X/Z的并发断言 4.9.4 探索断言 断言还有许多其他用途。例如，您可以将断言放在接口中。现在，您的接口不仅传输信号值，而且检查协议。 本节对SystemVerilog断言进行了简要介绍。更多信息，请参见Vijayaraghhavan和Ramanathan(2005)以及Haque等人(2007)。 4.10 四端口ATM路由器 仲裁器的例子是对接口的一个很好的介绍，但是真正的设计有不止一个输入和输出。本节讨论如图4.8所示的四端口ATM(异步传输模式)路由器。 图4.8没有接口的Testbench - ATM路由器图 4.10.1 带端口的ATM路由器 下面的代码片段展示了在将RTL块连接到testbench上时，您必须忍受的复杂的连接。第一个是ATM路由器模型的头。这使用了Verilog-1995风格的端口声明，其中类型和方向与头文件分开。 例4.44中路由器的实际代码被近一页的端口声明所挤占。 带端口的ATM路由器模型报头 那么，在例4.44末尾的“…”中包含了什么样的可合成代码呢?有关在模块和其他SystemVerilog设计构造中使用接口的更多信息和例，请参见Sutherland(2006)。 4.10.2 带端口的ATM顶层模块 例4.45包含顶级模块。 例4.45没有接口的顶级模块 例4.46显示了testbench模块的顶部。再次注意，端口和线占据了模块的大部分。 例4.46 Verilog-1995 testbench使用端口 你只看到了三页的代码，所有的都是连接——没有testbench，没有设计!接口提供了一种更好的方式来组织所有这些信息，并消除容易出错的重复部分。 4.10.3 使用接口简化连接 图4.9显示了连接到testbench的ATM路由器，将信号分组到接口中。 TestbenchRx Tx4 x4 ATM路由器 图4.9带有接口的testbench路由器图 4.10.4 ATM接口 例4.47和4.48显示了与modports和时钟块的Rx和Tx接口。 例4.47 Rx接口与modports和时钟块 例4.48 Tx接口与modports和时钟块 4.10.5 使用接口的ATM路由器模型 例4.49包含ATM路由器模型和testbench，它们需要在端口连接列表中指定modport。注意，你把modport名称放在接口名称Rx_if之后。 带modports接口的ATM路由器模型例4.49 4.10.6 带接口的ATM顶级模块 例4.50中显示的顶层模块已经大幅收缩，出错的机会也减少了。 例4.50带有接口的顶级模块 4.10.7 带接口的ATMtestbench 例4.51展示了testbench捕获从路由器的TX端口传入的单元的部分。注意，接口名称是硬编码的，因此您必须为44 ATM路由器复制相同的代码四次。例如，只显示任务receive_cell0，最终代码还将包含receive_ cell1、receive_cell2和receive_cell30。第10章展示了如何使用虚拟接口来简化代码。 例4.51 Testbench使用一个带有时钟块的接口 4.11 Ref端口方向 SystemVerilog引入了一个用于连接模块的新端口方向:ref。您应该熟悉输入、输出和inout方向。最后一个用于双向连接建模。如果驱动信号有多个inout端口，SystemVerilog将通过组合所有驱动的值来计算信号的值，考虑到驱动的强度和Z值。 裁判是另一种野兽。它本质上是一种使两个名称都引用同一个变量的方法。只有一个存储位置，但有多个别名。Ref端口只能连接变量，不能连接信号。关于例程参数的ref方向的信息，请参阅3.4.3节。 在例4.52中，incr模块有两个ref端口，c和d。这两个变量与顶部模块中的c和d变量共享存储。当top改变c的值时，incr会立即看到它。然后incr增加c，结果返回到顶层模块中。如果端口c被声明为inout，您将不得不构建三态驱动程序，比如连续赋值语句，并确保您正确地驱动了enable信号和Z值。不要认为ref端口是inout端口的方便替代，因为合成只支持inout端口。 例4.52 Ref端口 4.12 结论 在本章中，您已经学习了如何使用SystemVerilog的接口来组织设计块和testbench之间的通信。有了这种设计结构，您可以用一个接口替换数十个信号连接，使您的代码更容易维护和改进，并减少布线错误的数量。 SystemVerilog还引入了程序块来容纳您的testbench，并减少被测试设备和testbench之间的竞争条件。有了接口中的一个时钟块，您的testbench将驱动和样本设计信号正确地相对于时钟。 4.13 练习 设计了ARM高级高性能总线(AHB)的接口和testbench。提供给您一个总线主机作为可以启动AHB事务的验证IP。您正在测试一个从属设计。testbench实例化接口、从服务器和主服务器。如果事务类型在HCLK的负边缘不是IDLE或NONSEQ，你的接口将显示一个错误。AHB信号如表4.2所示。 表4.2 AHB信号描述 信号宽度方向描述HCLK1输出时钟HADDR21输出地址HWRITE1输出写标志:1=写，0=读HTRANS2输出交易类型:2b00 =闲置,2b10 = NONSEQHWDATA8输出写入数据HRDATA8输入读取数据 对于下面的接口，添加以下代码。 对时钟负边缘敏感的一个时钟块，所有的I/O都与时钟同步。 一个用于testbench的modport称为master，一个用于DUT的modport称为slave 使用主modport的I/O列表中的时钟块。 对于练习2中的时钟块，请填写下面计时图中的data_in和data_out信号。 测试/ reg_bus / clk 测试/ reg_bus / data_in测试/ reg_bus / data_out16 h000016 h0001reg_bus / cb / data_in reg_bus / cb / data_out16 h000016 h000116 h000216 h0003 修改练习2中的时钟块为: 输出写和地址的输出偏移25ns 输入偏差15ns 限制data_in仅在时钟的正边缘更改 对于练习4中的时钟块，填写下面的计时图，假设时钟周期为100ns。 reg_bus / clk reg_bus /写 reg_bus/data_in reg_bus/data_out reg_bus/cb/data_in reg_bus/cb/data_out reg_bus/cb/write . txt "},"articles/chapter-05.html":{"url":"articles/chapter-05.html","title":"第五章　　面向对象基础","keywords":"","body":"第五章 面向对象基础 5.1. 介绍 对于像Verilog和C这样的过程性编程语言，在数据结构和使用它们的代码之间存在很强的划分。数据的声明和类型通常与操作它们的算法在不同的文件中。因此，很难理解程序的功能，因为这两部分是分开的。 Verilog用户比C用户更糟糕，因为在Verilog中没有结构，只有位向量和数组。如果希望存储关于总线事务的信息，则需要多个数组:一个用于地址，一个用于数据，一个用于命令，等等。关于事务N的信息分布在所有数组中。用于创建、传输和接收事务的代码位于一个模块中，该模块可能实际连接到总线，也可能没有。最糟糕的是，数组都是静态的，所以如果您的testbench只分配了100个数组条目，而当前的测试需要101个，您就必须编辑源代码来更改大小并重新堆。因此，数组的大小被调整为能够容纳最大数量的事务，但在正常测试期间，大部分内存都被浪费了。 面向对象编程(OOP)允许您创建复杂的数据类型，并将它们与使用它们的例程联系在一起。您可以通过调用例程来执行一个操作，而不是切换位，从而在更抽象的级别上创建testbench和系统级模型。当您处理事务而不是信号转换时，您是在一个更高的层次上工作，您的代码更容易编写和理解。作为一个额外的好处，您的测试工作台从设计细节中分离出来，使它更加健壮，并且在未来的项目中更容易维护和重用。 如果您已经熟悉OOP，请浏览本章，因为SystemVerilog非常严格地遵循OOP指南。请务必阅读第5.18节以学习如何构建测试平台。第8章介绍了高级面向对象的概念，如继承和更多的测试台技术;它应该被每个人阅读。 5.2. 想想名词，而不是动词 将数据和代码分组在一起有助于创建和维护大型测试工作台。数据和代码应该如何组合在一起?您可以从思考如何执行测试工作台的工作开始。 试验台的目标是对设计施加刺激，然后检查结果是否正确。流入和流出设计的数据被分组到事务中，例如总线周期、操作码、包或数据样本。组织测试工作台的最佳方法是围绕事务，以及您在事务上执行的操作。在OOP中，事务是测试平台的焦点。 你可以想到汽车和试验台之间的相似之处。早期的汽车需要对其内部结构(名词)有详细的了解才能运行。如果你在湿滑的路面上行驶，你必须提前或延迟火花，打开或关闭阻风门，密切注意引擎的速度，并注意轮胎的牵引力。今天，你与汽车的互动达到了很高的水平。当你上了车，你就会执行不同的动作(动词)，比如启动、前进、转弯、停车和一边开车一边听音乐。如果你想发动汽车，只要转动钥匙点火，就可以了。按下油门踏板使汽车移动;用刹车把它停下来。你是在雪地上开车吗?别担心:防抱死刹车可以帮助你在直线上安全停车。你不必考虑底层的细节。 您的测试平台应该以同样的方式构建。传统的testbench是面向必须发生的操作的:创建一个事务，传输它，接收它，检查它，并制作一个报告。相反，您应该考虑测试台的结构，以及每个部分的作用。生成器创建事务并将它们传递到下一层。驱动程序与响应由监视器接收的事务的设计对话。记分板将这些数据与预期数据进行核对。您应该将您的测试工作台划分为块，然后定义它们如何通信。本章展示了这些组件的许多例子。 如何在SystemVerilog中表示这些块?类可以描述一个以数据为中心的块，如总线事务、网络数据包或CPU指令。或者一个类可以代表一个控制块，比如驱动程序或记分牌。无论采用哪种方式，类都将数据与操作数据的例程封装在一起。类如何实现数据生成或检查等操作的细节从外部隐藏，使类更具可重用性。 5.3. 你的第一节课 示例5.1显示了泛型事务的类。它包含一个地址、一个校验和和一个数据值数组。事务类中有两个例程:一个用于显示地址，另一个用于计算数据的校验和。 为了更容易匹配命名块的开头和结尾，您可以在它的结尾添加一个标签。在样例5.1中，这些结束标签可能看起来是多余的，但在具有许多嵌套块的复杂代码中，这些标签可以帮助您找到简单end、endtask、endfunction或endclass的配偶。 示例5.1简单事务类 每个公司都有自己的命名风格。本书使用如下约定:类名以大写字母开头，避免使用下划线，如在事务或包中。常量都是大写的，如CELL_SIZE，变量都是小写的，如count或opcode。你可以随意使用任何你想要的风格。 5.4. 在哪里定义类 您可以在程序、模块、包或任何外部定义和使用SystemVerilog中的类。 启动项目时，可以为每个文件存储一个类。当文件的数量变得太大时，您可以将一组相关的类和类型定义分组到SystemVerilog包中，如示例5.2所示。例如，您可以将所有USB3事务和bfm组合到一个包中。现在您可以独立于系统的其他部分编译这个包了。不相关的类，例如用于其他事务、记分板或不同协议的类，应该保留在单独的文件中。 本书中的代码示例省略了包，以使文本更紧凑。 包中的示例5.2类 样例5.3展示了如何将包导入程序。 例5.3在程序中导入一个包 5.5. OOP的术语 OOP新手和专家的区别是什么?首先是你用的词。通过使用Verilog，您已经了解了一些OOP概念。下面是Verilog 2001中的一些OOP术语、定义和大致的等价内容。 类——一个包含例程和变量的基本构建块。在Verilog中类似的是一个模块。 对象——类的实例。在Verilog中，您需要实例化一个模块来使用它。 句柄——指向对象的指针。在Verilog中，在引用模块外部的信号和例程时使用实例的名称。句柄类似于对象的地址，但存储在只能引用一种类型的指针中。句柄类似于其他OOP语言中的引用。 属性——保存数据的变量。在Verilog中，这是一个信号，比如寄存器或线路。 方法——操作变量的过程代码，包含在任务和函数中。Verilog模块有任务和函数以及initial和always块。 Prototype——例程的头，显示了名称、类型、参数列表和返回类型。例程的主体包含可执行代码。关于原型和体外体验的更多信息，请参阅5.10节。 本书在讨论非oop代码时使用了Verilog中更为传统的术语“变量”和“例程”，对于类则使用“属性”和“方法”。 在Verilog中，您可以通过创建模块并分层实例化它们来构建复杂的设计。在OOP中，您创建类并构造它们(创建对象)来创建类似的层次结构。模块在编译期间实例化，而类在运行时构造。 这里有一个类比来解释这些OOP术语。把一个班级想象成一座房子的蓝图。这个平面图描述了房子的结构，但你不能生活在蓝图中;你需要建造实体的房子。物体就是真正的房子。就像一套蓝图可以用来建造一大片房屋一样，一个单一的类别可以用来建造许多物体。房子的地址就像一个句柄，它唯一地标识你的房子。在你的房子里，你有一些东西，比如灯(开或关)，用开关控制它们。类具有保存值的变量和控制值的例程。一个类的房子可能有许多灯。只需调用turn_on_porch_light()，就可以在单个房子中打开light变量。 5.6. 创建新对象 Verilog和OOP都有实例化的概念，但在细节上有一些不同。在编译设计时实例化一个Verilog模块，比如一个计数器。SystemVerilog类，例如网络数据包，在测试工作台需要时在模拟过程中被实例化。Verilog实例是静态的，因为硬件在模拟过程中不会发生变化;只有信号值改变。SystemVerilog刺激对象不断被创建，并用于驱动DUT和检查结果。稍后，这些对象可能会被释放，以便它们的内存可以被新的对象使用。回到房子的类比:地址通常是静态的，除非你的房子被烧毁了，所以你需要建造一个新的。家里的垃圾收集不是自动的，尤其是当你有十几岁的孩子的时候。 OOP和Verilog之间的类比有一些其他的例外。顶级Verilog模块是隐式实例化的。但是，SystemVerilog类必须在使用之前进行实例化。接下来，Verilog实例名仅引用单个实例，而SystemVerilog句柄可以引用许多对象，但一次只能引用一个对象。 5.6.1 处理和构造对象 在示例5.4中，tr是指向事务类型对象的句柄。为简单起见，您可以只说tr是一个事务句柄。 例5.4声明和使用句柄 当声明句柄tr时，它被初始化为特殊值null。 在下一行中，调用new()函数来构造事务对象。 这个特殊的新函数为事务分配空间，将变量初始化为默认值(2状态变量为0,4状态变量为X)，并返回存储对象的地址。例如，事务类有两个32位寄存器(addr和csm)和一个带有8个值(数据)的数组，总共有10个长字，或40个字节。因此，当您调用new时，SystemVerilog会分配至少40个字节的存储空间。如果您使用过C语言，那么这个步骤类似于调用malloc函数。注意，SystemVerilog需要额外的内存用于4个状态变量和诸如对象类型之类的内部管理信息。 当您创建类的实例时，这个过程称为实例化。新函数有时被称为构造函数，因为它构建对象，就像你的木匠用木头和钉子建造房子。对于每个类，SystemVerilog创建一个默认的新函数来分配和初始化对象。 5.6.2 自定义构造函数 您可以定义自己的new()函数来设置自己的值。注意，不能给出返回值类型，因为构造函数是一个特殊函数，它会自动返回与类类型相同的对象句柄。 示例5.5简单的用户定义new()函数 在样例5.5中，首先SystemVerilog自动为对象分配空间。接下来，它将addr和data设置为固定值，但将csm保留为默认值x。您可以使用带有默认值的参数来创建一个更灵活的构造函数，如示例5.6所示。现在您可以在调用构造函数时指定addr和data的值，或者使用默认值。 带参数的new()函数 SystemVerilog如何知道要调用哪个new()函数?它查看赋值左边句柄的类型。在样例5.7中，在驱动构造函数内部调用new函数调用Transaction的new()函数，即使驱动函数调用的函数更接近。因为tr是一个事务句柄，所以SystemVerilog会做正确的事情，并创建一个事务类型的对象。 示例5.7调用正确的new()函数 5.6.3 分离声明和构造 你应该避免声明句柄并调用构造函数new, allin one语句。虽然这是合法的语法，而且不那么冗长，但它可能会产生排序问题，因为在第一个过程语句之前调用构造函数。您可能需要按特定顺序初始化对象，但如果在声明中调用new()，则不需要这样做 有相同的控制。此外，如果忘记使用自动存储，则在模拟开始时调用构造函数，而不是在进入块时调用。 5.6.4 New()和New[]的区别 您可能已经注意到，这个new()函数看起来很像2.3节中描述的new[]操作符，该操作符用于设置动态数组的大小。它们都分配内存和初始值。最大的区别是调用new()函数来构造单个对象，而new[]操作符构造一个包含多个元素的数组。new()可以接受参数来设置对象值，而new[]只接受数组中元素个数的单个值。只需记住，带方括号[]的new是用于数组的，而带圆括号()的是用于类的，类通常包含方法。 5.6.5 获取对象的句柄 新的OOP用户经常把对象和它的句柄搞混。两者截然不同。您声明一个句柄并构造一个对象。在模拟过程中，句柄可以指向许多对象。这就是OOP和SystemVerilog的动态特性。不要把句柄与对象混淆。 在示例5.8中，t1首先指向一个对象，然后指向另一个对象。图5.1显示了产生的手柄和对象。 示例5.8分配多个对象 图5.1分配多个对象后的句柄和对象 为什么要动态地创建对象?在模拟过程中，您可能需要创建数百或数千个事务。SystemVerilog允许您在需要时自动创建对象。在Verilog中，您必须使用足够大的固定大小数组来容纳事务的最大数量。 注意，这种对象的动态创建不同于之前在Verilog语言中提供的任何其他东西。在编译期间，Verilog模块的实例及其名称被静态地绑定在一起。即使使用在模拟过程中不断变化的自动变量，名称和存储也总是捆绑在一起的。 把手的一个类比是参加会议的人。每个人都像一个物体。当你到达时，你的名字就会被“构造”成一个徽章。这个徽章是一个把手，组织者可以用它来记录每个人。当你坐下来听讲座时，空间已经分配好了。您可能有多个参与者、演示者或组织者的徽章。当您离开会议时，您的徽章可以通过在其上写一个新的名字来重用，就像一个句柄可以通过分配来指向不同的对象。最后，如果你丢了你的徽章，没有任何东西能证明你的身份，你会被要求离开。你占用的空间，你的座位，会被别人回收利用。 5.7. 对象回收 现在你知道了如何创建一个对象——但是你如何摆脱它呢?例如，你的测试工作台创建并发送数千个事务，比如数据包、指令、帧、中断等等到你的DUT。一旦知道事务已经成功完成，就不需要保留它了。你应该回收内存;否则，长时间的模拟可能会耗尽内存。 垃圾回收是自动释放不再引用的对象的过程。SystemVerilog能够判断一个对象是否不再被使用的一种方法是跟踪指向该对象的句柄的数量。当最后一个句柄不再引用对象时，SystemVerilog将释放该对象的内存。(寻找未使用对象的实际算法因模拟器而异。本节描述最容易理解的引用计数)。 示例5.9创建多个对象 示例5.9中的第二行调用new()构造一个对象并将地址存储在句柄t中。下一个调用new()构造第二个对象并将其地址存储在t中，覆盖之前的值。由于没有指向第一个对象的句柄，SystemVerilog可以释放它。对象可以立即删除，也可以在短时间后删除。最后一行显式地清除句柄，以便现在可以释放第二个对象。 如果您熟悉c++，那么这些对象和句柄的概念是熟悉的，但是有一些重要的区别。SystemVerilog句柄只能指向一种类型的对象，因此它们被称为“类型安全的”对象。在C语言中，一个典型的空指针只是内存中的一个地址，你可以将它设置为任何值，或者用预增操作符(pre-increment)修改它。您不能确定指针是否有效。c++类型的指针要安全得多，但您可能会被C的灵活性所吸引。SystemVerilog不 允许对句柄进行任何修改，或使用一种类型的句柄引用另一种类型的对象。(SystemVerilog的OOP规范更接近Java，而不是c++)。 由于SystemVerilog垃圾在没有更多句柄引用对象时收集对象，所以可以确保代码总是使用有效句柄。在C / c++中，指针可以指向一个已经不存在的对象。在这些语言中，垃圾收集是手动的，因此当您忘记释放对象时，您的代码可能会遭受“内存泄漏”。 SystemVerilog不能垃圾收集仍然由句柄引用的对象。例如，如果将对象保留在一个链接列表中，则SystemVerilog无法释放对象，直到您通过将它们设置为null手动清除所有句柄。如果一个对象包含派生线程的例程，则该对象在线程运行时不会被分配。同样地，任何对象 被衍生的线程使用的线程在线程终止之前不能被释放。有关线程的更多信息，请参阅第7章。 5.8. 使用对象 既然已经分配了一个对象，那么如何使用它呢?回到Verilog模块的类比，您可以使用“。标记，如示例5.10所示。 在对象中使用变量和例程 在严格的OOP中，对对象中变量的唯一访问应该是通过访问函数，如get()和put()。这是因为直接访问变量会限制您将来更改底层实现的能力。如果将来出现了更好的(或者只是不同的)算法，您可能无法采用它，因为您还需要修改对变量的所有引用。 这种方法的问题在于，它是为寿命长达十年或更长的大型软件应用程序编写的。在数十名程序员进行修改的情况下，稳定性是至关重要的。然而，您正在创建一个测试平台，其目标是最大限度地控制所有变量，以生成最大范围的刺激值。实现这一目标的一种方法是使用受限随机刺激 逻辑单元的生成，如果一个变量隐藏在冰毒屏幕后面，这就不能完成。尽管get()和put()方法适用于编译器、gui和api，但您应该坚持使用可以在测试台中任何地方直接访问的公共变量。 这个规则的例外是由一个组(如公司)创建和维护的验证IP，该组与最终用户没有直接关系。例如，如果您从另一家公司购买了一个PCI处理程序，他们将限制对内部的访问，迫使您将其视为一个黑盒。开发人员必须为您提供足够的方法来生成好的事务和注入各种各样的错误。 5.9. 类方法 类中的方法只是定义在类范围内的任务或函数。样例5.11为事务和PCI_Tran定义了display()方法。SystemVerilog根据句柄类型调用正确的句柄。 示例类中的5.11例程 类中的方法默认使用自动存储，因此不必担心记住自动修饰符。 5.10. 在类的外部定义方法 一个好的经验法则是，在您最喜欢的编辑器中，您应该将一段代码限制在一个“页面”或一个屏幕内，以使其易于理解。对于例程，您可能熟悉这个规则，但它也适用于类。如果您能一次在屏幕上看到类中的所有内容，就更容易理解了。 但是，如果每个方法都取一个页面，那么整个类怎么能装得下一个页面呢?在SystemVerilog中，可以将一个方法分解为类内部的原型(方法名和参数)，以及类之后的主体(过程代码)。下面是如何创建块外声明。复制方法的第一行，包括名称和参数，并在开头添加extern关键字。现在获取整个方法并将其移动到类主体之后，并在方法名称之前添加类名和两个冒号(::作用域操作符)。上面的 类的定义如示例5.12所示。 样例5.12块外方法声明 一个常见的编码错误是原型与外体不匹配。SystemVerilog要求原型与out- block方法声明相同，除了类名和作用域操作符::之外。样机可以有质量保证 本地的、受保护的或虚拟的，但不是体外体的。如果任何参数有默认值，它们必须在原型中给出，但它们在out- body中是可选的。 另一个常见的错误是在类之外声明方法时省略了类名。因此，它定义在更高的作用域(可能是程序或包作用域)，当任务试图访问类级变量和方法时，编译器给出一个错误。示例5.13中显示了这一点。 样例5.13体外方法缺少类名 5.11. 静态变量与全局变量 每个对象都有自己的局部变量，不与任何其他对象共享。如果有两个事务对象，每个事务对象都有自己的addr、csm和数据变量。但有时，您需要一个由特定类型的所有对象共享的变量。例如，您可能希望保持已创建事务数量的运行计数。如果没有OOP，您可能会创建一个全局变量。然后，您将拥有一个由一小段代码使用的全局变量，但对整个测试工作台是可见的。这“污染”了全局名称空间，使每个人都可以看到变量，即使您希望将它们保持在本地。 5.11.1 一个简单的静态变量 在SystemVerilog中，您可以在类中创建静态变量。这个变量在类的所有实例中共享，但是它的作用域仅限于类。在示例5.14中，静态变量count保存到目前为止创建的对象的数量。它在声明中被初始化为0，因为在模拟开始时没有事务。每次构造一个新对象时，它都会被标记为唯一的值，并且count会增加。 带有静态变量的示例5.14类 在示例5.14中，无论创建了多少事务对象，静态变量count都只有一个副本。您可以认为count存储在类中，而不是对象中。变量id不是静态的，所以每个事务都有自己的副本，如图5.2所示。现在，您不需要为计数创建一个全局变量。 图5.2类中的静态变量 使用ID字段是跟踪对象在设计中流动的好方法。在调试测试平台时，您通常需要一个惟一的值。SystemVerilog不允许打印对象的地址，但是可以创建一个ID字段。当您想要创建一个全局变量时，请考虑创建一个类级静态变量。一个类应该是独立的，有尽可能少的外部引用。 5.11.2 通过类名访问静态变量 示例5.14展示了如何使用句柄引用静态变量。你不需要一个手柄;可以使用类名后跟::(类作用域解析操作符)，如示例5.15所示。 类作用域解析操作符 5.11.3 初始化静态变量 静态变量通常在声明中进行初始化。不能在类构造函数中轻松初始化它，因为每个新对象都会调用这个函数。您需要另一个静态变量作为标志，指示原始变量是否已初始化。如果需要更详细的初始化，则可以使用初始块。确保在构造第一个对象之前对静态变量进行初始化。静态变量的另一个用途是当类的每个实例都需要来自单个对象的信息时。例如，事务类可以引用具有事务数量的配置对象。如果在事务类中有一个非静态句柄，那么每个对象都将有自己的副本，这会浪费空间。样本 5.16展示了如何使用静态变量来代替。 示例5.16句柄的静态存储 5.11.4 静态方法 当您使用更多的静态变量时，操作它们的代码可能会发展成一个完整的例程。在SystemVerilog中，甚至在创建第一个实例之前，您就可以在一个类中创建一个静态方法，该方法可以读写静态变量。 样例5.17有一个简单的静态函数来显示静态变量的值。SystemVerilog不允许静态方法读取或写入非静态变量，比如id。您可以根据下面的代码理解这个限制。当在示例结束时调用函数display_statics时，还没有构造事务对象，因此没有为id变量创建存储。 静态方法显示静态变量 5.12. 范围规则 在编写测试工作台时，您需要创建并引用许多变量。SystemVerilog遵循与Verilog相同的基本规则，但有一些有益的改进。 范围是一个代码块，如模块、程序、任务、函数、类或开始/结束块。for和foreach循环自动创建一个块，以便可以在循环的范围内声明或创建索引变量。 你只能在一个块中定义新的变量。SystemVerilog的新特性是能够在未命名的开始-结束块中声明变量。 名称可以是相对于当前范围的，也可以是以$root开头的绝对名称。对于相对名称，SystemVerilog会查找作用域列表，直到找到匹配的为止。如果希望明确，可以在名称的开头使用$root。变量不能在$root中声明，也就是说，在任何模块、程序或包之外。 样例5.18在几个作用域中使用了相同的名称。注意，在实际的代码中，您将使用更有意义的名称!名称限制用于初始块中的全局变量、程序变量、类变量、函数变量和局部变量。后者位于一个未命名的块中，因此创建的标签依赖于工具，以及信号的层次名称。 示例5.18名称范围 对于testbench，可以在程序中或初始块中声明变量。如果一个变量只在单个初始块(如计数器)中使用，则应该在那里声明它，以避免与其他块可能的名称冲突。注意，如果在一个未命名的块中声明一个变量，例如示例5.18中的初始值，那么就没有能够在所有工具中一致工作的分层名称。 在包中的任何程序或模块之外声明类。这种方法可以被所有testbench共享，并且您可以在最内层声明临时变量。这种样式还消除了忘记在类中声明变量时发生的常见错误。SystemVerilog在更高的作用域中查找该变量。 如果一个块使用了一个未声明的变量，而另一个同名的变量恰巧在程序块中声明了，则类会使用它，而不会发出警告。在示例5.19中，函数Bad::display没有声明循环变量i，所以SystemVer- ilog使用程序级别i代替。调用函数会改变的值 测试。我，可能不是你想要的! 示例5.19类使用了错误的变量 如果将类移动到包中，类就无法看到程序级变量，因此不会像示例5.20中所示的那样无意地使用它们。 将类移到包中以查找bug 这是什么? 当您使用变量名时，SystemVerilog会在当前范围中查找该变量，然后在父范围中查找，直到找到该变量。这与Verilog使用的算法相同。如果您在类的深处，并且想要明确地引用类级别的对象，该怎么办?这种样式代码最常用在构造函数中， 程序员对类变量和参数使用相同的名称。在示例5.21中，关键字“this”消除了歧义，让SystemVerilog知道您将局部变量name赋值给类变量name。 示例5.21使用这个引用类变量 有些人认为这种参数命名风格使代码更容易阅读;其他人认为这是一个懒惰的程序员的捷径。 5.13. 在另一个类中使用一个类 使用对象句柄，一个类可以包含另一个类的实例。这就像Verilog的概念一样，在另一个模块中实例化一个模块来构建设计层次结构。使用包含的一个常见原因是代码重用和控制复杂性。例如，你的每一个事务都可能有一个统计块，包括表明事务开始和结束传输的时间戳，以及所有事务的信息，如图5.3和样本5.22所示。 类交易;bit [31:0] addr, crc, data[8];统计数据;endclass类的统计数据;时间startT stopT;static int ntrans= 0;total_elapsed_time静态时间;endclass 图5.3包含对象 示例5.22统计类声明 现在，您可以在另一个类(如事务)中使用Statistics类，如示例5.23中所示。 示例5.23封装Statistics类 最外层的类Transaction可以使用通常的层次结构语法引用Statistics类中的内容，比如stats.startT。 记住要实例化对象;否则，句柄stats为null，启动调用失败。这最好在外部类Transaction的构造函数中完成。 当你的类变大时，它们可能会变得很难管理。当变量声明和方法原型增长到超过一个页面时，您应该查看类中是否有一个项的逻辑分组，以便将其分成几个较小的分组。 这也是一个潜在的信号，表明是时候重构你的代码了。美国把它分成几个较小的、相关的类。关于类继承的更多细节请参见第8章。看看你想在课堂上做什么。有什么东西你可以移动到一个或多个基类，例如。，将单个类分解为一个类层次结构?一个典型的指示是类似的代码出现在类的不同位置。您需要将该代码分解为当前类中的一个函数，当前类的父类之一，或两者兼得。 5.13.1 我的班级应该多大还是小? 正如您可能想要划分太大的类一样，您也应该对类的大小有一个下限。只有一两个成员的类会使代码更难理解，因为它增加了一层额外的层次结构，并迫使您不断地在父类和所有子类之间来回跳转 理解它的作用。另外，看看它的使用频率。如果一个小的类只实例化一次，您可能想要将它合并到父类中。 Synopsys的一位客户将每个事务变量放入自己的类中，以便更好地控制随机化。该事务有一个单独的对象，用于地址、校验和、数据等。最后，这种方法只会使类层次结构更加复杂。在下一个项目中，他们将等级制度扁平化了。 请参阅第8.4节了解关于分区类的更多思想。 5.13.2 编译顺序问题 有时，您需要编译包含另一个尚未定义的类的类。句柄的声明会导致错误，因为编译器无法识别新类型。用typedef语句声明类名，如示例5.24所示。 示例5.24使用typedef类语句 5.14. 理解动态对象 在静态分配的语言(如Verilog)中，每个信号都有一个惟一的关联变量。例如，可能有一个称为grant的连接、整数计数和一个模块实例i1。在OOP中，并不存在相同的一对一的对应。可以有许多对象，但只有少数几个命名句柄。在模拟过程中，一个testbench可能分配一千个事务对象，但是可能只有几个句柄来操作它们。如果您只编写过Verilog代码，则需要一些时间来适应这种情况。 实际上，有一个句柄指向每个活动对象。一些句柄可以存储在数组或队列中，或者存储在另一个对象中，比如链表。对于存储在邮箱中的对象，句柄位于内部SystemVerilog结构中。有关邮箱的更多信息，请参见第7.6节。请记住，一旦给指向对象的最后一个句柄赋了新值，该对象就会被垃圾回收。 5.14.1 将对象和句柄传递给方法 将对象传递给方法时会发生什么?也许该方法只需要读取对象中的值，比如上面的transmit。或者，您的方法可以修改对象，就像创建包的方法一样。无论哪种方式，当您调用方法时，您传递的是对象的句柄，而不是对象本身。 图5.4跨方法的句柄和对象 在图5.4中，生成器任务刚刚调用了transmit。有两个把手，生成器。t和传输。t，两者都指向同一个物体。 在调用方法时，如果将一个标量变量(如句柄)传递给ref参数，则SystemVerilog将传递变量的地址，以便方法可以对其进行修改。如果不使用ref，则SystemVerilog将标量的值复制到参数变量中，因此对方法中参数的任何更改都不会影响原始值。 示例5.25传递对象 在示例5.25中，初始块分配一个事务对象，并使用指向该对象的句柄调用传输任务。使用这个句柄，transit可以读取和写入对象中的值。但是，如果transmit试图修改句柄，结果将不会在初始块中看到，因为t参数没有声明为ref。 即使句柄参数没有ref修饰符，方法也可以修改对象。这常常会给新用户带来困惑，因为他们混淆了句柄和对象。如上所示，传输者可以修改对象中的数据[0] 如果不希望在方法中修改对象，则传递该对象的副本，这样原始对象就不会被修改。有关复制对象的更多信息，请参阅5.15节。 5.14.2 修改任务句柄 一个常见的编码错误是忘记在要修改的方法参数上使用ref，特别是句柄。在样例5.26中，参数tr没有声明为ref，因此调用代码不会看到对它的任何更改。参数tr有默认的输入方向。 错误的事务创建任务，缺失ref on句柄 尽管create修改了参数tr，但调用块中的句柄t仍然保持为空。您需要将参数tr声明为ref，就像示例5.27中看到的那样。 带有ref on句柄的良好事务创建器任务 如果一个方法只打算修改对象的属性，那么该方法应该将句柄声明为输入参数。如果一个方法要修改句柄，例如使其指向一个新对象，那么该方法必须将句柄声明为ref参数。 5.14.3 修改飞行中的物体 一个非常常见的错误是忘记为testbench中的每个事务创建一个新对象。在示例5.28中，generate_ bad任务创建了一个带有随机值的事务对象，并在几个循环中将其传递到设计中。 坏生成器只创建一个对象 这个错误的症状是什么?上面的代码只创建一个事务，因此每次通过循环时，generator_bad都会在传输对象的同时更改该对象。当您运行它时，$display会显示许多addr值，但是所有传输的事务对象都有相同的addr值。当传输衍生出一个需要几个周期来发送事务的线程时，bug就会变得可见，因此在传输过程中对象中的值被重新随机化。如果您的传输任务复制了该对象，则可以反复回收同一对象。这个错误也可能发生在邮箱上，如示例7.32所示 为了避免此错误，您需要在每次经过循环时创建一个新事务，如示例5.29所示。 Good generator创建了许多对象 5.14.4 数组的处理 当您编写testbench时，您需要能够存储和引用许多对象。可以创建句柄数组，每个句柄指向一个对象。样例5.30展示了在一个数组中存储10个总线事务处理。 使用句柄数组的示例5.30 数组tarray由句柄组成，而不是对象。因此，您需要在使用数组中的每个对象之前构造它，就像使用普通句柄一样。没有办法在整个句柄数组上调用new。 没有所谓的“对象数组”，尽管您可以使用这个术语作为指向对象的句柄数组的简写。请记住，一些句柄可能被设置为null，或者多个句柄可能指向一个对象。 5.15. 复制对象 您可能希望复制对象以防止方法修改原始对象，或在生成器中保存约束。您可以使用new操作符提供的简单内置副本，也可以为更复杂的类编写自己的副本。请参阅第8.2节了解为什么您应该创建复制方法的更多原因。 5.15.1 使用New操作符复制对象 使用new操作符复制对象很容易，也很可靠，如Sample所示 5.31。为新对象分配内存，并复制现有对象中的所有变量。但是，您可能已经定义的任何new()函数都不会被调用。 用new复制一个简单的类 这是一种浅拷贝，类似于原始的影印，盲目地从源端抄写值到目的端。如果该类包含另一个类的句柄，则new操作符只复制句柄的值，而不是较低级别的对象的完整副本。在示例5.32中，事务类包含Statistics类的句柄，最初在示例5.22中显示。 示例5.32复制带有new操作符的复杂类 初始块创建第一个事务对象，并在包含的对象统计中修改一个变量，如图5.5所示。 图5.5使用new操作符复制之前的对象和句柄 当使用new操作符进行复制时，会复制事务对象，但不会复制统计数据对象。这是因为new操作符不调用您自己的new()函数。相反，将复制变量和句柄的值。所以现在两个事务对象有相同的id，如图5.6所示。 图5.6使用new操作符复制后的对象和句柄 更糟糕的是，两个事务对象都指向同一个统计对象，因此使用src句柄修改startT会影响使用dst句柄所看到的情况，如图5.7所示。 图5.7 src和dst对象都指向一个统计对象，并看到更新的startT值 5.15.2 编写自己的简单复制函数 如果您有一个简单的类，不包含对其他类的任何引用，那么编写复制函数就很容易，正如您在示例5.33和5.34中看到的那样。不是调用new()函数并复制每个单独的变量，copy函数可以使用new操作符，但是它需要复制在new()中完成的任何处理，比如设置id。 示例5.33带有copy函数的简单类 示例5.34使用复制函数 5.15.3 编写深度复制函数 对于非平凡类，您应该始终创建自己的复制函数，如示例5.35所示。通过调用包含的所有对象的复制函数，可以使其成为深度复制。您自己的复制功能可以确保所有用户字段(如id)保持一致。创建自己的复制函数的缺点是，在添加新变量时需要保持更新——如果忘记一个变量，您可能会花费数小时调试以找到丢失的值。 带有深度复制函数的示例5.35复杂类 new()构造函数是通过copy调用的，因此每个对象都有一个唯一的id。为Statistics类添加一个copy()方法，如示例5.36所示，以及层次结构中的所有其他类。 示例5.36统计类声明 现在，当您创建事务对象的副本时，它将拥有自己的副本 统计对象，如示例5.37所示。 复制带有new操作符的复杂类 图5.8深度复制后的对象和处理 好消息是UVM数据宏会自动创建复制函数，因此您不必手工编写它们。手动创建这些变量非常容易出错，尤其是在添加新变量时。 5.15.4 使用流操作符在数组和数组之间打包对象 有些协议，如ATM，一次一个字节传输控制和数据值。在发送事务之前，需要将对象中的变量打包到一个字节数组中。同样，在接收到字节串之后，您需要将它们解包回事务对象中。对于这两个函数，使用流操作符，如2.12节所示。 您不能只是流化整个对象，因为这将收集所有属性，包括数据和元数据，如时间戳和您可能不想打包的自检信息。您需要编写自己的包函数，如示例5.38和5.39中所示，该函数只使用您选择的属性。 更多的好消息- UVM数据宏创建了pack和unpack方法。 带有pack和unpack函数的5.38事务类示例 示例5.39使用pack和unpack函数 5.16. 公共与地方 OOP的核心概念是将数据和相关方法封装到一个类中。默认情况下，变量对类来说是局部的，以防止一个类在另一个类内部到处乱翻。类提供了一组访问器方法来访问和修改数据。这也允许您更改实现，而不需要让类的用户知道。例如，只要用户界面(访问器方法)具有相同的功能，图形包就可以将其内部表示从笛卡尔坐标更改为极坐标。 考虑具有有效负载和校验和的事务类，以便硬件可以检测错误。在传统的OOP中，您需要使用一个方法来设置有效负载，并设置校验和，使它们保持同步。因此，你的对象将总是充满正确的值。 然而，testbench不同于web浏览器或文字处理程序等其他程序。测试工作台需要创建错误。您希望有一个错误的校验和，以便测试硬件对错误的反应。 OOP语言，如c++和Java，允许你指定变量和方法的可见性。默认情况下，类中的所有内容都是局部的，除非有其他标记。 在SystemVerilog中，所有内容都是公共的，除非标记为本地或受保护。您应该坚持使用这个默认值，这样您就可以最大限度地控制DUT的运行，这比长期的软件稳定性更重要。例如，使校验和可见允许您轻松地将错误注入 DUT。如果校验和是本地的，您就必须编写额外的代码来绕过数据隐藏机制，从而产生更大更复杂的测试平台。 5.17. 迷失偏离轨道 作为一名新的OOP学生，您可能倾向于跳过将项分组到类中所需要的额外思想，而只是将数据存储在几个变量中。避免诱惑!一个基本的DUT监视器从一个接口中采样几个值。不要只是将它们存储在一些整数中并传递给下一个阶段。这首先会节省您几分钟的时间，但最终您需要将这些值组合在一起以形成一个完整的事务。可能需要对其中几个事务进行分组，以创建更高级别的事务，如DMA传输。相反，应立即将这些接口值放入事务类中。现在，您可以将相关信息(端口号、接收时间)与数据一起存储，并轻松地将该对象传递给测试工作台的其余部分。 5.18. 建立一个Testbench 现在您已经了解了OOP的基础知识，您可以了解如何从一组类创建分层的测试工作台。图5.9是第一章的图。显然，在块之间流动的事务是对象，但是每个块也用一个类建模。 图5.9分层试验台架 生成器、代理、驱动程序、监视器、检查器和记分板都是类，建模为事务处理程序(将在下面描述)。它们在Environment类中实例化。为简单起见，测试位于层次结构的顶部，实例化环境类的程序也是如此。函数覆盖定义可以放在环境类的内部或外部。关于分层验证环境及其组件的描述，请参见1.10节。 事务处理程序由一个简单的循环组成，该循环从前一个块接收事务对象，进行一些转换，并将其发送到下一个块，正如您在示例5.40中看到的那样。有些，如生成器，没有上游块，因此这个事务处理程序构造并随机化每个事务，而其他的，如驱动程序，接收事务并将其作为信号转换发送到DUT。 示例5.40基本处理程序 如何在块之间交换事务?使用过程代码，可以让一个对象调用下一个对象，或者可以使用FIFO这样的数据结构来保存块之间流动的事务。在第7章中，你将学习如何使用邮箱，这是一种fifo，它具有在添加新值之前暂停线程的能力。 5.19. 结论 使用面向对象编程是一大步，特别是如果您的第一种计算机语言是Verilog。这样做的好处是您的测试工作台更加模块化，因此更容易开发、调试和重用。 要有耐心——您的第一个OOP测试平台可能看起来更像添加了几个类的Verilog。当您掌握了这种新的思维方式后，您就开始为事务和测试台中处理事务的事务创建和操作类。 在第8章中，你将学到更多的面向对象技术，这样你的测试就可以改变底层测试平台的行为，而不需要改变任何现有的代码。 5.20. 练习 创建一个名为MemTrans的类，该类包含以下成员，然后在初始块中构造一个MemTrans对象。 逻辑类型的8位数据 逻辑类型的4位地址 一个名为print的void函数，输出data_in和address的值 使用练习1中的MemTrans类，创建一个自定义构造函数，即new函数，这样data_in和address都初始化为0。 使用练习1中的MemTrans类，创建一个自定义构造函数，使data_in和address都初始化为0，但也可以通过传入构造函数的参数进行初始化。此外，编写一个程序来执行以下任务。 创建两个新的MemTrans对象。 在第一个对象中初始化address为2，按名称传递参数。 在第二个对象中，将data_in初始化为3，并将address化为4，通过名称传递参数。 修改练习3中的解决方案以执行以下任务。 建设后，设置第一个对象的地址为4'hF。 使用print函数打印出这两个对象的data_in和address的值。 显式地释放第二个对象。 使用练习4中的解决方案，创建一个静态变量last_address，它保存最近创建的对象的address变量的初始值，就像构造函数中设置的那样。在分配MemTrans类的对象之后(练习4中完成)，打印last_address的当前值。 使用练习5中的解决方案，创建一个名为print_last_ address的静态方法，该方法打印出静态变量last_address的值。分配MemTrans类的对象后，调用print_last_address方法打印last_address的值。 给定以下代码，在MemTrans类中完成print_all函数，使用类prinutility打印data_in和address。演示如何使用print_all函数。 完成以下以//开头的注释所指示的代码。 对于下面的类，创建一个复制函数并演示它的用法。假设Statistics类有自己的复制函数。 "},"articles/chapter-06.html":{"url":"articles/chapter-06.html","title":"第六章　　随机","keywords":"","body":"第六章 随机化 6.1. 介绍 随着设计规模的扩大，创造一套完整的刺激来检查它们的功能变得越来越困难。您可以编写一个定向测试用例来检查一组特定的特性，但是当每个项目的特性数量不断增加时，您无法编写足够的定向测试用例。更糟糕的是，所有这些功能之间的交互是最严重的漏洞的来源，并且是最不可能通过一大堆功能被发现的。 解决方案是使用受限随机测试(CRT)自动创建测试用例。定向测试可以找到你认为存在的bug，而CRT则可以通过随机刺激找到你从未想过的bug。您可以通过使用约束将测试场景限制为既有效又有趣的场景。 为CRT创建环境比为定向测试创建环境需要更多的工作。一个简单的定向测试只是应用刺激，然后你手动检查结果。这些结果被捕获为一个黄金日志文件，并与未来的模拟进行比较，以查看测试是通过还是失败。CRT需要一个环境来预测结果，使用参考模型、传递函数或其他技术，再加上功能覆盖来衡量刺激的有效性。然而，一旦该环境就位，您就可以运行数百个测试，而不必手工检查结果，从而提高了生产率。这种测试编写时间(你的工作)与CPU时间(机器工作)的权衡使得CRT如此有价值。 CRT由两部分组成:使用一个随机值流创建DUT输入的测试代码，以及伪随机数生成器(PRNG)的种子，见本章末尾的6.16.1节。你可以通过使用一个新的种子使一个CRT表现不同。该特性允许您利用每个测试，因此每个测试都是许多定向测试的功能对等物，只需更改种子即可。与直接测试相比，使用这些技术可以创建更多的等效测试。 你可能会觉得这些随机测试就像扔飞镖。您如何知道您已经涵盖了设计的所有方面?刺激空间太大，无法产生所有可能的输入，所以你需要生成一个有用的子集。在第9章中，您将学习如何通过使用功能覆盖率来度量验证进度。 使用随机化的方法有很多，本章给出了很多例子。它强调最有用的技巧，但是选择最适合你的。 6.2. 如何随机 当你考虑随机化设计刺激时，你首先想到的可能是数据字段。这些是最容易创建的-只需调用$random。问题是，这种方法在发现bug方面的回报非常低:您只能发现数据路径bug，可能还有位级错误。这种测试仍然是固有的。具有挑战性的错误在控制逻辑中。因此，您需要随机化DUT中的所有决策点。只要控制路径出现分歧，随机化就会增加你在每个测试案例中选择不同路径的可能性。 您需要广泛地考虑所有的设计输入，如以下项目。 设备配置 环境配置 主要输入数据 封装的输入数据 协议异常 延迟 交易状态 错误和违规 6.2.1 设备配置 在测试RTL设计时遗漏bug最常见的原因是什么?没有尝试足够的不同配置!大多数测试只是在重新设置后使用设计，或者应用一组固定的初始化向量将其置于已知状态。这就像在PC安装完之后测试它的操作系统，而没有任何应用程序;当然，性能很好，也没有崩溃。 随着时间的推移，在真实的环境中，DUT的配置变得越来越随机。在一个真实的例子中，一个验证工程师必须验证一个有600个输入通道和12个输出通道的timedivision多路复用开关。当设备安装在终端客户的系统中时，通道将被一次又一次地分配和回收。在任何时候，几乎没有 相邻通道之间的相关性。换句话说，构型看起来是随机的。 为了测试这个设备，验证工程师必须编写几十行Tcl代码来配置每个通道。因此，她永远无法尝试使用超过少数几个通道的配置。使用CRT方法，她编写了一个测试平台，将单个通道的参数随机化，然后将其放入循环中来配置整个设备。现在她有信心，她的测试将发现以前可能被遗漏的错误。 6.2.2 环境配置 您正在设计的设备在包含其他设备的环境中运行。在验证DUT时，它连接到一个模拟此环境的测试平台。您应该随机化整个环境，包括对象的数量和它们的配置方式。 另一家公司正在创建连接多个总线到内部内存总线的PCI交换机。在模拟开始时，客户使用随机选择PCI总线的数量(1-4)、每个总线上的设备数量(1-8)以及每个设备的参数(主或从、CSR地址等)。尽管有很多可能的组合，这家公司知道所有的都已经被覆盖了。 6.2.3 主要输入数据 在阅读有关随机刺激的内容时，您可能首先想到的是:取一个事务，比如总线写入或ATM单元，然后用一些随机值填充它。这能有多难呢?实际上，只要您仔细准备事务类，这是相当简单的。您应该预料到任何分层协议和错误注入。 6.2.4 封装的输入数据 许多设备处理多层次的刺激。例如，一个设备可能创建TCP流量，然后在IP协议中进行编码，最后以以太网数据包的形式发送出去。每个关卡都有自己的控制字段，可以随机化以尝试新的组合。所以你是随机的数据和围绕它的层。您需要编写创建有效控制字段但也允许注入错误的约束。 6.2.5 协议异常、错误和违反 任何可能出错的事，最终都会出错的。设计和验证中最具挑战性的部分是如何处理系统中的错误。您需要预测所有可能出错的情况，将它们注入到系统中，并确保设计能够优雅地处理它们，而不会锁定或进入非法状态。一个优秀的验证工程师会在功能规范的边缘，有时甚至超出功能规范的范围来测试设计的行为。 当两个设备通信时，如果传输中途停止会发生什么?您的测试台可以模拟这些中断吗?如果存在错误检测和纠正字段，则必须确保尝试所有组合。 这些错误的随机部分是，您的testbench应该能够发送功能正确的刺激，然后，通过反转配置位，开始以随机间隔注入随机类型的错误。 6.2.6 延迟 许多通信协议规定了延迟的范围。总线授予在请求之后进行一到三个周期。来自内存的数据在第四到第十总线周期有效。然而，许多针对最快的模拟进行了优化的定向测试使用了最短的延迟，只有一个测试只尝试各种延迟。在每次测试中，您的测试平台应该总是使用随机的、合法的延迟，试图找到(有希望的)暴露设计缺陷的组合。 在周期水平以下，有些设计对时钟抖动很敏感。通过少量地来回滑动时钟边缘，您可以确保您的设计对时钟周期的微小变化不会过度敏感。 时钟生成器应该位于testbench之外的模块中，以便它在活动区域中创建事件以及其他设计事件。然而，生成器应该具有一些参数，例如频率和偏移量，这些参数可以由测试台在配置阶段设置。 请注意，本书中描述的方法是用于查找功能错误，而不是时间错误。你的受限的随机测试工作台不应该完全违背设置和保持需求。使用时间分析工具可以更好地验证这些。 6.3. 随机化在SystemVerilog SystemVerilog中的随机刺激生成在与OOP一起使用时最有用。首先创建一个类来保存一组相关的随机变量，然后让随机求解器用随机值填充它们。您可以创建约束来将随机值限制为合法值，或者测试特定的特性。 您可以随机化单个变量，但这种情况是最不有趣的。真正的约束随机刺激是在事务级别创建的，而不是一次一个值。 6.3.1 带有随机变量的简单类 样例6.1显示了一个带有随机变量和约束的包类，以及构造并随机化包的测试bench代码。 示例6.1简单随机类 这个类有四个随机变量。前三种方法使用rand修饰符，这样每次对类进行随机化时，变量都会被赋值。想象一下掷骰子，每次掷骰子都可以是一个新值或重复当前值。kind变量为randc，即随机循环，因此随机求解器不会重复一个随机值，直到每个可能的值都被分配。想象一下从一副牌中发牌，你以随机顺序发牌，然后洗牌，再以不同的顺序发牌。注意，循环模式是针对单个变量的。具有5个元素的randc数组有5个不同的模式，比如并行处理的5副牌。模拟器只需要实现具有256个不同值的8位宽的randc变量，但是大多数都支持更大的范围。 约束只是一组关系表达式，对于所选择的变量值必须为真。在本例中，src变量必须大于10且小于15。注意约束表达式是用花括号:{}分组的。这是因为这段代码是声明性的，而不是过程性的，它使用了begin…end。 如果发现约束问题，randomize函数返回0。代码检查结果，如果有问题，则使用$finish停止模拟。或者，您可能希望在完成一些内部事务(如打印摘要报告)之后，调用一个特殊的例程来结束模拟。本书的其余部分使用了一个宏而不是这些额外的代码。 不应该在类构造函数中随机化对象。您的测试可能需要打开或关闭约束，更改权重，甚至在随机化之前添加新的约束。构造函数是用来初始化对象的变量的，如果在这个早期阶段调用randomize，那么最终可能会丢弃结果。 类中的变量应该是随机的和公共的。这使你的测试对DUT的刺激和控制有最大的控制权。可以禁用变量的随机化，如第一部分所示 6.11.2。如果您忘记让一个变量是随机的，您必须编辑环境，这是您希望避免的。例外的是，像权重和限制这样的配置变量不应该是这样的 在事务类中随机，因为它们的值在模拟开始时被选择，并且不更改。 6.3.2 检查随机化结果 randomize函数将随机值赋给类中标记为rand或randc的任何变量，并确保遵守所有活动约束。如果你的代码有冲突的约束，随机化可能会失败(见下一节)，所以你应该总是检查状态。如果不进行检查，这些变量可能会得到意想不到的值，从而导致模拟失败。 本书中其余的代码示例使用了样例6.2中的宏来检查随机化的结果。如果采用这种风格，您可以很容易地添加代码来给出有意义的错误消息并优雅地结束模拟。这个宏展示了几个编码技巧，包括将生成的代码包装在一个do…while状态中，这样就可以像使用以分号结束的普通语句一样使用它，包括在一个if-else语句中，VMM日志宏做得对，但OVM不行。 样本6.2随机检查宏和示例 6.3.3 约束解算器 求解约束表达式的过程由SystemVerilog约束求解器处理。求解器选择满足约束条件的值。这些值来自SystemVerilog的PRNG，它以一个初始种子开始。如果您给SystemVerilog模拟器相同的种子和相同的测试台，它应该总是产生相同的结果。请注意，更改工具版本或开关(如debug级别)可能会更改结果。请参阅本章末尾的练习，了解如何指定初始种子。 求解器是特定于仿真厂商的，当在不同的模拟器上运行时，甚至在同一工具的不同版本上运行时，约束随机测试可能不会给出相同的结果。SystemVerilog标准指定了表达式的含义和所创建的合法值，但没有详细说明求解器操作的精确顺序。关于随机数生成器的更多细节，请参阅6.16节。 6.3.4 什么可以随机化? SystemVerilog允许您随机化整变量，即包含一组简单位的变量。这包括两种状态和四种状态类型，尽管随机化只生成两种状态的值。你可以有整数，位向量等等。不能使用随机字符串或引用约束中的句柄。在LRM中还没有定义实变量的随机化。 6.4. 约束条件的细节 有用的刺激不仅仅是随机值——变量之间存在着关系。否则，可能需要很长时间来生成有趣的刺激值，或者刺激值可能包含非法的值。您可以使用包含一个或多个约束表达式的约束块在SystemVerilog中定义这些交互。SystemVerilog选择随机值，以便表达式为真。 每个表达式中至少有一个变量是随机的，可以是rand或randc。以下类别在随机化时是失败的，除非年龄恰好在正确的范围内。解决方案是在年龄之前添加修饰词rand或randc。 示例6.3没有随机变量的约束 randomize函数尝试给随机变量分配新值，并确保所有约束都得到满足。在Sample 6.3中，因为没有随机变量，所以randomize只是检查age值，看看它是否在约束c_teenager指定的范围内。除非变量在13:19的范围内，否则ran- domize会失败。虽然可以使用约束来检查非随机变量是否具有有效值，但可以使用assert或if语句。调试过程检查程序代码要比阅读来自随机求解器的错误消息容易得多。 6.4.1 约束的介绍 示例6.4显示了一个带有随机变量和约束的简单类。具体的构造将在下面的章节中解释。注意，在约束块中，您使用花括号{}将多个表达式组合在一起。begin…end关键字用于过程代码。 示例6.4约束随机类 6.4.2 简单的表达式 样例6.4展示了一个包含几个表达式的约束块。前两个控件控制len变量的值。如您所见，一个变量可以在多个表达式中使用。 一个表达式中最多只能有一个操作符，例如=或>。示例6.5显示了SystemVerilog的缺陷，它错误地尝试以固定顺序生成三个变量。 示例6.5糟糕的排序约束 示例6.6是由错误的排序约束导致的 示例6.6显示了结果，这不是我们想要的结果。示例6.5中的约束bad被分解为多个二进制关系表达式，从左到右依次为:((lo 样例6.7约束变量以固定顺序排列 6.4.3 等价表达式 约束最常见的错误是试图在只能包含表达式的约束块中进行赋值。相反，使用等价操作符将一个随机dom变量设置为一个值，例如len==42。您可以构建复杂的 一个或多个随机变量之间的关系:addr_ mode * 4 + payload.size())。 6.4.4 加权分布 如果应用足够多的模式，在受限的随机刺激下，可能会发现DUT中的bug。然而，生成一个特定的极端情况可能需要很长时间。当评审功能覆盖结果时，查看是否生成了极端案例。如果不是，你可以使用一个加权分布来扭曲a中的刺激 特定的方向，从而加速发现bug。dist操作符允许你创建加权分布，这样某些值会比其他值更容易被选择。 dist操作符接受一组值和权重值，用:=或:/操作符分隔。值和权重可以是常量或变量。这些值可以是单个值，也可以是一个范围，如[lo:hi]。权重不是百分比，也不必加起来等于100。: =操作符指定的权重对范围内的每个指定值都相同，而:/操作符指定的权重在所有值之间平均分配。 样本8。8加权随机分布 在示例6.8中，src获得值0、1、2或3。0的权重是40，而1、2、3的权重都是60，总共是220。选0的概率是40/220，选1 2 3的概率都是60/220。 接下来，dst将获得值0、1、2或3。0的权重是40，而1、2和3的总权重是60，总共是100。选0的概率是40/100，选1 2 3的概率都是20/100。 同样，值和权重可以是常量或变量。您可以使用可变权重来动态更改分布，甚至通过将权重设置为0来消除选项，如示例6.9所示。 样例6.9动态改变分布权重 在示例6.9中，len枚举变量有三个值。使用默认的权重值，长字长度会被更频繁地选择，因为w_lwrd的值最大。不要担心，您可以在模拟过程中动态更改权重，以获得不同的分布。 6.4.5 集合成员和内部操作符 可以使用inside操作符创建一组值。SystemVerilog求解器以相等的概率在集合中的值之间进行选择，除非对该变量有其他约束。一如既往，您可以在集合中使用变量。 样本6.10随机值集 在示例6.10中，SystemVerilog使用lo和hi的值来确定可能值的范围。您可以使用这些变量作为约束的参数，这样testbench就可以在不重写约束的情况下改变刺激生成器的行为。注意，如果lo > hi，则形成一个空集合，约束失败。 如果你想要任何值，只要它不在集合中，就用not操作符反转约束:!如示例6.11所示。 样本6.11倒置随机集约束 6.4.6 在集合中使用数组 样例6.12展示了如何通过将一组值存储在数组中来进行选择。 示例6.12数组的随机集约束 这被扩展到示例6.13中的约束中。 样例6.13等价约束集 同样，您可以使用NOT操作符告诉SystemVerilog选择除示例6.14中所示数组中的值以外的任何值。 选择数组之外的任何值 总是确保你的约束如你所期望的那样工作。您可以创建功能性覆盖组并生成报告，或者使用样例6.15中的代码打印一个值的直方图，输出样例6.16中的结果。 示例6.15打印直方图 样本6.16内部约束直方图 样例6.17和6.18从枚举的值列表中选择一周中的哪一天。你可以在飞行中更改选项列表。如果您选择一个randc变量，模拟器会在重复之前尝试每一个可能的值。 示例6.17类从一个数组中选择可能的值 样例6.18从值数组中选择 name函数返回一个包含枚举值名称的字符串。 如果要动态地从集合中添加或删除值，在使用inside操作符之前要考虑到它的性能。也许你有一组价值观，你只想选择一次。您可以使用inside从队列中选择值，然后删除它们，从而缓慢地收缩队列。这要求求解器解出N个约束条件，其中N是剩下的元素数 队列。相反，使用一个randc变量作为选项数组的索引，如示例6.19和6.20所示。选择一个randc值只需要很短的常量时间，而解决大量的约束则需要花费更多的时间，特别是当数组中有几十个元素时。 使用randc以随机顺序选择数组值 Sample 6.20 Testbench for randc choosing array values in random order 注意约束和例程可以以任何顺序混合。 6.4.7 双向约束 现在你可能已经意识到约束块不是过程代码，exe-从上到下切割。它们是声明性代码，同时都是活动的。如果使用set[10:50]的inside操作符约束一个变量，并且使用另一个表达式约束该变量大于20,SystemVerilog将同时解决这两个约束，并且只选择21到50之间的值。SystemVerilog约束是双向求解的，这意味着所有随机变量的约束都是并发求解的。对任何一个变量添加或删除一个约束将影响为所有相关变量选择的值 直接或间接。考虑样例6.21中的约束。 示例6.21双向约束 SystemVerilog求解器同时查看所有四个约束。变量r必须小于t, t必须小于10。但是，r也必须等于s, s大于5。即使没有直接的限制 t越小，s的约束就会限制选择。表6.1显示了这三个变量的可能值。 表6.1双向约束的解决方案 解决方案 r 年代 t 一个 6 6 7 B 6 6 8 C 6 6 9 D 7 7 8 E 7 7 9 F 8 8 9 6.4.8 隐含的约束 通常，所有的约束表达式在一个块中都是活动的。如果您想让表达式只在某些时候激活，该怎么办?设置最高地址，但只针对IO空间模式。SystemVerilog支持两个隐含操作符，->和if。 带有隐含算子的约束块 表达式A->B等价于表达式(!当隐含运算符出现在约束中时，求解器为A和B选择值，因此表达式为真。真值表6.2给出了A和B的逻辑值表达式的值。 表6.2隐含算子真值表 A - B >B = falseB = true一个= false真正的真正的一个= true假真正的 当A为真时，B必须为真，但当A为假时，B可以为真或为假。请注意，这是部分双向约束，但a ->B并不意味着B-> a。这两种表达产生了不同的结果。 在样本6.23中，当d==1时，变量e必须为1，但当e==1时，d可以为 0或1。 示例6.23隐含运算符 如果添加约束{e==0;}，变量d必须为0;但是，如果添加了一个约束{e==1;}，则d的值不受约束，它仍然可以是0或1。 示例6.24展示了如何使用if隐含约束编写示例6.22。 样本6.24带有if隐含算子的约束块 if-else运算符是在多个表达式之间进行选择的一种很好的方法。例如，样例6.9中定义的总线可能支持字节、字和长字读，但只有像样例6.25那样编写时才支持长字写。 带有if-else操作符的约束块 if (A) B else C;等于两个约束(A && B);(!& & C);。示例6.26展示了如何将多个选项链接在一起。 带有多个if-else操作符的约束块 6.4.9 等价算子 等价运算符是双向的。AB定义为((A->B) && (B->A))。表6.3是样本6.27中约束的A和B的逻辑值的真值表。 表6.3等价算子真值表AB B = false B = true = false 真正的 假 一个= true 假 真正的 样本6.27等价约束 当d为真时，e也必须为真，当d为假时，e也必须为假。所以这个运算符和逻辑上的XNOR是一样的。如果你从约束de开始，然后添加一个约束，比如d==1，那么解算器就会把e设为1。约束de和e==0导致d被求解器设置为0。如果你的类有三个约束，de, d==1，和e==0，求解器将不能选择d和e的值。 6.5. 解决方案的可能性 当您处理随机值时，您需要理解结果的概率。SystemVerilog不保证得到随机约束求解器找到的精确解决方案，但您可以影响分布。任何时候你 使用随机数时，你必须查看成千上万个或数百万个数值来平均掉噪音。一些模拟器，如Synopsys VCS，有多个解决方案，让你可以在内存使用和性能之间进行权衡。分布在不同的模拟器之间会有所不同。这些表是用Synopsys VCS 2011.03生成的。 6.5.1 无约束 从一个没有约束的类中的两个随机变量开始，如示例6.28所示。 示例6.28类Unconstrained 表6.4给出了八种可能的解决方案。因为没有限制条件，每一个都有相同的概率。你必须进行成千上万的随机操作，才能看到实际的结果接近列出的概率。 表6.4无约束类的解决方案 解决方案xy概率一个001/8B011/8C021/8D03.1/8E101/8F111/8G121/8H13.1/8 6.5.2 含义 在示例6.29中，y的值取决于x的值。这是用以下约束中的隐含操作符表示的。这个示例和本节中的其他示例也以与if隐含操作符相同的方式表现。 带有隐含约束的示例6.29类 表6.5给出了可能的解决方案和概率。你可以看到，ran- dom求解器识别出x和y的8种组合，但所有x==0的解(解A-D)都被合并在一起。 表6.5 Imp1类的解决方案 解决方案 x y 概率 一个001/2B010C020D03.0E101/8F111/8G121/8H13.1/8 6.5.3 隐含和双向约束 注意，隐含操作符说，当x==0时，y被强制为0，但当y==0时，对x没有约束。然而，隐含是双向的，因为如果y被强制为非零值，x必须为1。样例6.30有约束条件y>0，所以x不可能是0，表6.6给出了解决方案。 带有隐含约束和附加约束的示例6.30类 表6.6 Imp2类的解决方案 解决方案xy概率一个000B010C020D03.0E100F111/3G121/3H13.1/3 之前用解决…来指导分配 您可以使用示例6.31中看到的“solve…before”约束来指导SystemVerilog求解器。 Sample 6.31 Class with implication and solve…before 约束前的解不改变解空间，只改变结果的概率。求解者以相等的概率选择x(0,1)的值。在1000次随机调用中，x约为0 500次，1约为500次。当x = 0时，y = 0。当x = 1时，y可以为0、1、2、3，概率相等，如表6.7所示。 表6.7解x前解y 约束 解决方案xy概率一个001/2B010C020D03.0E101/8F111/8G121/8H13.1/8 如果您在x之前使用约束解y，您会得到一个非常不同的分布，如表6.8所示。 表6.8解y在x之前 约束 解决方案xy概率一个001/8B010C020D03.0E101/8F111/4G121/4H13.1/4 如果你不满意某些值出现的频率，只使用solve…before。过度使用会减慢约束求解器的速度，并使他人难以理解您的约束。 对于示例6.31中的简单类，等价操作符给出了与隐含操作符->相同的解决方案。尝试添加额外的约束条件，并为您最喜欢的模拟器绘制结果。 6.6. 控制多个约束块 一个类可以包含多个约束块。一个块可以确保您有一个有效的事务，如6.7节所述，但是在测试DUT的错误处理时可能需要禁用它。或者，您可能希望为每个测试都有一个单独的约束。也许一个约束会限制数据长度以创建小事务(这对于测试拥塞很好)，而另一个约束则会创建长事务。 可以使用constraint_mode函数打开或关闭约束。您可以使用handle控制单个约束。约束。constraint_mode (arg)。要控制对象中的所有约束，请使用handle。constraint_mode (arg)，如示例6.32所示。当constraint_mode的参数为0时，约束被关闭，当参数为1时，约束被打开。 示例6.32使用constraint_mode 虽然许多小的限制可以给你更多的灵活性，但是打开和关闭它们的过程更加复杂。例如，当您关闭所有创建数据的约束时，您也将禁用所有检查数据有效性的约束。 如果你只是想让一个随机变量变得非随机，可以使用6.11.2节中描述的rand_mode。 6.7. 有效的约束 一个好的随机化技巧是创造一些约束来确保你的随机刺激的正确性，即所谓的“有效约束”。在样例6.33中，总线的read-modify-write命令只允许长字数据长度。 样例6.33使用有效的约束检查写长度 现在您知道总线事务遵守规则。稍后，如果你想违反规则，可以使用constraint_mode来关闭这个约束。当您想要生成错误时，可以使用constraint_mode关闭这些功能。例如，如果一个包的有效载荷长度为零会怎样?您应该有一个命名约定来突出这些约束，例如如上所示使用有效的前缀。 6.8. 内联约束 当您编写更多的测试时，您最终会得到许多约束。它们可以以意想不到的方式相互交互，并且启用和禁用它们的额外代码增加了测试的复杂性。此外，不断地向类添加和编辑约束可能会在团队环境中引起问题。 许多测试只在代码中的一个地方随机化对象。SystemVerilog允许您使用randomize with添加额外的约束。这相当于给现有的约束添加一个额外的约束。样例6.34显示了一个带有约束的基类，然后两个随机化with语句。 示例6.34 randomize() with语句 额外的约束被添加到现有的约束中。如果需要禁用冲突约束，请使用constraint_ mode。注意，在with{}语句中，SystemVerilog使用了类的作用域。这就是为什么样本6。34只使用了addr，而不是t。addr。 一个常见的错误是用圆括号而不是花括号{}来包围行内约束。请记住，约束块使用花括号，所以你的内联约束也必须使用它们。大括号用于声明性代码。 6.9. pre_randomize和post_randomize函数 有时你需要在每次randomize调用之前或之后立即执行一个操作。例如，您可能想要在随机化开始之前设置一些非随机类变量(例如限制或权重)，或者您可能需要计算随机数据的错误纠正位。SystemVerilog允许您使用pre_randomize和post_randomize两个函数来实现这一点，这两个函数是在任何带有随机变量的类中自动创建的。 6.9.1 建造浴缸分布 对于某些应用，你想要一个非线性随机分布。例如，大小数据包更容易发现缓冲区溢出等设计错误 比中型包。所以你想要浴缸形状的分布;两头高，中间低。你可以创建一个精细的dist约束，但这可能需要大量调整才能得到你想要的形状。Verilog有几个用于非线性分布的函数，比如$ dist_index，但是没有用于普通分布的函数。图6.1中的图表显示了如何组合两条指数曲线来制作浴缸曲线。示例6.35中的pre_randomize方法计算指数曲线上的一个点，然后随机选择将其放在左曲线或右曲线上。当您在左右曲线上选择点时，您将逐渐构建一个组合值的分布。 图6.1建筑浴缸分布图 示例6.35构建浴缸分布 每次该对象被随机化时，变量值都会更新。通过许多随机化，您将看到所需的非线性分布。由于变量是按程序计算的，而不是通过随机约束求解器，所以它不需要rand修正器。 参见示例6.64了解post_randomize的另一个示例。 6.9.2 Void函数的注意事项 pre_randomize和post_randomize函数只能调用其他函数，而不能调用可能会消耗时间的任务。在调用randomize过程中不能有延迟。在调试随机化问题时，如果提前计划并将其设置为空函数，则可以调用显示例程。 第8章描述了高级面向对象的概念，包括扩展类和虚拟方法。pre_randomize和post_randomize函数不是虚函数，因此根据句柄的类型调用它们，而不是对象。此外，如果扩展类的pre_randomize或post_randomize需要基类的pre_randomize和post_randomize函数中的功能，它们应该使用super前缀调用这些方法，如super.pre_randomize。 6.10. 随机数函数 您可以使用所有Verilog-1995发行版函数，以及SystemVerilog的几个新函数。有关“dist”函数的更多细节，请查阅统计书籍。一些有用的函数包括以下内容。 $random -平面分布，返回有符号的32位随机 $urandom -平面分布，返回32位无符号随机 $urandom_range -在一个范围内平面分布 $ dist_index -指数衰减，如图6.1所示 $dist_normal -钟形分布 $dist_poisson -钟形分布 $dist_uniform -平面分发 $urandom_range函数接受两个参数，一个可选的低值和一个高值，如示例6.36所示。 示例6.36 $urandom范围的使用 6.11. 约束技巧和技术 如何创建易于修改的约束随机测试?你可以使用一些技巧。最常用的技术是使用OOP来扩展原始类，如第6.11.8和8.2.4节所述，但这需要更多的计划。所以，首先学习一些简单的技巧，但要对其他方法保持开放的心态。 6.11.1 约束和变量 本书中的大多数约束示例都使用了常量，以使它们更具可读性。在示例6.37中，length在一个使用变量作为上界的范围内随机化。 示例6.37带有变量边界的约束 默认情况下，该类会创建1到100之间的随机长度，但是通过更改变量max_length，可以更改上限。 你可以使用dist约束中的变量来打开和关闭值和范围。 在示例6.38中，每个总线命令都有一个不同的权重变量。 样本6.38变量权重的dist约束 默认情况下，这个约束以相同的概率生成每个命令。如果您希望拥有更多的READ8命令，请增加read8_wt权重变量。最重要的是，您可以通过将命令的权重降低到0来关闭命令的生成。 6.11.2 使用非随机值 如果你有一组约束，产生的刺激几乎是你想要的，但不完全是，你可以调用randomize，然后设置一个变量为你想要的值-你不必使用随机值。然而，根据您为检查有效性而创建的约束条件，您的刺激值可能不正确。 如果只是有一些随机变量你想要覆盖，使用rand_ mode函数使它们非随机。当您使用参数为0的随机变量调用此方法时，rand或randc限定符将被禁用，并且随机求解器不再更改变量的值，但如果值出现在约束中，则仍然检入。将随机模式设置为1将打开限定符，这样求解器就可以更改变量。 示例6.39 rand_mode禁用变量的随机化 在示例6.39中，包的大小以随机可变长度存储。测试的前半部分将长度变量和负载动态数组的内容随机化。后半部分调用rand_mode使length成为一个非随机变量，将其设置为42，然后调用randomize。约束将有效载荷大小设置为常数42，但是数组仍然充满了随机值。 6.11.3 使用约束检查值 如果你随机化一个对象，然后修改一些变量，你可以检查对象是否仍然有效，如果所有的约束仍然被遵守。调用处理。randomize(null)和SystemVerilog将所有变量视为非随机(“状态变量”)，并只是确保满足所有约束，即。所有的表达式都是正确的。如果不满足任何约束，randomize函数返回0。 6.11.4 随机化个体变量 假设您想要在一个类中随机化几个变量。可以使用变量的子集调用ran- domize。只有那些传入参数列表的变量才会被随机化;其余的将被视为状态变量而不是随机的。所有的限制仍然有效。在示例6.40中，第一次调用randomize仅更改两个rand变量med和hi的值。第二次调用只更改med的值，而hi保留了它之前的值。令人惊讶的是，您可以传递一个非随机变量(如最后一次调用所示)，只要low遵守约束，它就会得到一个随机值。 样本6.40随机化类中的变量子集 这种只随机化变量子集的技巧并不常用于真正的测试中，因为你限制了刺激的随机性。您希望您的测试平台探索法律价值的全部范围，而不仅仅是一些角落。 6.11.5 关闭和打开约束 第6.6和6.7节讨论了有效约束和constraint_mode。关闭单个约束对于错误生成是好的，但是应该适当使用。 6.11.6 使用内联约束在测试中指定约束 如果你一直向一个类添加约束，它就会变得很难管理和控制。很快，每个人都会从源代码控制系统中检出相同的文件。很多时候，一个约束只被一个测试使用，那么为什么它对每个测试都是可见的呢?本地化约束效果的一种方法是使用内联约束，随机化约束，见第6.8节。如果您的新约束是默认约束的附加约束，那么这将很好地工作。如果您遵循6.7节中的建议来创建“有效约束”，您可以快速地约束有效序列。对于错误注入，您可以禁用任何与您试图做的事情相冲突的约束。注入特定类型的损坏数据的测试将首先关闭检查该错误的特定有效性约束。 使用内联约束有几个折衷。首先，现在您的约束位于多个位置，这可能会使它更难理解所有的活动约束。如果您向原始类添加了一个新的约束，它可能会与内联约束冲突。第二个问题是，您很难跨多个测试重用内联约束。根据定义，内联约束只存在于一段代码中。您可以将它放在一个单独文件中的例程中，然后根据需要调用它。在这一点上，它几乎变成了一种外部约束。 6.11.7 在带有外部约束的测试中指定约束 约束的主体不必在类中定义，就像例程的主体可以在外部定义一样，如5.10节所示。数据类可以定义在一个文件中，其中包含一个空约束。然后，每个测试都可以定义这个约束的自己版本，以生成自己口味的刺激，如示例所示 6.41和6.42。 带有外部约束的示例6.41类 样例6.42定义外部约束的程序 外部约束比内联约束有几个优点。它们可以放在一个文件中，从而在测试之间重用。外部约束适用于类的所有实例，而内联约束仅影响随机化的单个调用。因此，外部约束提供了无需学习高级OOP技术就可以更改类的基本方法。请记住，使用这种技术，您只能添加约束，而不能改变现有的约束，并且您需要在原始类中定义外部约束原型。 与内联约束一样，外部约束也会导致问题，因为约束分布在多个文件中。LRM要求在与原始类相同的范围内定义外部约束。在包中定义的类必须在同一个包中定义它的外部约束，这限制了它的用途。这就是样例6.42包含类定义而不是使用包的原因。 最后要考虑的是，当外部约束的主体从未定义时，会发生什么。SystemVerilog LRM当前没有指定在这种情况下应该发生什么。在构建带有许多外部约束的测试台前，请了解模拟器如何处理缺失的定义。这是一个阻止模拟的错误，只是一个警告，还是根本没有消息? 6.11.8 扩展一个类 在第8章中，你将学习如何扩展一个类。使用这种技术，您可以使用一个使用给定类的testbench，并交换一个扩展类，该扩展类具有额外的或重新定义的约束、例程和变量。关于典型的测试工作台，请参阅示例8.10。请注意，如果在扩展类中定义的约束与基类中的约束同名，则扩展的约束将替换基类中的约束。 学习OOP技术需要更多的学习，但是这种新方法的灵活性带来了巨大的回报。 6.12. 常见的随机化问题 您可能熟悉过程代码，但编写约束条件和理解随机分布需要一种新的思维方式。以下是你在尝试创造随机刺激时可能会遇到的一些问题。 6.12.1 小心使用带符号的变量 在创建testbench时，您可能会倾向于使用int、byte或其他有符号类型的计数器和其他简单变量。不要在随机约束中使用它们，除非你真的想要有符号的值。当样本6。43中的类被随机化时产生了什么值?它有两个随机变量，希望它们的和是64。 样本6。43有符号变量导致随机化问题 显然，您可以获得(32,32)和(2,62)等成对的值。此外，你可以看到(−63,127)，这是方程的合理解，尽管它可能不是你想要的。为了避免无谓的值，例如负长度，只使用无符号随机变量，如示例6.44所示。 样本6.44随机化32位无符号变量 即使是这个版本也会导致问题，因为pkt1_len和pkt2_len的大值(如32'h80000040和32'h80000000)在加在一起时会绕起来，得到32'd64或32'h40。您可能会考虑添加另一对约束来限制这两个变量的值，但最好的方法是根据需要将它们设置为适当的范围，并避免在约束中使用32位变量。在示例6.45中，将两个8位变量的和与一个9位值进行比较。 样本6.45随机无符号8位变量 6.12.2 解算器性能技巧 每个约束求解器都有自己的长处和弱点，但是你可以遵循一些指导方针来提高约束随机变量模拟的速度。工具总是在不断改进，所以请向您的供应商查询更具体的信息。 如果你只是需要用原始数据填充数组，不要使用求解器，因为它有一些选择值的开销，即使是一个没有约束的变量。不要将这些数组声明为rand，而是使用$urandom或$urandom_range计算pre_randomize中的值。这些函数计算值的速度比求解器快100倍，这在您需要快速计算1000个值时非常重要。通常，数组越大，单个值就越不重要，也就越不需要使用求解器。即使您需要一个不一致的值范围，或者值之间存在简单的关系，您也可以使用if语句。 6.12.3 选择合适的算术运算符来提高效率 求解器在约束条件下可以非常有效地处理简单的算术运算，如加减、位提取和移位。然而，乘法、除法和取模对于32位值来说是非常昂贵的。记住，任何没有显式大小的常量，比如42，都被视为32位值32'd42。 如果您想生成靠近页面边界的随机地址，其中一个页面是4096字节，您可以编写以下代码，但如果您使用示例6.46中的约束，求解器可能需要很长时间才能找到合适的addr值。 示例6.46使用mod和unsize变量的昂贵约束 硬件中的许多常量都是2的幂，所以要利用比特提取而不是除法和取模。只约束重要的位，而不是上面的位。同样地，2的乘方可以用移位代替。请注意，一些约束求解器会自动进行这些优化示例 6.47将MOD操作符替换为一个bit extract。 样例6.47带bit提取的有效约束 6.13. 迭代和数组约束 到目前为止提供的约束允许您指定对单个变量的限制。如果你想要随机化一个数组呢?foreach约束和几个数组函数允许您塑造值的分布。 使用foreach约束会创建许多会减慢模拟速度的约束。一个好的求解者可以快速地解决数百个约束条件，但可能会因为数千个约束条件而放慢速度。嵌套的foreach约束尤其慢，因为它们为大小为n的数组产生N2约束。请参阅6.13.5节，了解使用randc变量代替嵌套foreach的算法。 6.13.1 数组大小 最容易理解的数组约束是size函数。在样例6.48中，您将指定动态数组或队列中的元素数量。 样例6.48约束动态数组大小 使用inside约束可以设置数组大小的上下边界。在许多情况下，您可能不想要一个空数组，即size==0。记住要指定上限;否则，你可能会得到成千上万个元素，这可能会导致随机求解器花费过多的时间。 6.13.2 元素的总和 您可以将一个随机的数据数组发送到设计中，但是您也可以使用它来控制流。也许您有一个必须传输四个数据词的接口。字可以连续发送，也可以在多个周期内发送。频闪信号告诉数据信号何时有效。图6.2显示了一些合法的频闪模式，在10个周期内发送4个值。 图6.2随机频闪波形 您可以使用随机数组创建这些模式，如示例6.49所示。使用sum函数将其限制为在整个范围外启用四位。 样本6.49随机频闪模式类 正如你在第二章中所记得的，一个由单个位元素组成的数组的和通常是单个位，例如0或1。样本6.49比较了频闪仪。求和为一个4位值(4’h4)，因此求和以4位精度计算。本例使用4位精度存储最大元素数，即10。 6.13.3 数组约束的问题 sum函数看起来很简单，但由于Verilog的算术规则，可能会导致一些问题。以下是一位作者经历过的一个简单问题——创造约束随机刺激。您希望生成1到8个事务，这样所有事务的总长度都小于1024字节。样本 6.50显示第一次尝试，6.51显示测试程序，6.52显示输出。的 len字段是原始事务中的一个字节。 示例6.50第一次尝试sum约束:bad_sum1 示例6.51程序尝试使用数组和约束 示例6.52 bad_sum1的输出 这会产生一些更小的长度，但总和有时是负的，总是小于127 -绝对不是你想要的!样例6.53显示了另一个尝试，但这次用无符号字段替换字节数据类型。显示功能不变。示例6.54显示了输出。 示例6.53秒尝试求和约束:bad_sum2 示例6.54 bad_sum2的输出 样本6.53有一个微妙的问题。所有事务长度的总和总是小于256，即使您将数组长度限制为小于1024。这里的问题是，在Verilog中，使用8位结果计算许多8位值的总和。样例6.55使用2.8节中的uint类型将len字段增加到32位。 示例6.55第三次尝试求和约束:bad_sum3 示例6.56 bad_sum3的输出 在样本6。56中发生了什么?这类似于第6.12.1节中的有符号问题，因为两个非常大的数的和可以绕成一个很小的数。您需要根据约束中的比较来限制大小。样本6.57和6.58显示了下一次尝试和结果。 示例6.57第四次尝试求和约束:bad_sum4 示例6.58 bad_sum4的输出 因为单个的len字段大于8位，所以len值通常大于255，所以这也行不通。您需要指定每个len字段在1到255之间，但是使用10位字段，以便它们的和正确。这需要约束数组中的每个元素，如下节所示。 6.13.4 约束单个数组和队列元素 SystemVerilog允许使用foreach约束数组的单个元素。虽然您可以通过列出每个元素来编写固定大小数组的约束，但foreach风格更紧凑。约束动态数组或队列的唯一实用方法是使用foreach，如示例6.59和6.60所示。 示例6.59简单foreach约束:good_sum5 示例6.60 good_sum5的输出 为单个元素添加约束修正了示例。注意，len数组可以是10位或10位以上，但必须是无符号的。 只要注意端点，就可以在数组元素之间指定约束。样例6.61中的类通过将每个元素与前一个元素进行比较(第一个元素除外)来创建一个升序值列表。 示例6.61使用foreach创建升序数组值 这些约束会变得多复杂?为了解决爱因斯坦的问题(一个由五个人组成的逻辑谜题，每个人都有五个独立的属性)，八皇后问题(在国际象棋棋盘上放八个皇后，这样就没有人能抓到对方)，甚至数独，已经编写了一些约束。 6.13.5 生成唯一值数组 如何创建一个随机唯一值数组?如果你的数组有N个元素，并且元素值的范围从0..N-1，您可以简单地使用2.6.3节介绍的array shuffle函数。 如果值的范围大于数组元素的数量怎么办?如果您尝试创建一个randc数组，每个数组元素都将被独立随机化，因此几乎可以肯定会得到重复的值。 您可能会倾向于使用一个约束求解器来比较嵌套foreach循环的每个元素，如示例6.62所示。这会产生超过4000个单独的约束，这可能会减慢模拟。 示例6.62使用foreach创建唯一数组值 相反，您应该使用示例6.63中所示的过程代码，并使用包含一个randc变量的helper类，这样您就可以反复随机化相同的变量。 示例6.63使用randc helper类创建唯一的数组值 示例6.64和6.65给出了更一般的解决方案。例如，您可能需要为N个总线驱动器分配ID号，它们的范围是0到MAX-1，其中MAX >=N。 示例6.64惟一值生成器 样例6.65类生成一个惟一值的随机数组 示例6.66有一个程序。下面是一个使用UniqueArray的程序 类。 示例6.66使用UniqueArray类 6.13.6 将句柄数组随机化 如果需要创建多个随机对象，可以创建一个句柄的随机数组。与整数数组不同，您需要在随机化之前分配所有元素，因为随机解算器永远不会构造对象。如果你有一个动态数组，分配你可能需要的最大数量的元素，然后使用一个约束来调整数组的大小，如示例6.67所示。在随机化过程中，句柄的动态数组可以保持相同的大小或缩小，但它的大小永远不会增加。 样例6.67构造随机数组类中的元素 以上代码适用于单个数组随机化。如果需要反复随机化同一个数组，那么分配数组并在pre_randomize中构造元素。有关句柄数组的更多信息，请参阅5.14.4节。 6.14. 原子刺激生成vs.场景生成 到目前为止，您已经看到了原子随机事务。您已经学习了如何进行单个随机总线事务、单个网络数据包或单个处理器指令。这是一个良好的开始，但是您的工作是验证设计是否有效 与现实世界的刺激。总线可能有很长的事务序列，如DMA传输或缓存填充。当您同时阅读电子邮件、浏览网页和从网上下载音乐时，网络流量由扩展的数据包序列组成，所有这些都是并行的。处理器有很深的管道，其中充满了用于例程调用、for循环和中断处理程序的代码。一次生成一个事务不太可能模拟这些场景。 6.14.1 一个有历史的原子发电机 创建相关事务流的最简单方法是让原子生成器基于以前事务的一些随机值。该类可以约束总线事务在80%的时间里重复前面的命令(比如写)，还可以使用前面的目标地址加上增量。可以使用post_randomize函数复制生成的事务，以便下次调用randomize时使用。 这种方案在较小的情况下工作得很好，但当您需要提前了解整个序列的信息时，就会遇到麻烦。DUT在开始之前可能需要知道网络事务序列的长度。 6.14.2 对象随机数组 如果你想为一个复杂的、多层次的协议产生刺激，你可以建立一个代码和随机对象数组的组合。UVM和VMM都允许您通过一组复杂的类和宏生成随机序列。本节展示了一个简化的随机序列。 生成随机序列的一种方法是随机化整个对象数组。您可以创建引用数组中上一个和下一个对象的约束，并且SystemVerilog求解器同时解决所有约束。由于整个序列是一次生成的，因此您可以在发送第一个事务之前提取诸如事务总数或所有数据值的校验和之类的信息。或者，您可以为DMA传输构建一个严格限制为1024字节的序列，并让求解器选择正确的事务数量来达到这个目标。 示例6.68显示了一个简单的事务序列，每个事务的目标地址都大于前一个事务。它建立在示例6.61中所示的数组约束之上。 示例6.68带有升序值的简单随机序列 6.14.3 结合序列 您可以将多个序列组合在一起，以形成更真实的事务流。例如，对于网络设备，您可以制作一个类似于下载电子邮件的序列，第二个类似于查看web页面，第三个类似于在基于web的表单中输入单个字符。组合这些流的技术超出了本书的范围，但是您可以从VMM中了解更多，如Bergeron等人(2005)所述。 6.14.4 Randsequence 您可能会发现编写随机约束很有挑战性，因为它们不像过程语句那样按顺序执行。创建随机序列的另一种方法是使用声明式风格描述协议语法，使用类似于BNF (Backus-Naur形式)和随机加权case语句的语法。 SystemVerilog的randsequence构造类似于您传统上使用的算法代码，但仍然具有挑战性。 样例6.69生成一个名为stream的序列。流可以是cfg_ read、io_read或mem_read。随机序列引擎随机选择一个。cfg_read标签的权重为1,io_read的权重是cfg_read的两倍，因此被选中的可能性是cfg_read的两倍。标签mem_read最有可能被选中，其权重为5。 示例6.69命令生成器使用randsequence cfg_read可以是对cfg_read_task的单个调用，也可以是对任务的调用，后面跟着另一个cfg_read。因此，该任务总是至少被调用一次，也可能被调用多次。 randsequence的一大优点是它是过程代码，您可以通过逐步执行或添加$display语句来调试它。当您为一个对象调用randomize时，它要么全部工作，要么全部失败，但您无法看到获得结果所采取的步骤。 使用randsequence有几个问题。生成序列的代码是独立的，与序列使用的带有数据和约束的类风格非常不同。因此，如果你同时使用randomize和randsequence，你就必须掌握两种不同的随机化形式。更严重的是，如果您想要修改一个序列，也许是添加一个新的分支或操作，您必须修改原始的序列代码。你不能只是打个分机。正如您将在第8章中看到的，您可以扩展一个类来添加新的代码、数据和约束，而不必编辑原来的类。 6.15. 随机控制 此时，你可能会认为这个过程是为你的设计创造一长串随机输入的好方法。或者，如果您想要做的只是偶尔在代码中做出随机决定，那么您可能会认为这是一项工作量很大的工作。您可能更喜欢使用一组可以使用调试器逐步执行的过程语句。 介绍randcase 您可以使用randcase在几个操作之间进行加权选择，而不必创建类和实例。示例6.70根据权重选择三个分支中的一个。SystemVerilog将权重相加(1+8+1 = 10)，在这个范围内选择一个值，然后选择适当的分支。这些分支不依赖于顺序，权重可以是变量，它们的总和不必达到100%。函数$urandom_range在第6.10节中描述。 示例6.70随机控制与randcase和$urandom_range 您可以使用一个类和randomize函数编写示例6.70。对于这个小例子，示例6.71中的OOP版本要大一些。但是，如果这是一个更大的类的一部分，那么约束将比等效的randcase语句更紧凑。 示例6.71等效约束类 使用randcase的代码比随机约束更难覆盖和修改。修改随机结果的唯一方法是重写代码或使用可变权重。 使用randcase时要小心，因为它不会留下任何痕迹。例如，您可以使用它来决定是否在事务中注入错误。问题是下游的事务处理程序和记分牌需要知道这个选择。通知他们的最好方法是在事务或环境中使用变量。但是，如果您要创建一个变量，它是这些类的一部分，那么您可以使它成为一个随机变量，并使用约束在不同的测试中更改它的行为。 用randcase构建决策树 您可以使用randcase语句来创建决策树。样例6.72只有两层过程代码，但是您可以看到如何扩展它以使用更多的过程代码。 示例6.72使用randcase创建决策树 6.16. 随机数生成器 SystemVerilog有多随机?一方面，你的测试平台依赖于不相关的随机值流来创建超出任何定向测试的刺激模式。另一方面，您需要在特定测试的调试过程中反复重复这些模式，即使设计和测试工作台只做了很小的更改。 6.16.1 伪随机数生成器 Verilog使用一个简单的PRNG，您可以通过$random函数访问它。生成器有一个内部状态，您可以通过向$random提供种子来设置它。所有兼容ieee -1364的Verilog模拟器都使用相同的算法来计算值。 示例6.73显示了一个简单的PRNG，而不是SystemVerilog使用的PRNG。PRNG的状态为32位。要计算下一个随机值，将状态平方生成一个64位值，取中间的32位，然后加上原始值。 示例6.73简单伪随机数生成器 您可以看到，这段简单的代码是如何生成看似随机的值流的，但是可以通过使用相同的种子值来重复。SystemVerilog调用自己的PRNG来为randomize和randcase生成一个新值。 6.16.2 随机稳定性-多个发电机 Verilog有一个用于整个模拟的PRNG。如果SystemVerilog保持这种方法会发生什么?测试台上通常有几个刺激发生器并行运行，为被测试的设计创建数据。如果两个流共享相同的PRNG，它们每个都得到随机值的子集。 图6.3共享单个随机生成器 在图6.3中，有两个刺激发生器和一个PRNG产生值a、b、c等。Gen2有两个随机对象，因此在每个周期中，它使用的随机值是Gen1的两倍。 如图6.4所示，当其中一个类发生变化时，可能会出现问题。Gen1获得一个额外的随机变量，因此每次调用它时都会消耗两个随机值。这种方法不仅会更改第1代使用的值，还会更改第2代使用的值。 图6.4第一个发电机使用附加值 在SystemVerilog中，每个对象和线程都有一个单独的PRNG。图6.5显示了一个对象的变化如何不会影响其他对象看到的随机值。 图6.5每个对象独立的随机生成器 6.16.3 随机稳定性和分层播种 在SystemVerilog中，每个对象和线程都有自己的PRNG和唯一的种子。当一个新的对象或线程启动时，它的PRNG将从它的父对象或线程的PRNG中进行播种。因此，在模拟开始时指定的单个种子可以产生许多不同的随机刺激流。 在调试测试平台时，可以添加、删除和移动代码。即使具有随机稳定性，您的更改也可能导致testbench生成不同的随机dom值。如果您正在调试一个DUT故障，而testbench不再创建相同的刺激，那么这可能会非常令人沮丧。您可以通过在现有对象或线程之后添加任何新对象或线程来最小化代码修改的影响。样例6.74显示了一个来自testbench的例程，它构造了对象，并在并行线程中运行它们。 样例6.74修改前测试代码 样例6.75添加了一个新的生成器，并在一个新的线程中运行它。新对象是在现有对象之后构造的，新线程是在旧线程之后生成的。 示例6.75修改后的测试代码 随着新代码的添加，您可能无法保持随机流与旧流相同，但您可能能够推迟这些更改带来的任何副作用。 6.17. 随机设备配置 测试DUT的一个重要部分是内部DUT设置和围绕它的系统的配置。如第6.2.1节所述，您的测试应该随机化环境，这样您就可以确信它已经在尽可能多的模式下进行了测试。 样例6.76显示了一个可以在测试级别上根据需要修改的随机测试工作台配置。EthCfg类描述了4端口以太网交换机的配置。它在一个环境类中实例化，这个环境类反过来在测试中使用。测试覆盖其中一个配置值，启用所有4个端口。 示例6.76以太网交换机配置类 configuration类在环境类的几个阶段中使用。配置是在环境构造函数中构造的，但在gen_cfg阶段(如示例6.77所示)之前不是随机的。这允许您在调用randomize之前打开和关闭约束。然后，您可以在构建阶段围绕DUT创建虚拟组件之前覆盖生成的值。(EthGen和EthMii等类没有显示)。 样本6.77随机配置的建筑环境 现在您已经拥有了构建测试所需的所有组件，该测试在程序块中进行了描述。样例6.78中的测试实例化了环境类，然后运行每一步。 示例6.78使用随机配置的简单测试 您可能想要覆盖随机配置，可能是为了达到某个特殊情况。样例6.79中的测试将配置类随机化，然后启用所有端口。 示例6.79覆盖随机配置的简单测试 请注意，在示例6.77中，所有生成器都构造好了，但只运行了少数几个，这取决于随机配置。如果您只构造了正在使用的生成器，那么您必须使用in_ use [i]测试来包围对gen [i]的任何引用，否则您的测试平台在尝试使用时将会崩溃 参考不存在的生成器。这些生成器占用的额外内存对于一个更稳定的测试平台来说只是一个小代价。 6.18. 结论 约束随机测试是产生验证复杂设计所需刺激的唯一可行方法。SystemVerilog提供了许多创建随机刺激的方法，本章提供了许多替代方法。 测试需要灵活，允许您使用默认生成的值，或者约束或覆盖这些值，以便您能够达到目标。在创建您的测试平台时，总是预先计划，留下足够的“挂钩”，这样您就可以在不修改现有代码的情况下从测试中控制测试平台。 6.19. 练习 为以下项目编写SystemVerilog代码。 创建一个类Exercise1，包含两个随机变量，8位数据和4位地址。创建一个约束块，将address保持为3或4。 在初始块中，构造一个Exercise1对象并将其随机化。检查随机化的状态。 修改练习1的解决方案，创建一个新的类Exercise2，以便: data总是等于5 地址==0的概率为10% 地址在[1:14]之间的概率是80% 地址==15的概率是10% 使用练习1或练习2的解决方案，通过生成20个新数据和地址值来演示其用法，并检查约束求解器是否成功。 创建一个将Exercise2类随机化1000次的测试平台。 计算每个地址值出现的次数，并在直方图中打印结果。你是否看到了10% / 80% / 10%的确切分布?为什么或为什么不? 用3个不同的随机种子运行模拟，创建直方图，然后对结果进行评论。下面是如何使用seed 42运行模拟。 VCS: > simv +ntb_random_seed=42 IUS: > irun exercise4。sv−svseed 42 Questa: > vsim−sv_seed 42 对于样例6.4中的代码，请描述len、dst和src的约束 变量。 请按以下约束填写表6.9。 表6.9解概率 解决方案xy概率一个00B01C02D03.E10F11G12H13. 对于下面的类，create: 一个限制读取事务地址范围为0到7(包括0到7)的约束。 编写行为代码来关闭上述约束。使用内联约束构造并运行MemTrans对象，该约束将读事务操作地址限制在0到8(包括0到8)范围内。测试内联约束是否有效。 为10x10像素的图形图像创建一个类。每个像素的值可以随机化为黑色或白色。随机生成一张平均20%的白色图像。打印图像并报告每种类型的像素数。 创建一个类StimData，包含一个整数样本数组。随机化数组的大小和内容，将大小限制在1到1000之间。通过生成20个事务并报告大小来测试约束。 展开下面的事务类，使相同类型的背靠背事务没有相同的地址。通过生成20个事务来测试约束。 展开下面的RandTransaction类，使相同类型的背靠背事务没有相同的地址。通过生成20个事务来测试约束。 "},"articles/chapter-07.html":{"url":"articles/chapter-07.html","title":"第七章　　线程和进程间通信","keywords":"","body":"第7章线程和进程间通信 在实际硬件中，时序逻辑在时钟边缘被激活，而组合逻辑则在任何输入变化时不断变化。所有这些并行活动都在Verilog RTL中使用initial和always块，以及偶尔的gate和连续赋值语句进行模拟。为了刺激和检查这些块，您的测试平台使用许多执行线程，所有线程都并行运行。testbench环境中的大多数块都使用事务处理程序建模，并在它们自己的线程中运行。 SystemVerilog调度程序是选择接下来运行哪个线程的交通警察。您可以使用本章中的技术来控制线程，从而控制您的测试平台。 这些线程中的每一个都与它的邻居通信。在图7.1中，发电机将刺激传递给agent。environment类需要知道生成器何时完成，然后告诉其余的testbench线程终止。这是通过进程间通信(IPC)构造完成的，比如标准的Verilog事件、事件控制和等待语句，以及SystemVerilog邮箱和信号量 SystemVerilog LRM可以互换使用“线程”和“进程”。术语“进程”通常与Unix进程联系在一起，每个进程都包含一个在自己的内存空间中运行的程序。线程是轻量级进程，可以共享公共代码和内存，并且比典型进程消耗的资源少得多。这本书使用了“线程”这个术语。然而，“进程间通信”是一个如此常见的术语，以至于在本书中使用了它。 图7.1测试台环境块 7.1. 处理线程 虽然所有的线程结构都可以在模块和程序块中使用，但是testbench属于程序块。因此，代码总是从时间为0时开始执行的初始块开始。不能在程序中放入always块。然而，您可以通过在初始块中使用永久循环轻松地解决这个问题。 经典的Verilog有两种对语句进行分组的方法——使用begin…end或fork…join。begin…end语句是顺序运行的，而fork…join语句是并行执行的。后者的限制非常有限，因为fork…join中的所有语句必须在块的其余部分继续之前完成。因此，Verilog testbench很少使用这个特性。 SystemVerilog引入了两种新的创建线程的方法——fork…join_none和fork…join_any语句，如图7.2所示。 图7.2分叉…连接块 testbench使用事件、@事件控制、等待和禁用状态等现有结构，以及信号量和邮箱等新语言元素来通信、同步和控制这些线程。 使用fork…join and begin…end 样例7.1有一个fork…join并行块和一个封闭的begin…end顺序块，并显示了两者的区别。 示例7.1 begin…end和fork…join的交互 父 子线程 图7.3叉…连接块 在下面的输出中，fork…join中的代码是并行执行的，因此延迟时间较短的语句会在延迟时间较长的语句之前执行。正如示例7.2中所示，fork…join在最后一条语句(以#50开头)之后完成。 示例7.2 begin…end和fork…join的输出 使用fork生成线程…join_none 一个fork…join_none块会调度该块中的每一条语句，但会在父线程中继续执行。样例7.3与样例7.1相同，不同之处是连接被转换为join_none。 样例7.3 Fork…join_none代码 这个框图类似于图7.3。注意，样例7.4中join_none块后面的语句在fork…join_none内的任何语句之前执行。 示例7.4 Fork…join_none输出 使用fork…join_any来同步线程 join_any块调度该块中的每一条语句。然后，当第一个语句完成时，在父线程中继续执行。所有其他保留线程继续。样例7.5与前面的示例相同，只是连接被转换为join_any。 示例7.5 Fork…join_any代码 注意，在示例7.6中，语句$display(\" after join_any \")在并行块中的第一条语句之后完成。 示例7.6 fork…join_any的输出 7.1.1 在类中创建线程 你可以使用fork…join_none来启动一个线程，比如随机事务处理生成器的代码。示例7.7显示了一个带有运行任务的生成器/驱动程序类，该任务创建了N个包。完整的测试工作台为驱动程序、监视器、检查器等提供了类，所有这些类都带有需要并行运行的事务处理。 示例7.7带有运行任务的生成器/驱动程序类 对于示例7.7有几点需要注意。首先，在new()函数中没有启动trans- actor。构造函数应该只是初始化值，而不是启动任何线程。将构造函数与执行实际工作的代码分离，允许您在开始执行对象中的代码之前更改任何变量。 这允许你注入错误、修改默认值和改变对象的行为。接下来，run任务在fork…join_none块中启动一个线程。线程是事务处理程序的一部分，应该在那里生成，而不是在父类中。 7.1.2 动态线程 Verilog的线程是非常可预测的。你可以阅读源代码并计算初始化，always和fork…join块，以知道一个模块中有多少线程。另一方面，SystemVerilog允许动态创建线程，并且不需要等待线程完成。 在样例7.8中，testbench生成随机事务并将它们发送到DUT, DUT将它们存储一段预定的时间，然后返回它们。testbench必须等待事务完成，但不希望停止生成器。 样例7.8动态线程创建 当调用check_trans任务时，它会生成一个线程来监视总线以获取匹配的事务数据。在正常的模拟过程中，许多线程并发运行。在这个简单的示例中，线程只打印一条消息，但是您可以添加更复杂的控件。 7.1.3 线程中的自动变量 当有一个生成线程的循环，而在下一次迭代之前没有保存变量值时，就会出现一个常见但微妙的错误。样例7.8只在带有自动存储器的程序或模块中工作。如果check_trans使用静态存储，那么每个线程都将共享相同的变量tr，以便以后调用 将覆盖以前设置的值。同样地，如果示例在repeat循环中有fork…join_none，它将尝试使用tr来匹配传入的事务，但它的值将在下一次循环中改变。总是使用自动变量在并发线程中保存值。 示例7.9在for循环中有一个fork…join_none。SystemVerilog在fork…join_none中调度线程，但它们直到原始代码块之后才会执行，这是因为#0延迟。因此，示例7.9打印“3 3 3”，这是循环结束时索引变量j的值。 示例7.9 Bad fork…join_none within a loop 示例7.10在循环中执行bad fork…join_none #0延迟阻塞当前线程，并重新安排它在当前时隙中稍后启动。在示例7.10中，延迟使得当前线程在fork…join_none语句中产生的线程之后运行。这种延迟对于阻塞线程很有用，但您应该小心，因为过度使用会导致竞争条件和意外的结果。 你应该在fork…join语句中使用自动变量来保存一个变量的副本，如示例7.11所示。 示例7.11 fork中的自动变量…join_none join_none块被分成两部分，声明和过程代码。带有初始化的自动变量声明运行在for循环中的线程中。在每个循环中,创建一个副本k和j的当前值。然后叉的身体…join_none(写)美元计划,包括k的副本。循环完成后,## 7.0阻塞当前线程,所以三个线程运行,印刷复制的价值的k。当线程完成,和其他没有离开在当前时间段,SystemVerilog进展到下一个语句和美元显示执行。 样例7.12跟踪样例7.11中的代码和变量。自动变量k的三个副本称为k0、k1和k2。 执行自动变量代码的步骤示例7.12 编写样例7.11的另一种方法是在fork…join_none之外声明自动变量。示例7.13工作在一个带有自动存储功能的程序中。 示例7.13 fork中的自动变量…join_none 7.1.4 等待所有产生的线程 在SystemVerilog中，当程序中的所有初始块都完成后，模拟程序就会退出。样例7.14展示了如何生成许多仍在运行的线程。使用wait fork语句等待所有子线程。 使用wait fork来等待子线程 7.1.5 跨线程共享变量 在类的例程中，可以使用局部变量、类变量或程序中定义的变量。如果忘记声明变量，SystemVerilog会查找更高的作用域，直到找到匹配的为止。如果代码的两部分是这样的话，这可能会导致微妙的错误 无意中共享同一个变量，可能是因为您忘记在最内层作用域中声明它。 例如，如果您喜欢使用索引变量i，请注意，testbench的两个不同线程不会同时在For循环中使用这个变量。或者您可能忘记在类中声明一个局部变量，如Buggy，如下所示。如果你的程序块声明了一个全局i，那么这个类只使用全局i而不是你想要的局部i。除非程序的两个部分试图同时修改共享变量，否则您甚至可能不会注意到这一点。 使用共享程序变量的错误 解决方案是在包含变量所有使用的最小作用域中声明所有变量。在样例7.15中，在for循环中声明索引变量，而不是在程序或类级别声明。更好的是，尽可能使用foreach语句。 7.2. 禁用线程 正如您需要在testbench中创建线程一样，您也需要停止它们。Verilog disable语句适用于SystemVerilog线程。下面的部分将展示如何异步禁用线程。这可能会导致意想不到的行为，因此您应该注意在线程中途停止时的副作用。相反，您可能希望将算法设计为在稳定点检查中断，然后优雅地放弃其资源。 7.2.1 禁用单个线程 下面是check_trans任务，这一次使用fork…join_any加上disable来创建一个超时的手表。在本例中，您正在禁用一个标记块，以精确地指定要停止的内容。 最外层的fork…join_none与样本7.8相同。这个版本在fork…join_any中实现了两个线程的超时，这样简单的wait语句就会与延迟的$display并行执行。如果正确的总线数据以足够快的速度返回，则等待构造完成，执行join_any，然后禁用将终止剩余的线程。但是，如果总线数据在timeout延迟完成之前没有得到正确的值，则会打印错误消息，执行join_any，而disable则通过wait终止线程。 示例7.16禁用线程 要注意，因为您可能无意中停止了太多带有disable标签的线程。如果有多个驱动程序或监视器对象同时运行，则该语句会停止执行该标记块的每个进程。如果你的代码只有一个实例，禁用标签是一个安全的方法来停止线程。 7.2.2 禁用多个线程 示例7.16使用了经典的Verilog disable语句来停止命名块中的线程。SystemVerilog引入了disable fork语句，这样您就可以停止从当前线程派生的所有子线程。 要注意，因为您可能会无意中停止使用disable fork的太多线程，比如从周围的任务调用创建的线程。您应该始终使用fork…join将目标代码包围起来，以限制禁用fork语句的范围。 接下来的几个示例使用示例7.16中的check_trans任务。您可以将此任务视为执行#TIME_OUT。样例7.17在fork…join中有一个额外的begin…end块，使语句顺序执行。 示例7.17限制禁用fork的范围 图7.4显示了衍生线程的示意图。 初始化begin check_trans(tr0) fork … 加入结束 图7.4叉…连接方框图 线程1 check_trans(tr1) fork … 加入## 7.TIME_OUT / 2 禁用叉 代码调用启动线程0的check_trans。接下来一个fork…join创建线程1。在这个线程中，一个由check_trans任务生成，另一个由最内层的fork…join生成，fork…join通过调用任务生成线程4。延迟之后，一个禁用的fork停止，所有的子线程2-4。线程0在fork…join块之外，所以它不受影响。 样例7.18是样例7.17的更健壮版本，其中disable带有一个标签，该标签显式地指定要停止的线程。 示例7.18使用disable label停止线程 7.2.3 禁用多次调用的任务 当你在一个块里面禁用一个块的时候要小心——你可能会停止的比你预期的要多。正如预期的那样，如果您在任务内部禁用一个任务，它就像一个return语句，但它也会杀死由该任务启动的所有线程。此外，一个禁用标签将使用该代码终止所有线程，而不仅仅是当前线程。 在示例7.19中，wait_for_time_out任务被调用了三次，产生了三个线程。然后，线程0也会禁用#2ns之后的任务。当您运行这段代码时，您将看到三个线程开始运行，但是没有一个线程结束，因为线程0中的禁用将停止所有三个线程，而不仅仅是一个线程。如果这个任务在一个被实例化多次的驱动程序类中，一个disable标签可以停止所有的块。 样例7.19使用禁用标签停止任务 7.3. 进程间通信 测试台上的所有这些线程都需要同步和交换数据。在最基本的级别上，一个线程等待另一个线程，例如环境对象等待生成器完成。多个线程可能尝试访问单个资源，比如DUT中的总线，因此testbench需要确保一个且只有一个线程被授予访问权。在最高级别上，线程需要交换数据，比如从生成器传递到代理的事务对象。所有这些数据交换和控制同步称为进程间通信(IPC)，它在SystemVerilog中通过事件、信号量和邮箱实现。这些将在本章的其余部分进行描述。 IPC通常有三个部分:创建信息的生产者、接受信息的消费者和携带信息的通道。生产者和消费者在单独的线程中。 7.4. 事件 Verilog事件同步线程。它类似于电话，一个人等待另一个人的电话。在Verilog中，线程等待带有@操作符的事件。这个操作符是边缘敏感的，所以它总是阻塞，等待事件改变。另一个线程用->操作符触发事件，解除第一个线程的阻塞。 System Verilog在几个方面增强了Verilog事件。事件现在是可以传递给例程的同步对象的句柄。这个特性允许您跨对象共享事件，而不必将事件设置为全局的。最常见的方法是将事件传递到对象的构造函数中。 在Verilog中总是存在竞争条件的可能性，即一个线程阻塞一个事件，同时另一个线程触发该事件。如果触发线程exe-在阻塞线程之前终止，则会错过触发器。SystemVerilog引入了触发状态，允许您检查事件是否被触发，包括在当前时间段内触发。线程可以等待这个函数，而不是用@操作符阻塞。 7.4.1 事件边缘的阻塞 当运行样例7.20时，一个初始块启动，触发它的事件，然后阻塞另一个事件，如样例7.21的输出所示。第二个块开始，触发它的事件(唤醒第一个)，然后阻塞第一个事件。然而，第二个线程因为错过了第一个事件而被锁定，因为它是一个零宽度的脉冲。 示例7.20在Verilog中阻塞事件 示例7.21阻塞事件的输出 7.4.2 等待事件触发器 而不是边缘敏感块@e1，使用级别敏感的等待(e1。三角-基尔)。如果在此时间步骤中触发了事件，则不会阻塞。否则，它将等待直到事件被触发。 示例7.22等待事件 当您运行示例7.22时，一个初始块启动，触发它的事件，然后阻塞另一个事件。第二个块启动，触发它的事件(唤醒第一个事件)，然后阻塞第一个事件，产生示例7.23中的输出。 示例7.23等待事件的输出 其中一些示例具有竞争条件，可能在每个模拟器上执行的结果都不完全相同。例如，示例7.23中的输出假设当第二个块触发e2时，执行跳转回第一个块。第二个块触发e2、等待e1并在控制返回到第一个块之前显示消息也是合法的。 7.4.3 循环中使用事件 可以用一个事件同步两个线程，但要谨慎使用。 如果你在循环中使用wait (handshake.triggered)，请确保在再次等待之前提前时间。否则，当等待在单个事件触发器上一遍又一遍地继续时，代码将进入零延迟循环。示例7.24错误地使用了a 级别敏感的阻塞语句，用于通知事务已就绪。 示例7.24等待事件导致零延迟循环 正如您学习了总是在always块中放置延迟一样，您也需要在事务处理循环中放置延迟。样本中的边缘敏感延迟语句 7.25每个事件触发器只持续一次。 示例7.25等待事件的边缘 如果需要在一个时间段内发送多个通知，则应该避免事件，并查看其他内置队列的IPC方法，如信号量和邮箱，本章后面将讨论这些方法。 7.4.4 通过事件 如上所述，SystemVerilog中的事件可以作为参数传递给例程。在示例7.26中，事务处理程序使用事件来在事件完成时发出信号。 样例7.26向构造函数传递事件 7.4.5 等待多个事件 在示例7.26中，有一个触发单个事件的单个生成器。如果您的testbench环境类必须等待多个子进程(比如N个生成器)完成，该怎么办?最简单的方法是使用wait fork，它等待所有子进程结束。问题是，这还需要等待所有事务处理程序、驱动程序和由环境生成的任何其他线程。你需要更有选择性。您仍然希望使用事件在父线程和子线程之间进行同步。 您可以在父线程中使用for循环来等待每个事件，但只有当线程0在线程1之前结束，线程1在线程2之前结束，等等，这才会起作用。如果线程按顺序完成，那么您可能正在等待触发多个周期的事件。 解决方案是创建一个新线程，然后在那里为每个生成器的每个事件上的每个块生成子线程，如示例7.27所示。现在你可以做一个等待叉，因为你更有选择性了。 示例7.27使用wait fork等待多个线程 解决这个问题的另一种方法是跟踪已经触发的事件的数量，如示例7.28所示。 示例7.28通过计数触发器等待多个线程 这个稍微没那么复杂。为什么不删除所有事件，只是等待正在运行的生成器的数量?这个计数可以是一个静态变量 在Generator类中。注意，大多数线程操作代码已经被单个wait构造所取代。示例7.29中的最后一个块使用类作用域解析操作符::等待计数。您可以使用任何句柄，如gen[0]，但那将不那么直接。 示例7.29使用线程计数等待多个线程 7.5 信号量 信号量允许你控制对资源的访问。想象一下，你和你的配偶共用一辆车。很明显，一次只能有一个人驾驶。你可以通过同意谁有钥匙谁就能驾驶来处理这种情况。当你用完车后，你把车让给别人用。关键是确保只有一个人能进入汽车的信号量。在操作 系统术语中，这被称为“互斥访问”，因此信号量被称为“互斥”，并用于控制对资源的访问。 信号量可以在测试台上使用，当你有一个资源，比如总线，可能有多个来自测试台上的请求者，但是作为物理设计的一部分，只能有一个驱动程序。在SystemVerilog中，当一个键不可用时，请求一个键的线程总是会阻塞。多个阻塞线程按FIFO顺序排队。 7.5.1 信号量操作 信号量有三种基本操作。您可以使用新方法创建一个具有一个或多个键的信号量，使用阻塞任务get()获取一个或多个键，并使用put()返回一个或多个键。如果您想尝试获取一个信号量，而不是块，请使用try_get()函数。如果键是可用的，try_get()获取键并返回1。如果没有足够的键，它只返回0。样本 7.30展示了如何使用信号量控制对资源的访问。 样例7.30信号量控制对硬件资源的访问 7.5.2 具有多个键的信号量 对于信号量，有两点需要注意。首先，你可以放回比你拿走的更多的钥匙。突然，你可能有两把钥匙，但只有一辆车!其次，如果您的testbench需要获取和放置多个键，请小心。也许您还剩一个键，而线程请求了两个键，导致它阻塞。现在第二个线程请求一个信号量-应该发生什么?在SystemVerilog中，第二个请求get(1)比之前的get(2)提前，绕过了FIFO顺序。如果您混合不同大小的请求，您总是可以编写自己的类。 这样你就能清楚地知道谁优先。 7.6. 邮箱 如何在两个线程之间传递信息?也许您的生成器需要创建许多事务并将它们传递给驱动程序。您可能想让生成器线程调用驱动程序中的一个任务。如果您这样做，生成器需要知道驱动任务的层次路径，使您的代码更少的可重用性。此外，这种样式强制生成器以与驱动程序相同的速度运行，如果一个生成器需要控制多个驱动程序，这可能会导致同步问题。 可以将生成器和驱动程序视为事务处理程序，它们是通过通道进行通信的自治对象。每个对象从上游对象获得一个事务操作(或像生成器那样创建事务操作)，进行一些处理，然后将其传递给下游对象。通道必须允许它的驱动程序和接收器异步操作 实现。您可能很想只使用共享数组或队列，但安全地创建读、写和阻塞的线程可能比较困难。 解决方案是SystemVerilog邮箱。从硬件的角度来看，考虑邮箱最简单的方法是，它只是一个FIFO，具有源和接收器。源将数据放入邮箱，接收从邮箱获取值。邮箱可以有最大大小，也可以无限制。当源线程试图将值放入已满的大小邮箱时，该线程会阻塞，直到该值被删除。同样，如果接收线程试图从为空的邮箱中删除一个值，那么该线程将阻塞，直到将一个值放入邮箱。 图7.5显示了连接生成器和驱动程序的邮箱。 邮箱 图7.5连接两个办理的邮箱 邮箱是一个对象，因此必须通过调用new函数来实例化。它接受一个可选的size参数，以限制邮箱中的条目数量。如果大小为0或未指定，则邮箱是无界的，可以容纳无限数量的条目。 您可以通过put()任务将数据放入邮箱，然后通过阻塞的get()任务将数据删除。如果邮箱已满，则put()将阻塞，如果邮箱为空，则get()将阻塞。如果想查看邮箱是否已满，请使用try_put()。和try_get()查看是否为空。peek()任务获取邮箱中的数据副本，但不删除它。 数据是单个值，例如整数，或任意大小的逻辑或句柄。邮箱从不包含对象，只包含对对象的引用。默认情况下，邮箱没有类型，因此可以将任何数据混合放入其中。不要这样做!通过使用示例中所示的参数化邮箱，强制每个邮箱使用一种数据类型 7.31在编译时捕获类型不匹配。 示例7.31邮箱声明 示例7.32中所示的一个典型邮箱错误是一个循环，该循环将对象运行到一个邮箱中，但对象只在循环之外构造一次。因为只有一个对象，所以它被反复随机化。 示例7.32坏生成器只创建一个对象 图7.6显示了指向单个对象的所有句柄。邮箱只包含句柄，而不包含对象，因此最终会得到一个包含多个句柄的邮箱，这些句柄都指向单个对象。从邮箱获取句柄的代码只看到最后一组随机值。 图7.6对一个对象使用多个手柄的邮箱 示例7.33所示的解决方案是确保您的循环具有构造对象、随机化对象和将其放入邮箱的所有三个步骤。这个bug非常常见，在5.14.3节中也提到过。 Good generator创建了许多对象 结果如图7.7所示，每个手柄都指向一个唯一的对象。这种类型的生成器称为蓝图模式，在8.2节中进行了描述。 图7.7一个对多个对象具有多个把手的邮箱 示例7.34显示了等待来自生成器的事务的驱动程序。 示例7.34好的驱动程序从邮箱接收事务 如果您不希望代码在访问邮箱时阻塞，可以使用try_ get()和try_peek()函数。如果成功，则返回一个非零值;否则，它们返回0。它们比num()函数更可靠，因为条目的数量在测量时和下次访问邮箱时之间可能会发生变化。 7.6.1 测试台上的邮箱 示例7.35展示了一个带有生成器和驱动程序的程序，它们使用邮箱交换事务。 示例7.35使用邮箱交换对象:Generator类 7.6.2 有界的邮箱 默认情况下，邮箱类似于无限制的FIFO——生产者可以在使用者取出对象之前将任意数量的对象放入邮箱。但是，您可能希望这两个线程同步操作，这样生产者就会阻塞，直到消费者处理完对象。 您可以在构造邮箱时指定其最大大小。默认邮箱大小为0，这将创建一个无界邮箱。任何大于0的大小都将创建一个有界邮箱。如果试图放置超过此限制的对象，则put()将阻塞，直到从邮箱中获得对象，从而创建一个空位。 示例7.36绑定邮箱 样例7.36创建可能的最小邮箱，该邮箱可以容纳一条消息。生产者线程尝试将三条消息(整数)放入邮箱，而消费者线程缓慢地每1ns获取一条消息。正如示例7.37所示，第一个put()成功，然后生产者尝试阻塞的put(2)。消费者醒来，从邮箱中获得消息1，所以现在生产者可以完成消息2的放置。 示例7.37有界邮箱的输出 有界邮箱充当两个进程之间的缓冲区。您可以看到生产者如何在消费者读取当前值之前生成下一个值。 7.6.3 与邮箱通信的非同步线程 在许多情况下，由邮箱连接的两个线程应该同步运行，这样生产者就不会领先于使用者。这种方法的好处是，您的整个刺激逻辑单元生成链现在都是同步运行的。只有当最后一个低级别事务完成传输时，最高级别的生成器才能完成。现在，你的测试平台可以准确地判断出所有刺激在什么时候发生了变化 被发送。在另一个示例中，如果您的生成器领先于驱动程序，并且您正在收集生成器的功能覆盖率，那么您可能会记录某些事务已被测试，即使测试过早地停止了。因此，即使邮箱允许您将两者解耦，您可能仍然希望保持它们同步。 如果希望两个线程同步运行，除了邮箱之外，还需要握手。在示例7.38中，生产者和消费者现在是交换的类 使用邮箱的整数，两个对象之间没有显式的同步。结果，如示例7.39所示，生产者甚至在消费者开始之前就运行到完成。 示例7.38不同步的生产者-消费者 上面的示例将邮箱保存在一个全局变量中，以使代码更紧凑。在实际代码中，应该通过构造函数将邮箱传递到类中，并在类级变量中保存对邮箱的引用。 样例7.38没有同步，因此生产者在消费者获得第一个整数之前将所有三个整数放入邮箱。这是因为线程会一直运行，直到出现阻塞语句，而生产者没有阻塞语句。消费者线程在第一次调用mbx.get时阻塞。 示例7.39没有同步输出的生产者-消费者 这个例子有一个竞争条件，因此在某些模拟器上，消费者可以更早地激活。结果仍然是相同的价值是由生产者决定的，而不是由消费者多快看到它们。 7.6.4 使用绑定邮箱和窥视的同步线程 在同步的测试台中，生产者和消费者以同步的步骤操作。这样，您就可以通过等待任何线程来判断输入刺激何时完成。如果线程的操作是不同步的，则需要添加额外的代码来检测最后一个事务何时应用到DUT。 为了同步两个线程，生产者创建一个事务并将其放入邮箱中，然后阻塞，直到消费者完成该事务。这是通过让使用者仅在最终完成事务处理时(而不是在第一次检测到事务时)从邮箱中删除事务来实现的。 样例7.40展示了同步两个线程的第一次尝试，这次使用一个绑定邮箱。使用者使用内置邮箱方法peek()查看邮箱中的数据，而不删除数据。当消费者完成数据处理后，它使用get()删除数据。这就释放了生产者来产生新的价值。如果消费者循环以get()而不是peek()开始，事务将立即从邮箱中删除，这样生产者就可以在消费者完成事务之前醒来。示例7.41给出了这段代码的输出。 与绑定邮箱同步的生产者-消费者示例7.40 示例7.41带有有限邮箱的生产者-消费者输出 您可以看到生产者和消费者步调一致，但是生产者仍然在消费者前面一个事务。这是因为当您尝试执行第二个事务的put时，size=1的有界邮箱只会阻塞 2此行为与VMM通道不同。如果将通道的完整级别设置为1，则put()的第一个调用将事务放置在通道中，但直到事务被删除后才返回。 7.6.5 使用邮箱和事件的同步线程 您可能希望这两个线程使用握手，这样生产者就不会走在消费者前面。消费者已经阻塞，等待使用邮箱的生产者。生产者需要阻塞，等待消费者完成事务。为此，可以向生产者添加一个阻塞语句，比如一个事件、一个信号量或第二个邮箱。样例7.42在生产者将数据放入邮箱后使用事件阻塞生产者。使用者在使用数据后触发事件。 如果在循环中使用wait (handshake.triggered)，请确保在再次等待之前提前时间，如前面7.4.3节所示。这种等待在一个给定时间段内只阻塞一次，因此您需要进入另一个时间段。示例7.42使用边缘敏感的阻塞语句@handshake来代替，以确保 生产者在发送事务后停止。边缘敏感语句在一个时隙中工作多次，但如果触发器和块发生在同一个时隙中，则可能出现排序问题。 样例7.42生产者-消费者与一个事件同步 现在生产者在消费者触发事件之前不会前进，如示例7.43所示。 示例7.43带有事件的生产者-消费者输出 您可以看到，生产者和消费者成功地同步运行，因为生产者在旧值被读取之前不会产生新值。 7.6.6 使用两个邮箱的同步线程 另一种同步两个线程的方法是使用第二个邮箱将完成消息发送回生产者，如示例7.44所示。 与邮箱同步的生产者-消费者示例7.44 rtn邮箱中的返回消息只是原始整数的负版本。您可以使用任何值，但是为了进行调试，可以根据原始值来检查这个值。 示例7.45使用邮箱的生产者-消费者输出 从示例7.45中可以看到，生产者和消费者成功地同步运行。 7.6.7 其他同步技术 您还可以通过阻塞变量或信号量来完成握手。事件是最简单的结构，然后在变量上阻塞。信号量相当于使用第二个邮箱，但不交换信息。SystemVer- ilog的绑定邮箱不能像这些其他技术那样工作，因为当生产者放入第一个事务时，没有办法阻塞生产者。样例7.41表明生产者总是先于消费者一个事务。 7.7. 使用线程和IPC构建测试平台 早在1.10节中，您就了解了分层testbench。图7.8显示了不同部分之间的关系。现在您已经知道了如何使用线程和IPC，现在可以使用事务来构建一个基本的测试平台。 图7.8带环境的分层试验台 7.7.1 基本办理人 示例7.46是位于生成器和驱动程序之间的代理类。 示例7.46基本处理程序 7.7.2 配置类 configuration类允许您为每个模拟随机化系统的配置。示例7.47只有一个变量和一个基本约束。 示例7.47配置类 7.7.3 环境类 Environment类(如图7.8中的虚线所示)包含生成器、代理、驱动程序、监视器、检查器、记分板和配置对象，以及它们之间的邮箱。示例7.48显示了一个基本的环境类。 示例7.48环境类 第8章展示了如何构建这些类的更多细节。 7.7.4 测试程序 样例7.49显示了主测试，它在一个程序块中。正如第4.3.4节所讨论的，您还可以在模块中放置测试，但会略微增加出现竞争条件的几率。 样本7.49基本测试程序 7.8. 结论 您的设计被建模为许多独立的块并行运行，因此您的testbench还必须生成多个刺激流并使用并行线程检查响应。它们被组织到一个分层的测试平台中，由顶级环境编排。除了标准的fork…join之外，SystemVerilog引入了强大的构造，如fork…join_none和fork…join_any，用于动态创建新线程。这些线程使用事件、信号量、邮箱以及经典的@事件控制和wait语句进行通信和同步。最后，使用disable命令终止线程。 这些线程和相关的控制构造补充了OOP的动态特性。当对象被创建和销毁时，它们可以在独立的线程中运行，允许您构建一个强大而灵活的testbench环境。 7.9. 练习 对于下面的代码，确定每个状态的执行顺序和时间——如果使用了join或join_none或join_any。提示:fork和join/join_none/join_any之间的执行顺序和时间是相同的，只是连接后的语句的顺序和执行时间不同。 对于下面的代码，使用和不使用等待叉的输出是什么 是否插入到指定的位置? 下面的代码将显示什么?假设事件和任务触发器在声明为automatic的程序中声明。 创建一个名为wait10的任务，该任务将等待10个ns，然后检查是否有一个信号量键可用。当键可用时，退出循环并打印时间。 下面调用练习4中的任务的代码将显示什么? 下面的代码将显示什么? 查看265页的图7.8“分层的testbench with environment”，并创建Monitor类。您可以做以下假设。 Monitor类拥有类OutputTrans的知识，该类的成员变量为out1和out2。 DUT和监视器通过一个名为my_bus的接口连接，信号为out1和out2。 接口my_bus有一个时钟块cb。 在每个活动时钟边缘上，Monitor类将对DUT输出(out1和out2)进行采样，将它们分配给OutputTrans类型的对象，并将该对象放在邮箱中。 "},"articles/chapter-08.html":{"url":"articles/chapter-08.html","title":"第八章　　面向对象进阶和Testbench指南","keywords":"","body":"第八章高级面向对象和测试工作台指南 如何为同样执行错误注入并具有随机延迟的总线事务创建复杂类?第一种方法是将所有内容放入一个大型的扁平类中。这种方法构建简单，易于理解(所有代码都在一个类中)，但开发和调试可能比较慢。此外，如此大的类是一个维护负担，因为任何想要进行新的事务行为的人都必须编辑相同的文件。正如您永远不会仅仅使用一个Verilog模块来创建复杂的RTL设计一样，您应该将类分解为更小的、可重用的块。 另一种方法是作曲。正如你在第5章中所学到的，你可以在一个类中实例化另一个类，就像你在另一个类中实例化模块一样，构建一个分层的testbench。您从自顶向下或自底向上编写和调试类，在决定哪些变量和方法进入各个类时，总是寻找自然分区。一个像素可以划分为它的颜色和坐标。一个包可以分为报头和有效载荷。您可以将一条指令分解为操作码和操作数。有关分区的指导方针，请参阅第8.4节。 有时很难将功能划分为单独的部分。考虑在总线事务期间注入错误。在为事务编写原始类时，可能不会考虑到所有可能的错误情况。理想情况下，您希望为一个好的事务创建一个类，然后添加不同的错误注入器。事务具有数据字段和从数据生成的错误检查校验和字段。错误注入的一种形式是校验和字段的损坏。如果您使用组合，那么对于好的事务和错误事务，您需要单独的类。使用好的对象的Testbench代码必须重写以处理新的错误对象。您需要的是一个与原始类相似但添加了一些新变量和方法的类。这个结果是通过继承来实现的。 继承允许通过添加新的变量和方法来扩展现有类。原始类被称为基类。由于新类扩展了基类的功能，所以它被称为扩展类。继承通过在现有类上覆盖特性(如错误注入)而不修改该类，从而提供了可重用性。 OOP真正的强大之处在于，它允许您获取一个现有的类(比如一个事务)，并通过替换方法有选择地更新其部分行为，而不必更改周围的基础设施。所有依赖于基类的原始测试继续工作，现在您可以使用扩展类创建新的测试。通过一些计划，您可以创建一个足够坚固的testbench来发送基本事务，但又能够容纳测试所需的任何扩展。 请注意，本章涉及了广泛的高级OOP主题，其中许多在学习SystemVerilog时并不需要。现在可以跳过后面的部分，等您深入研究UVM和VMM的内部结构时再看。 8.1. 介绍继承 图8.1显示了一个简单的测试台。测试控制发电机。生成器创建事务，随机化它们，并沿着虚线将它们发送给驱动程序。驱动程序将事务分解为pin摆动，并沿着虚线将其发送到DUT。测试台上的其他部分被忽略了。 图8.1简化分层试验台架 8.1.1 基本的事务 示例8.1中的基本事务类有用于源地址和目的地址的变量、8个数据字、一个用于错误检查的校验和，以及用于显示内容和计算校验和的方法。calc_csm函数被标记为虚函数，以便在需要时可以重新定义它，如下一节所示。虚方法将在本章后面的章节中进行更详细的解释 8.3.2。这个类非常简单，它使用默认的SystemVerilog构造函数，该构造函数分配内存并将变量初始化为默认值。 示例8.1基事务类 通常计算校验和将在post_randomize()中完成，但在这个例子中，它已经从随机化中分离出来，以展示如何注入错误。 图8.2显示了包含变量和方法的类的图。 事务 图8.2基本事务类图 扩展事务类 假设你有一个通过DUT发送好的事务的测试平台，现在你想注入错误。如果您遵循第1章的指导方针，您将希望对您现有的测试平台进行尽可能少的代码更改。那么如何重用现有的事务类呢?使用现有的类 扩展它以创建一个新类。这是通过声明一个新类BadTr作为当前类的扩展来实现的。Transaction是基类，BadTr是扩展类。代码显示在示例8.2和图8.3的图表中。 示例8.2扩展事务类 注意，在示例8.2中，变量csm is不需要分层标识符。BadTr类可以看到来自原始事务的所有变量以及它自己的变量，如bad_csm，如图8.3所示。扩展类中的calc_csm函数使用超前缀调用基类中的calc_csm。你可以向上调用一个级别，但可以跨多个级别调用，比如super.super。SystemVerilog中不允许new。这种跨越多个级别的样式会因为跨越多个边界而违反封装规则。 原来的显示方法打印了一行，从前缀开始。因此扩展的display方法打印前缀、类名和bad_csm $write使结果仍然在单行上。 事务 BadTr 图8.3扩展事务类图 始终将类中的方法声明为虚方法，以便可以在扩展类中重新定义它们。这适用于所有任务和函数，除了new函数，该函数在构造对象时被调用，因此无法扩展它。SystemVerilog总是根据句柄的类型调用新函数。虚方法将在8.3.2节中详细描述。 8.1.2 更多的OOP的术语 这里是一个快速的术语表。正如第5章所解释的那样，面向对象的术语是类中的变量“属性”，任务或函数称为“方法”。基类不是从任何其他类派生的类。当您扩展一个类时，原始类(如事务)被称为父类或父类。扩展类(BadTr)也称为派生类或子类。方法的“原型”只是显示参数列表和返回类型(如果有的话)的第一行。当你将方法的主体移到类之外时，原型会被使用，但是需要描述方法如何通信，如5.10节所示。 8.1.3 扩展类中的构造函数 当您开始扩展类时，有一条关于构造函数(新函数)的规则要记住。如果基类构造函数有任何参数，则扩展类必须有构造函数，并且必须在第一行调用基类的构造函数。在示例8.3中，由于Base::new有一个参数，Extended::new必须调用它。 示例8.3在扩展类中带有参数的构造函数 8.1.4 驱动程序类 示例8.4中的驱动程序类从生成器接收事务，并将它们驱动到DUT中。 示例8.4驱动程序类 这个类通过邮箱gen2drv从生成器接收事务对象，将它们分解为接口中的信号变化，以刺激DUT。如果生成器将BadTr对象发送到类中会发生什么?OOP规则规定，如果您有一个基类型(事务)的句柄，它也可以指向扩展类型(BadTr)的对象。句柄tr只能引用基类中的东西，比如变量src、dst、csm和data，以及方法calc_csm。因此，您可以将BadTr对象发送到驱动程序中，而无需更改驱动程序类。 参见第10章和第11章，了解具有虚拟接口和回调等高级特性的全功能驱动程序的例子。 当驱动程序调用tr.calc_csm时，将调用哪一个，事务中的那个还是BadTr中的那个?由于calc_csm在样例8.1的基类中声明为虚方法，SystemVerilog根据tr中存储的对象类型选择合适的方法。如果对象是事务类型，SystemVerilog会调用任务Transaction::calc_csm。如果是BadTr类型，则SystemVerilog调用函数BadTr::calc_csm。 8.1.5 简单的生成器类 这个testbench的示例8.5中的生成器创建了一个随机事务，并将其放入发送给驱动程序的邮箱中。下面的(错误的)示例显示了如何根据目前所学的知识创建类。注意，这避免了一个非常常见的testbench bug，因为它在每次循环中构造一个新的事务对象，而不是只在循环外部构造一次。关于邮箱的第7.6节将详细讨论此错误。 示例8.5坏生成器类 这个发电机有一个很大的限制。运行任务构造一个事务并立即将其随机化。这意味着事务使用任何默认打开的约束。唯一可以改变这一点的方法是编辑Transaction类，这违背了本书中提出的验证指南。更糟糕的是，生成器只使用事务对象——没有办法使用扩展对象，如BadTr。修复的方法是将tr的构造与它的随机化分开，如下面的8.2节所示。 在构建面向数据的类(如网络和总线事务)时，您将看到它们具有公共属性(id)和方法(display)。面向控件的类，如生成器和驱动程序类，也有共同的结构。您可以通过使这两个类都是基处理程序类的扩展(带有用于run的虚拟方法)和wrap_up来实现这一点。UVM和VMM都有一组广泛的用于事务处理、数据等的基类。 8.2. 蓝图模式 一个有用的面向对象技术是“蓝图模式”。“如果你有一台制作标识的机器，你就不需要事先知道每一个可能标识的形状。你只需要一台冲压机，然后改变模具来切割不同的形状。同样，当您想要构建事务处理生成器时，您不必知道如何构建每种类型的事务;你只需要会盖章就行了 与给定事务类似的新事务。 与样例8.5中构造然后立即使用一个对象不同的是，构造一个blueprint对象(切模)，然后用constraint_mode修改它的约束，甚至用扩展对象替换它，如图8.4所示。现在，当你随机化这个蓝图时，它会有你想要的随机值。创建此对象的副本，并将该副本发送给下游事务处理程序。 图8.4蓝图模式发生器 这种技术的美妙之处在于，如果您更改blueprint对象，您的生成器将创建一个不同类型的对象。使用符号类比，你改变切割模具从一个正方形到一个三角形作出屈服符号，如图8.5所示。 图8.5带有新图案的蓝图生成器 蓝图是一个“钩子”，它允许你改变属类的行为，而不需要改变它的代码。您需要创建一个复制方法，该方法可以复制蓝图来传输，这样原始蓝图对象就会被保留下来，以供下次通过循环时使用。 示例8.6展示了使用blueprint模式的generator类。需要注意的重要一点是，blueprint对象是在一个地方构造的(新函数) 使用蓝图模式的示例8.6生成器类 并在另一个(run任务)中使用。在这本书之前的编码指南说，分开声明和构造;类似地，您需要分离blueprint对象的构造和随机化。 复制方法通过将对象的变量复制到一个新对象来复制该对象，将在5.15节和8.5节中讨论。现在，请记住必须将其添加到事务和BadTr类中。第304页的示例8.34显示了一个使用模板的高级生成器。 每当蓝图被随机化时，这个生成器都会构造一个新的事务。这种编码风格防止了典型的OOP邮箱错误，因为邮箱将存储多个惟一对象的句柄，而不是同一个对象。 反复随机化blueprint对象的另一个好处是，randc变量可以正确工作。示例8.5中的坏生成器每次通过循环都会构造新的对象。每个带有randc变量的对象都维护为该变量生成的以前值的历史记录。每当您构造一个新对象时，历史记录就会丢失，而坏生成器会创建带有独立randc变量的对象。在示例8.6中，只有blueprint对象是随机的，因此randc历史被维护。 修改蓝图的操作请参见8.2.3章节。 环境类 第一章讨论了执行的三个阶段:构建、运行和总结。样本 8.7显示了实例化所有testbench组件的环境类，并运行这三个阶段。还要注意邮箱gen2drv是如何将事务从生成器传递到驱动程序的，因此会将每个事务传递到构造函数中。 示例8.7环境类 8.2.1 一个简单的Testbench 测试包含在示例8.8中所示的顶级程序中。基本测试只是让环境以所有默认值运行。 示例8.8使用环境默认值的简单测试程序 使用扩展的事务类 要注入错误，您需要将blueprint对象从事务对象更改为BadTr。您可以在环境中的构建阶段和运行阶段之间进行此操作。示例8.9中的顶级测试工作台运行环境的每个阶段并更改蓝图。注意，对BadTr的所有引用都在这个文件中，因此不必更改环境或生成器 类。你想限制使用BadTr的范围，所以在初始块的中间使用一个独立的begin…end块。这就形成了一个视觉上与众不同的代码块。您可以采用捷径，在声明中构造扩展类。 示例8.9向testbench注入一个扩展的事务 8.2.2 使用扩展类更改随机约束 在第6章中，您学习了如何生成受限随机数据。您的大多数测试将需要进一步约束数据，这最好通过继承来完成。在示例8.10中，原始事务类被扩展为包含一个新的约束，该约束将目标地址保持在源地址的+/−100范围内。 示例8.10用一个扩展的对象替换生成器的蓝图，该对象具有额外的约束。正如你将在本章后面学到的，邻近的类应该有一个复制方法，但是在一些章节中请稍等。 示例8.10添加带有继承的约束 请注意，如果在扩展类中定义的约束与基类中的约束同名，则扩展的约束将替换基类中的约束。这允许您更改现有约束的行为。 8.3. 向下casting和虚拟方法 当您开始使用继承来扩展类的功能时，您需要一些OOP技术来控制对象及其功能。特别是，句柄可以引用特定类或任何扩展类的对象。那么，当基本句柄指向扩展的对象时，会发生什么呢?当调用基类和扩展类中同时存在的方法时会发生什么?本节用几个例子解释发生了什么。 向下类型转换美元投 向下强制转换或转换是将基类句柄强制转换为指向从该基类类型扩展的类的对象的行为。考虑一下示例8.11和图8.6中的基类和扩展类。 示例8.11基类和扩展类 图8.6简化的扩展事务 您可以将扩展句柄分配给基本句柄，不需要特殊代码，如示例8.12所示。当一个类被扩展时，所有的基类变量和方法都被包含，所以src在扩展对象中。对tr的赋值是允许的，因为任何使用基本句柄tr的引用都是有效的，例如tr.src和tr.display。 示例8.12复制扩展句柄到基本句柄 如果尝试相反的方向，如示例8.13所示，将基对象的句柄复制到扩展句柄中，会怎么样?这将失败，因为基对象缺少仅存在于扩展类中的属性，如bad_csm。SystemVerilog编译器对句柄类型进行静态检查，不会编译第二行。 示例8.13复制基本句柄到扩展句柄 将基句柄分配给扩展句柄并不总是非法的，但必须始终使用$cast。当基本句柄指向扩展对象时，允许赋值。$cast方法检查句柄引用的对象类型，而不仅仅是句柄。如果源对象与目标对象类型相同，或者是从目标的类扩展而来的类，则可以将扩展对象的地址从基句柄tr复制到扩展句柄bad2中。 示例8.14使用$cast复制句柄 当您使用$cast作为任务时，SystemVerilog在运行时检查源对象的类型，如果它与目标不兼容，则给出一个错误。当您使用$cast作为函数时，SystemVerilog仍然检查类型，但如果不匹配，则不再打印错误。当类型不兼容时，$cast函数返回0，兼容类型返回1。 作为示例8.14中if语句的替代，您可以使用6.3.2节中的SV_RAND_CHECK宏。您不应该使用immediate断言语句，因为如果禁用断言，就不会计算断言表达式，这意味着$cast和bad2赋值将永远不会执行。 8.3.1 虚拟方法 到目前为止，您应该已经习惯了将句柄与扩展类一起使用。如果您试图使用这些句柄之一调用方法，会发生什么?示例8.15和8.16展示了基类和扩展类以及调用这些类中的方法的代码。 示例8.15事务和BadTr类 样例8.16包含了一个使用不同类型句柄的代码块。 示例8.16调用类方法 为了决定调用哪个虚方法，SystemVerilog使用对象的类型，而不是句柄的类型。在示例8.16的最后一条语句中，tr指向一个扩展对象(BadTr)，因此调用BadTr::calc_csm。 如果忽略事务::calc_csm上的虚拟修饰符，则SystemVerilog检查句柄tr(事务)的类型，而不是对象的类型。示例8.16中的最后一条语句调用Transaction::calc_csm——这可能不是您想要的。 面向对象的术语是多方法共享一个共同的名称“多态性”。它解决了一个问题，类似于计算机架构师试图制造一个可以处理大地址空间但只有少量物理内存的处理器时所面临的问题。他们创造了虚拟内存的概念，其中的代码和 程序的数据可以驻留在内存中或磁盘上。在编译时，程序不知道它的部件在哪里——这都是由硬件和运行时的操作系统来处理的。虚拟地址可以映射到一些RAM芯片，或磁盘上的交换文件。程序员在编写代码时不再需要担心这种虚拟内存映射——他们只知道处理器会在运行时找到代码和数据。参见Denning(2005)。 8.3.2 签名和多态性 使用虚方法有一个缺点:一旦您定义了一个虚方法，所有定义相同方法的扩展类都必须使用相同的“签名”，即:，相同的参数数目和类型，加上返回值(如果有的话)。不能在扩展的虚方法中添加或删除参数。这意味着你需要提前计划。 SystemVerilog和其他OOP语言要求虚拟方法必须具有与父方法(或祖父方法)相同的签名，这是有充分理由的。如果您能够添加额外的参数，或将任务转换为函数，那么多态性将不再起作用。您的代码需要能够调用虚方法，并保证扩展类中的方法具有相同的接口。 8.3.3 构造函数从来都不是虚的 当您调用虚方法时，SystemVerilog会检查对象的类型，以决定它应该调用基类中的方法还是扩展类中的方法。现在您可以看到为什么构造函数不能是虚的了。当您调用它时，没有对象的类型可以被检查。对象只在构造函数调用启动后才存在。 8.4. 组合、继承和替代 当您构建您的测试平台时，您必须决定如何将相关的变量和方法分组到类中。在第5章中，您学习了如何构建基本类并将一个类包含在另一个类中。在本章的前面，您看到了继承的基础知识。本节将向您展示如何在这两种样式之间做出选择，以及另一种选择。 8.4.1 决定在组合和继承之间 如何将两个相关的类联系在一起?组合使用“has-a”关系。一个数据包有一个报头和一个正文。继承使用“is-a”关系。 BadTr是一个带有更多信息的事务。表8.1是一个快速指南，下面有更多细节。 表8.1比较继承和组合 问题 继承 (是一个关系) 作文 (有关系) 你需要把多个扩展课程分组在一起吗?(SystemVerilog不支持多重继承) 高级类是否表示类似抽象级别的对象? 低级别的信息总是存在还是必需的? 在被预先存在的代码处理时，额外的数据需要保持附加到原始类吗? 没有 是的 是的 没有 是的 没有 是的 没有 是否有几个小班要合并成一个大班?例如，您可能有一个data类和一个header类，现在想要创建一个packet类。SystemVerilog不支持多重继承，即一个类同时从多个类扩展。相反，你必须使用合成。或者，您可以将其中一个类扩展为新类，并手动添加来自其他类的信息。 在示例8.15中，事务和BadTr类都是在生成器中创建并驱动到DUT中的总线事务，因此继承是有意义的。 低级信息如src、dst和数据必须始终存在，以便驱动程序发送事务。 在示例8.15中，新的BadTr类有一个新的字段bad_csm和扩展的calc_csm函数。Generator类只传输事务，而不关心附加信息。如果使用组合创建错误总线事务，则必须重写Generator类以处理新类型。 如果两个对象似乎通过“is-a”和“has-a”相互关联，那么您可能需要将它们分解为更小的组件。 8.4.2 问题的作文 构建类层次结构的经典OOP方法将功能划分为易于理解的小块。然而，testbench并不是标准的 软件开发项目，如第5.16节中讨论的公共属性与本地属性。像信息隐藏(使用局部变量)这样的概念与构建一个需要最大可见性和可控性的测试平台相冲突。类似地，将事务划分为更小的部分可能会导致比它解决的问题更多的问题。 当您创建一个类来表示一个事务时，您可能希望对它进行分割，以使代码更易于管理。例如，您可能有一个以太网MAC帧，您的测试工作台使用两种风格，普通(II)和虚拟LAN (VLAN)。使用composition，您可以创建一个基本单元格EthMacFrame，其中包含所有常见字段，如da和sa，以及一个判别变量kind，以表示示例8.17中所示的类型。还有第二个类用来保存VLAN信息，它包含在EthMacFrame中。 示例8.17构建带有组合的以太网帧 作文有几个问题。首先，它添加了额外的层次结构层，因此您必须不断地向每个引用添加额外的名称。VLAN信息称为eth_h.vlan_h.vlan。如果您开始添加更多的外行，层次名称就会成为一种负担。 当您想实例化和随机化类的层次结构时，会出现一个更微妙的问题。EthMacFrame构造函数创建了什么?由于kind是随机的，所以您不知道在调用new时是否要构造一个Vlan对象。当您随机化类时，约束会根据随机种类字段设置EthMacFrame和Vlan对象中的变量。你有一个循环的依赖关系，在随机化只工作在对象已经实例化，但你不能实例化这些对象，直到kind已被选择。 构造和随机化问题的唯一解决方案是总是实例化EthMacFrame::new中的所有对象。但是，如果您总是使用所有的替代方案，为什么要将以太网单元划分为两个不同的类呢? 8.4.3 继承的问题 继承可以解决其中的一些问题。扩展类中的变量可以不像eth_h.vlan那样具有额外的层次结构而被引用。您不需要判别器，但是您可能会发现只测试一个变量比执行示例8.18中所示的类型检查更容易。 示例8.18构建具有继承的以太网帧 缺点是，一组使用继承的类总是比一组没有继承的类需要更多的设计、构建和调试工作。当你有一个从基本句柄到扩展句柄的赋值时，你的代码必须使用$cast。构建一组虚拟方法具有挑战性，因为它们都必须具有相同的签名。如果需要额外的参数，则需要返回并编辑整个集合，可能还需要调用方法。 随机化也存在一些问题。你如何在两种框架中随机选择一个约束并设置适当的变量?不能在EthMacFrame中添加引用vlan字段的约束。 最后一个问题是多重继承。在图8.7中，你可以看到VLAN帧是如何从一个普通的MAC帧扩展过来的。问题是，这些不同的标准重新趋于一致。SystemVerilog不支持多重继承，因此无法通过继承创建VLAN / Snap / Control帧。 图8.7多重继承问题 8.4.4 一个真实的选择 如果组合会导致较大的层次结构，但继承需要额外的代码和计划来处理所有不同的类，而且两者都有难以构建和随机化的情况，那么您能做什么呢?相反，您可以创建一个包含所有变量和方法的单一平面类。这种方法会产生一个非常大的类，但是它可以干净地处理所有的变体。您必须经常使用判别变量来判断哪些变量是有效的，如示例8.19所示。它包含几个条件约束，它们适用于不同的情况，取决于kind的值。 示例8.19构建平面以太网帧 无论您如何构建类，都要在类中定义典型的行为和约束，然后使用继承在测试级别注入新的行为。 8.5. 复制一个对象 在示例8.6中，生成器首先随机化，然后复制蓝图以创建一个新事务。仔细看看示例8.20中的copy函数。有关复制函数的更多示例，请参见5.15节。 示例8.20带有虚拟复制函数的基本事务类 当您扩展事务类以使类BadTr时，复制函数仍然必须返回一个事务对象。这是因为扩展虚函数必须匹配基本事务::copy，包括所有参数和返回类型，如示例8.21所示 示例8.21使用虚拟复制方法的扩展事务类 8.5.1 指定复制的目的地 前面的复制方法总是构造一个新对象。对copy的一个改进是指定应该放置副本的位置。当您希望重用现有对象而不分配新对象时，此技术非常有用。 示例8.22带有copy函数的基本事务类 唯一的区别是指定目标的附加参数，以及测试将目标对象传递给此方法的代码。如果没有传递任何信息(默认值)，则构造一个新的对象，或者使用现有的对象。 因为您已经向基类中的虚方法添加了一个新参数，所以您必须将它添加到扩展类中的相同方法中，例如BadTr。 示例8.23扩展事务类，带有新的复制函数 请注意，BadTr::copy只需要复制扩展类中的字段，并且可以使用基类方法Transaction::copy来复制自己的字段。 8.6. 抽象类和纯虚方法 到目前为止，您已经看到了带有用于执行常见操作(如复制和显示)的方法的类。验证的一个目标是创建可以跨多个项目共享的代码。如果您的公司对一组通用的类和方法进行标准化，那么在项目之间重用代码就会更容易。 像SystemVerilog这样的OOP语言有两种构造，允许您构建一个可共享的基类。第一个是抽象类，它是一个可以扩展的类，但不能直接实例化。它使用virtual关键字定义。第二种是纯虚拟方法，是一个没有主体的原型。从抽象类扩展而来的类只有在所有纯虚方法都有实体的情况下才能实例化。pure关键字指定方法声明是一个原型，而不仅仅是一个空的虚方法。纯方法没有endfunction或end- task。最后，纯虚方法只能在抽象类中声明。抽象类可以包含纯虚方法、包含或不包含主体的虚方法以及非虚方法。注意，如果你定义了一个没有主体的虚方法，也就是说里面没有代码，你可以调用它，但它会立即返回。 示例8.24显示了一个抽象类BaseTr，它是事务的基类。它从一些有用的属性开始，比如id和count。构造函数确保每个实例都有一个唯一的ID。接下来是用于比较、复制和显示对象的纯虚拟方法。 示例8.24带有纯虚方法的抽象类 可以声明BaseTr类型的句柄，但不能构造这种类型的对象。您需要扩展这个类并为所有纯虚方法提供实现。 样例8.25展示了Transaction类的定义，它是从BaseTr扩展而来的。由于事务具有所有从BaseTr扩展的纯虚拟方法的主体，所以您可以在您的testbench中构造这种类型的对象。 示例8.25事务类扩展了抽象类 抽象类和纯虚方法让您可以构建具有共同外观的testbench。这让任何工程师都能阅读你的代码并快速理解其结构。 8.7. 回调 这本书的主要指导方针之一是创建一个单一的验证环境，你可以在不做任何更改的情况下使用它进行所有的测试。关键的要求是这个testbench必须提供一个“钩子”，在这个钩子上，测试程序可以注入新的代码，而不需要修改原始的类。您的驱动程序可能想要做以下工作。 注入错误 下降的事务 延迟的事务 将此事务与其他事务同步 把交易记录在记分牌上 收集功能覆盖率数据 而不是试图预测所有可能的错误、延迟或气流中的扰动 对于事务，驱动程序只需要“回调”顶级测试中定义的方法。这种技术的美妙之处在于，在每个测试中，回调方法的定义都是不同的。因此，测试可以使用回调函数向驱动程序添加新的功能，而不需要编辑驱动程序类。对于一些极端的行为，比如删除事务，您需要提前在类中编写代码，但这是一个已知的模式。删除事务的原因留给回调。 司机:任务:运行;永远的开始 … 传输(tr); … 结束endtask 任务pre_callback; … endtask 任务post_callback; … endtask 图8.8回拨流程 在图8.8中，驱动程序::run任务循环永远调用一个transmit任务。在发送事务之前，run调用预传输回调(如果有的话)。在发送事务之后，它调用后回调任务(如果有的话)。默认情况下，没有回调，因此运行只调用传输。 你可以让Driver::run一个虚拟方法，然后在扩展类中重写它的行为，比如MyDriver::run。这样做的缺点是，如果您需要在新方法中复制原始方法的所有代码 注入新的行为。现在，如果对基类进行了更改，则必须记住将其传播到所有扩展类。此外，您可以在不修改构造原始对象的代码的情况下注入回调函数。 8.7.1 创建一个回调 在顶级测试中创建回调任务，并从环境的最低级别驱动程序调用它。然而，驱动程序不需要对测试有任何了解——它只需要使用测试可以扩展的泛型类。示例8.27中的驱动程序使用一个队列来保存回调对象，它允许您添加多个对象。示例8.26中的基回调类是一个抽象类，在使用之前必须进行扩展。你的回调是一个任务，所以它可以有延迟。 示例8.26基回调类 示例8.27带回调的驱动程序类 注意，Driver_cbs是一个抽象类，pre_tx和post_tx不是纯虚拟方法。这是因为一个典型的回调函数只使用其中一个。如果一个类有一个没有实现的纯虚方法，OOP规则将不允许您实例化它。 回调是VMM和UVM的一部分。这种回调技术与Verilog PLI回调或SVA回调无关。 8.7.2 使用回调来注入干扰 回调的一个常见用途是注入一些干扰，例如引起错误或延迟。示例8.28中的测试工作台使用回调对象随机丢弃数据包。回调还可以用来将数据发送到记分板或收集函数覆盖值。请注意，您可以使用push_back()或push_front()将回调对象放入队列中，这取决于您希望这些对象被调用的顺序。例如，您可能希望在任何可能延迟、损坏或删除事务的任务之后调用记分板。您应该只在事务成功传输后才收集覆盖范围。 示例8.28使用回调错误注入的测试 8.7.3 快速介绍记分板 记分牌的设计取决于被测试的设计。处理原子事务(如包)的DUT可能有一个计分板，其中包含一个转换函数来将输入事务转换为期望的值，一个存储这些值的内存，以及一个比较方法。处理器设计需要一个参考模型来预测预期的输出，在模拟结束时可能会对预测值和实际值进行比较。 示例8.29显示了一个简单的记分牌，它将事务存储在一个预期值队列中。第一种方法保存一个预期的事务，第二种方法尝试查找与testbench接收到的实际事务相匹配的预期事务。注意，当您搜索一个队列时，您可以得到0个匹配(没有找到事务)、1个匹配(理想情况下)或多个匹配(您需要进行更复杂的匹配)。 示例8.29原子事务的简单记分牌 8.7.4 通过回调连接到记分板 示例8.30中的testbench创建了驱动程序回调类的自己扩展，并添加了对驱动程序回调队列的引用。请注意，计分板回调需要一个计分板句柄，以便它可以调用该方法来保存预期的事务。这个示例没有显示监视器端，它需要自己的回调来将实际事务发送到记分牌进行比较。 示例8.30测试使用回调计分板 VMM建议您对记分板和功能覆盖使用回调。监视器事务处理程序可以使用回调来比较接收到的事务和预期的事务。监视器回调也是收集关于由DUT实际发送的事务的功能覆盖的完美场所。 您可能已经想到将记分板或功能覆盖组放在事务处理程序中，并使用邮箱将其连接到测试工作台。这是一个糟糕的解决方案，原因有几个。这些测试工作台组件几乎总是被动的和异步的，所以它们只有在测试工作台有数据时才会苏醒，而且它们永远不会将信息传递给下游事务处理程序。因此，必须同时监视多个邮箱的事务处理程序是一个过于复杂的解决方案。此外，您可以从测试台上的几个点采样数据，但事务处理程序是为单个源设计的。相反，将方法放在你的记分板和覆盖类中来收集数据，并通过回调将它们连接到testbench。 UVM推荐TLM分析端口，用于连接监视器/驱动程序到记分板和功能覆盖。对这种结构的描述超出了本书的范围，但是您可以将其看作一个具有可选使用者的邮箱。 8.7.5 使用回调来调试事务处理程序 如果带有回调的事务处理程序没有按预期工作，则可以添加调试回调。您可以从添加回调来显示事务开始。如果有多个事务处理程序实例，则为每个实例创建唯一标识符。在其他回调之前和之后放置调试代码，以定位导致问题的回调。即使对于调试，您也希望避免对testbench环境进行更改。 8.8. 参数化的类 当您越来越熟悉类时，您可能会注意到，类(如堆栈或生成器)只适用于单一数据类型。本节展示如何定义使用多个数据类型的单个参数化类。 8.8.1 一个简单的栈 一个常见的数据结构是堆栈，它有push和pop方法来存储和检索数据。示例8.31展示了一个使用int数据类型的简单堆栈。 示例8.31使用int类型的堆栈 这个类的问题是它只适用于整数。如果您想为实数创建一个堆栈，则必须复制该类，并将数据类型从int更改为real。这将很快导致类的激增，如果您想添加新的操作(如遍历或打印堆栈内容)，这可能会成为维护问题。 在SystemVerilog中，可以向类添加数据类型参数，然后在向该类声明句柄时指定类型。这与参数化模块类似，但比它更强大，在参数化模块中，您可以在实例化时指定总线宽度等值。SystemVerilog的参数化类类似于c++中的模板。 示例8.32是堆栈的参数化类。注意类型T是如何在第一行定义的，它的默认类型是int。 示例8.32堆栈的参数化类 向参数化类指定值的步骤称为专门化。 样例8.33声明了一个具有真实数据类型的stack类的句柄。 示例8.33创建参数化的堆栈类 生成器是一个很好的类参数化的例子。一旦为一个类定义了类，同样的结构就可以用于任何数据类型。样本 8.34使用了示例8.6中的原子生成器，并添加了一个参数 生成任意随机对象。生成器应该是验证类包的一部分。它需要指定一个默认类型，因此它使用示例8.24中的BaseTr，因为这个抽象类也应该是验证包的一部分。 示例8.34使用蓝图模式的参数化生成器类 使用示例8.25中的事务类和示例8.34中的生成器，您可以构建一个示例8.35中的简单测试平台。它启动生成器并打印前五个事务，使用示例7.40中所示的邮箱同步。 示例8.35使用参数化生成器类的简单testbench 8.8.2 共享参数化的类 当您专门化一个参数化类时，就像在示例8.33中的实际堆栈中一样，您正在创建一个新的数据类型，与任何其他专门化没有OOP关系。例如，不能使用$cast()在实变量堆栈和整数之一之间进行转换。为此，您需要一个公共基类，如示例8.36所示。 示例8.36参数化生成器类的公共基类 接下来的部分将展示更多参数化类的示例。 8.8.3 参数化的类的建议 在创建参数化类时，应该从非参数化类开始，彻底调试它，然后添加参数。这种分离减少了您的调试工作。 在创建参数化类时，事务类中的一组通用虚拟方法可以帮助您。Generator类使用copy方法，知道它总是具有相同的签名。同样，display方法允许您在事务流经testbench组件时轻松调试它们。 当您的类需要知道形参的名称和宽度时，系统函数$typename()和$bits()是有用的。$typename(T)函数返回形参类型的名称，比如int、real，或者句柄的类名。函数的作用是:返回参数的宽度。对于复杂类型(如结构和数组)，它返回作为位流保存表达式所需的位数。UVM事务打印方法使用这个函数来正确地排列字段。 宏是参数化类的替代方案。例如，您可以为生成器定义一个宏，并将事务数据类型传递给它。宏比参数化类更难调试，除非编译器输出扩展代码。 如果需要定义几个共享相同事务类型的相关类，可以使用参数化类或单个大型宏。最后，如何定义类并不重要，重要的是它们包含了什么。 8.9. 静态和单例类 本节和下一节将展示在UVM和VMM中广泛使用的高级OOP概念。您可以通过阅读带有许多方法的源代码来尝试理解UVM的工厂机制，但是这一节应该可以通过一个非常简化的示例为您节省几天的实验时间。本章展示了几个替代方案，这样您就可以理解为什么UVM没有选择一个更简单的替代方案。 OOP的目标之一是消除全局变量和方法，因为生成的代码很难维护和重用。它们的名称存在于全局名称空间中，可能会导致名称空间冲突。packet_count是指TCP/IP数据包还是其他协议?相反，在包类中放置一个名为count的变量，以避免任何歧义。 8.9.1 用于打印消息的动态类 然而，有时确实需要全局变量。例如，所有的验证方法都提供了打印服务，这样你就可以过滤消息并统计错误。如果您尝试用目前所学的知识构建这样一个类，它可能类似于示例8.37。 示例8.37带有静态变量的动态打印类 这是VMM日志类的一个简化版本。VMM代码允许您通过类名和实例名以及许多其他特性来过滤消息。 示例8.38中的类使用示例8.37中的Print类打印错误消息。 示例8.38带有动态打印对象的事务处理类 Print类的最大限制是测试台上的每个组件都需要实例化它。上面的简单Print类占用的内存很少，但是像VMM这样的实际Print类可能有很多字符串和数组，消耗了大量的内存。当添加到一个事务处理程序类时，这个开销可能并不大，但可能会淹没一个小事务类，例如只有53个字节的ATM单元。 8.9.2 打印消息的单例类 构造所有这些打印对象的另一种方法是不构造任何对象。如第5.11.4节所述，可以将Print类中的方法声明为静态方法。这些方法只能引用静态变量，如示例8.39所示。 示例8.39静态打印类 既然类是静态的，您就不能再拥有每个实例的信息，比如父类的名称和实例。任何筛选都必须基于其他条件。 示例8.40带有静态打印类的事务处理类 示例8.40展示了使用Print类名调用error()方法。 这种类型的类被称为单例类，因为只有一个副本，就是在精化阶段用静态变量分配的副本。 随着您的静态类(如示例8.39中的类)变大，您必须用static关键字标记所有东西，这是一个小麻烦。接下来，在模拟时间之前分配类，即使您从未使用过它。此外，该类没有句柄，所以您不能将它传递给您的测试工作台。静态类的另一种选择是具有单个实例的单例类(或单例模式)，这是一个只构造一次的非静态类。它们在一开始很难创建，但是它们可以简化程序的架构。UVM的许多课程都是单例的。 单例模式是通过创建一个类的方法来实现的，该方法在类的新实例不存在时创建一个新实例。如果一个实例已经存在，它只返回该对象的句柄。要确保不能以任何其他方式实例化对象，必须使构造函数处于保护状态。不要将其设置为局部的，因为扩展的类可能需要访问构造函数。 8.9.3 配置数据库与静态参数化类 静态类在验证中的另一个好的用途是配置参数的数据库。在模拟的开始，你随机配置你的系统。在一个小型系统中，您可以简单地将它们存储在单个类中或类的层次结构中，并根据需要在testbench中传递它们。但在某些时候，这变得太复杂了，因为句柄在层次结构中上下传递。相反，创建一个全局参数数据库，以名称为索引，您可以访问testbench中的任何位置。UVM 1.0引入了这个概念，它是下面一组示例的基础。这段代码在数据库中有一个字符串索引，而像UVM这样的真实数据库可以有一个属性名、实例名和其他值。您可以将它们连接起来，创建一个更复杂的索引字符串。 数据库的一个问题是需要在单个数据库中存储不同类型的值，比如位向量、整数、实数、枚举值、字符串、类句柄、虚拟接口等等。虽然可以找到一些常见的类型，如位向量和公共基类，但也有一些类型，如virtual 接口是唯一的，因此没有简单的方法将它们存储在公共数据库中。早期版本的OVM和UVM建议创建一个围绕虚拟接口的类包装器，但这需要额外的编码，并且是常见的bug来源。 如果为每种数据类型创建不同的数据库会怎样?您可以使用以参数名称为索引的关联数组。一个真实的数据库可能也有一个实例名，但是对于这个简单的示例，您可以将所有的名称连接在一起，形成一个索引。示例8.41展示了由全局方法组成的整数数据库的代码。 示例8.41使用全局方法配置数据库 您可以使用8.8节中的概念将其概括为一个参数化类，如示例8.42所示。 示例8.42带有参数化类的配置数据库 现在可以为整数数据库、真实数据库等构造对象。最后一个问题是数据库的每个实例都是本地的 类被实例化。示例8.43中显示的解决方案是全局化，并使其成为一个静态类，即一个具有静态属性和方法的类。 示例8.43配置数据库与静态参数化类 您可以用示例8.44测试上述代码，看看参数化类如何为每种类型创建一个新数据库。 示例8.44 Testbench用于配置数据库 通过将单例对象实现为单实例而不是静态类成员，您可以惰性地初始化单例对象，只在需要时创建它。 UVM数据库允许通配符和其他正则表达式，这需要比关联数组更复杂的查找模式。 8.10. 创建测试注册表 在实际设计中，编译测试和DUT需要花费大量时间。如果要运行100个测试，每个测试都在单独的程序块中，则需要在每次测试之前重新堆100次。这是对CPU时间的浪费，因为大多数代码都没有改变。如果您创建了100个程序块，每个程序块都有一个测试，并连接模型中的所有这些程序，那么您需要一种方法来禁用除一个程序块以外的所有程序块。最好的解决方案是将所有测试和testbench包含在一个程序块中，用DUT编译一次。本节展示如何使用Verilog命令行开关为每次运行选择一个测试。 8.10.1 使用静态方法测试注册表 本书前面的例子有一个包含一个测试的程序。对于这种新方法，每个测试都是一个单独的类，它们都在一个单独的程序块中，或者从包中导入，或者在编译时包含。测试类被构造、注册到测试注册表中，然后，在运行时，您可以在运行时选择所需的测试。这遵循早期的VMM风格。 首先，您需要一个可以扩展您的测试的基测试类。示例8.45显示了一个抽象类，它包含一个Environment类的句柄和一个纯虚拟任务，该任务是包含测试代码的方法的占位符。 示例8.45基本测试类 test registry类的核心是所有测试句柄的关联数组，以测试名称为索引。示例8.46中显示的TestRegistry类是一个只有静态变量和方法的静态类，并且从来没有构造过。get_test()方法读取Verilog命令行参数，以确定要执行哪个测试。 示例8.46测试注册表类 示例8.47展示了如何扩展TestBase来创建一个运行所有环境阶段的简单测试。示例的最后一行是调用构造函数的声明，构造函数也注册了测试。构造了所有的测试对象，但只有一个运行。 示例8.47类中的简单测试 示例8.48中的程序现在只是向测试注册中心请求一个测试对象并运行它。测试类可以在包中声明并导入，也可以在程序块内部或外部声明。 示例8.48测试类的程序块 样例8.49展示了如何创建一个测试类，通过更改生成器的蓝图来创建错误的事务来注入新行为。 示例8.49将错误事务放入生成器的测试类 这个简短的示例允许您将许多测试编译到单个模拟可执行文件中，并在运行时选择您的测试，从而节省许多重新编译。当您从少量测试开始时，这种模式很好，但是下一节将展示更强大的方法。 8.10.2 使用代理类测试注册表 前一节的测试注册表可以很好地工作于较小的测试环境，但是对于真实的项目有一些限制。首先，您需要记住构造每个测试类，否则注册表无法定位它。其次，在模拟开始时构造每个测试，即使实际上只运行一个测试。 在验证一个大型设计时，可能会有数百个测试，因此构建所有这些测试会浪费宝贵的模拟时间和内存。 考虑这个比喻。当你想买车时，你可以去经销商那里看看有哪些选择。如果只有几个变种，白色或黑色，带或不带天窗，经销商可以以很少的开销来储备每一种型号。这就是您在前一节中所看到的，其中测试注册中心有每个测试类型的对象。 如果有许多不同的型号，每一种颜色都有一种，还有诸如收音机、天窗、空调、运动包和引擎之类的变体，那该怎么办?经销商永远不可能在他的lot中拥有一种类型，因为有数百种组合。相反，他会给你看一个有所有选择的目录。您可以选择您想要的选项，工厂将根据您的规范构建一个选项。同样，测试注册表可以有很多小类，每个小类都知道如何构建一个完整的测试。小类的开销很低，所以即使有一千个对象也不会消耗太多内存。现在，当您想要运行测试N时，想象一下快速浏览目录(测试注册表)，直到您找到测试的图片，然后告诉工厂构建一个该类型的对象。 测试注册表需要一个从测试名称到对象的表(类似于上面的目录)。在8.10.1节中，这个表是一个TestBase句柄的关联数组，由一个字符串索引，如示例8.46所示。相反，如果您有一个参数化的类，它唯一的工作是构造一个测试，该怎么办?UVM使用一种称为代理类的设计模式，其唯一的作用是构建实际需要的类。proxy类是轻量级的，因为它只包含一些属性和方法，因此消耗的内存或CPU时间很少。它的作用类似于汽车经销商目录中的图片，保存着您可以构建的内容的表示。 接下来的几个代码示例展示了UVM类工厂是如何工作的。由于本书中的代码是真实的UVM类的简化版本，因此名称已更改为SVM, SystemVerilog Methodology，以便您不会将其与真实的东西混淆。希望您会发现这个简单工厂的解释比试图阅读UVM源代码更容易理解。 第一个是样例8.50，它有公共基类，其他所有东西都是从这个类构建的。它是一个抽象类，因为您永远都不应该构造这种类型的对象，而只应该构造从这个类型扩展而来的类。 样本8.50常见的支持向量机基类 接下来是示例8.51中的组件类。在UVM中，组件是形成testbench层次结构的耗时对象，类似于VMM事务处理程序。在这个简化的例子中，分层父句柄已经被移除。 示例8.51组件类 现在定义svm_object_wrapper，代理类的抽象公共基类，如示例8.52所示。它有纯虚方法来返回类类型的名称，并创建该类型的对象。 示例8.52代理类的公共基类 现在，对于示例8.53中显示的关键类svm_component_registry。这是一个轻量级的类，构造它的开销很小。它由测试类类型和名称参数化。一旦您有了这个类的实例，您的testbench可以在任何时候使用create_ object方法构造实际的测试类。这是一个单例类，因为您只需要一个副本就可以创建测试类的实例。在模拟开始时，通过调用get()方法初始化静态句柄me，该方法在需要时构造第一个实例。 示例8.53参数化代理类 最后一个主要类是svm_factory，它的核心只是一个包含数组m_type_names的单例类，用于从测试用例名转换到创建测试类实例的代理类。在示例8.54中的这个类中还有get_test方法，它从模拟运行命令行读取测试名，并构造测试类的一个实例。与示例8。46不同，您甚至可以进行一些自我检查。 示例8.54工厂类 最后是一个基本测试类，由示例8.55中所示的svm_component扩展而来。它使用宏svm_component_utils定义一个新的数据类型type_id，该数据类型指向代理类。宏对包含类名的标记T进行string化，并将其转换为包含T值的字符串，语法为:' \"T ' \"。 示例8.55基本测试类和注册宏 样本8.56测试程序 以下是使用命令行开关+SVM_TESTNAME=TestBase启动模拟时发生的步骤。 使用宏svm_component_utils，类TestBase基于类svm_component_registry定义type_id类型，参数为TestBase和\"TestBase\"。因为这是一种新类型，所以模拟器通过调用实例化类的get方法初始化静态变量svm_component_registry::me。这个实例在工厂中注册。这一切意味着什么?现在有了一个可以构造TestBase类的对象，您可以通过工厂访问它。 现在开始模拟，工厂的get_test方法从命令行读取测试名。此字符串用于注册中心的索引，以获取代理对象的句柄。这个对象的create_object方法构造了TestBase对象的一个实例。 程序调用测试对象的run_test方法，该方法调用特定类的步骤。现在，示例8.55中的TestBase类没有做任何有趣的事情，但是将对svm_component_utils宏的调用添加到示例8.47和示例8.49中的测试类中，您就可以运行测试了。 现在您可以看到启动测试的基本UVM流。注册表包含一个可以构造测试对象的代理类列表。 8.10.3 8.10.3 UVM工厂建立 UVM工厂也可以为testbench中的任何类构造对象 在示例8.53中创建方法。示例8.57展示了如何构建驱动程序。 示例8.57 UVM工厂构建示例 上面的代码调用静态方法create来构造驱动类型的对象。在UVM中，第二个参数指向正在创建的组件的父组件。 UVM工厂允许你覆盖组件，这样当你构建一个组件时，你就会得到一个扩展的组件。 您可能已经注意到术语上的变化。在经典的OOP中，根据句柄类型调用新方法来“构造”一个类，并将地址分配给赋值语句左侧的句柄。使用UVM工厂模式，您可以通过调用静态create方法来“构建”一个对象。这可以使对象具有与句柄相同的类型，或者扩展类型。 8.11. 结论 继承的软件概念，新的功能是添加到现有的类，平行的硬件实践扩展设计的特点，每一代，同时仍然保持向后兼容性。 例如，你可以通过增加更大容量的磁盘来升级你的电脑。只要它使用与旧的相同的界面，您不必替换系统的任何其他部分，但整体功能得到了改进。 同样，您可以通过“升级”现有的驱动程序类来创建一个新的测试，以注入错误。如果您在驱动程序中使用一个现有的回调，您就不必更改任何testbench基础设施。 如果您想要使用这些OOP技术，您需要提前计划。通过使用虚拟方法并提供足够的回调点，您的测试可以修改行为 在不改变其代码的情况下。其结果是一个健壮的测试平台，它不需要预测你可能想要的每种类型的干扰(错误注入、延迟、同步)，只要你留下一个钩子，测试就可以注入它自己的行为。 测试台比您以前构建的要复杂得多，但是它的回报是测试变得更小，更容易编写。测试台负责发送刺激和检查响应的艰苦工作，因此测试只需要做一些小的调整就可以产生专门的行为。额外的几行testbench代码可能会取代必须在每个测试中重复的代码。 最后，OOP技术允许重用类，从而提高了工作效率。例如，操作任何其他类(而不是单一类型)的堆栈的参数化类可以省去创建重复代码的麻烦。 8.12. 练习 给定下面的类，在扩展类ExtBinary中创建一个方法，将val1和val2相乘并返回一个整数。 从练习1的解决方案开始，使用ExtBinary类进行初始化 val1=15, val2=8，并打印出相乘的值。 从练习1的解决方案开始，创建一个扩展类Exercise3 这将约束val1和val2小于10。 从练习3的解决方案开始，使用Exercise3类进行随机化 val1和val2，并打印出相乘的值。 给定练习1中的类、下面的声明和扩展类ExtBinary，在执行每个代码片段a-d后，mc、mc2和b将指向什么，或者会发生编译错误吗? a. mc = new(15,8);b = mc; b = new(15, 8); mc = b; c - mc = new(15, 8);b = mc; mc2 = b; d. mc = new(15, 8);b = mc;如果美元投(mc2, b)) 显示美元(“成功”);其他的 显示美元(“错误:不能分配”); 给定练习1中的类Binary和Ext Binary以及以下类Binary的复制函数，创建函数Ext Binary::copy。 从解决方案到练习6，使用copy函数将扩展类句柄mc所指向的对象复制到扩展类句柄mc2。 使用文本8.7.1和8.7.2小节中的代码示例8.26到示例8.28，添加将事务随机延迟到0到100ns之间的能力。 创建一个可以使用大小写相等操作符比较任何数据类型的类， = = =和! = =。它包含一个compare函数，如果两个值匹配，则返回1，否则返回0。缺省情况下，比较两种4位数据类型。 使用练习9中的解决方案，使用comparator类来比较两个4位值expected_4bit和actual_4bit。接下来，比较color_t类型的两个值、expected_color和actual_color。如果发生错误，则递增错误计数器。 "},"articles/chapter-09.html":{"url":"articles/chapter-09.html","title":"第九章　　功能覆盖率","keywords":"","body":"第九章 功能覆盖 随着设计的复杂化，约束随机测试(CRT)是唯一有效的验证方法。这种方法使您摆脱了为设计中的每个特性编写单独的定向测试的单调乏味。然而，如果您的测试台在所有设计状态的空间中进行随机漫步，您如何知道您是否到达了目的地?即使是有指导的测试也应该对功能覆盖率进行双重检查。在一个项目的生命周期中，DUT的时间或功能上的微小变化可以微妙地改变定向测试的结果，因此它不再验证相同的特性。无论您使用的是随机dom还是定向刺激，您都可以使用覆盖率来评估进度。 功能覆盖率是测试执行了哪些设计特性的度量。从设计规范开始，并创建一个验证计划，其中包含要测试什么以及如何测试的详细列表。例如，如果您的设计连接到总线，则您的测试需要测试设计和总线之间所有可能的交互，包括相关的设计状态、延迟和错误模式。验证计划是一幅地图，它告诉你去哪里。有关创建验证计划的更多信息，请参见Bergeron(2006)。 在许多复杂的系统中，您可能永远不会达到100%的覆盖率，因为时间表不允许您达到每一个可能的极端情况。毕竟，您没有时间编写定向测试来获得足够的覆盖率，即使是CRT也受到创建和调试测试用例以及分析结果所需时间的限制。 图9.1显示了分析覆盖率结果并决定采取哪些行动以收敛于100%覆盖率的反馈循环。您的第一个选择是用更多的种子运行现有的测试;第二是建立新的约束条件。只有在绝对必要时才求助于创建定向测试。 当您专门编写定向测试时，验证计划是有限的。如果设计规范列出了100个特性，那么您所要做的就是编写100个测试。覆盖率在测试中是隐式的——“寄存器移动”测试来回移动寄存器的所有组合。度量进度很容易:如果您已经完成了50个测试，那么您已经完成了一半。本章使用“显式”和“隐式”来描述覆盖率是如何指定的。明确的覆盖范围 9.1. 约束的随机测试 导演testcase 最少的代码修改 图9.1覆盖收敛 9.2. 功能覆盖 直接在测试环境中使用SystemVerilog特性。隐式覆盖是由测试隐含的——当“register move”指向的测试通过时，您可能已经覆盖了所有的寄存器事务。 使用CRT，您不必手工制作每一行输入刺激，但现在您需要编写代码，根据验证计划跟踪测试的有效性。当您在更高的抽象级别上工作时，您仍然是更有效率的。您已经从调整单个部件转移到描述有趣的设计状态。达到100%的功能覆盖率会迫使您更多地思考您想要观察什么，以及如何将设计引导到这些状态。 9.3. 收集覆盖率数据 您可以反复运行相同的随机测试平台，只需更改随机种子以生成新的刺激。每个人的模拟产生一个数据库的功能覆盖信息，脚印的轨迹从随机行走。然后，您可以将所有这些信息合并在一起，使用功能覆盖率来度量您的总体进度，如图9.2所示。 然后您分析覆盖率数据，以决定如何修改您的测试。如果覆盖率水平稳步增长，您可能只需要用新的随机种子运行现有的测试，或者甚至只需要运行更长的测试。如果覆盖率的增长已经开始放缓，您可以添加额外的限制来产生更多“有趣的”刺激。当您到达一个平台期时，设计的某些部分没有得到执行，所以您需要创建更多的测试。最后，当你的功能覆盖率接近100%时，检查bug率。如果仍然发现bug，那么您可能没有对设计的某些领域进行真正的覆盖率度量。不要太急于达到100%的覆盖率，这只是表明你在所有常见的地方寻找漏洞。当你尝试着验证你的设计时，你可以在刺激空间中进行多次随机漫步;这可以产生许多意想不到的组合，如van der Schoot(2007)所示。 调试 设计 没有 覆盖数据库 通过吗? TTeessttss 是的 覆盖率分析 图9.2覆盖流 每个模拟供应商都有自己的存储覆盖率数据的格式，以及自己的分析工具。您需要使用这些工具执行以下操作。 用多个种子进行测试。对于一组给定的约束和覆盖组，将测试台编译并设计成一个单独的可执行文件。现在，您需要使用不同的随机种子反复运行这个约束集。您可以使用Unix系统时钟作为种子，但要小心，因为批处理系统可能会同时启动多个作业。这些作业可以在不同的服务器上运行，也可以在具有多个处理器的单个服务器上启动。因此，将所有这些价值结合起来，就能培育出真正独特的种子。为了保证种子的可重复性，必须保存模拟和覆盖结果。 检查通过/失败。功能覆盖信息只对成功的模拟有效。当由于设计错误而导致模拟失败时，必须丢弃覆盖年龄信息。覆盖率数据度量验证计划中有多少项已经完成，并且该计划基于设计规范。如果设计不符合规范，覆盖率值是无用的。一些验证团队定期地从头开始测量所有的功能覆盖率，以便它反映设计的当前状态。 跨多个运行分析覆盖率。随着时间的推移，您需要度量每个约束集的成功程度。如果你还没有在限制条件下的目标区域获得100%的覆盖率，但数量仍在增长，运行更多的种子。如果覆盖率水平已经趋于平稳，没有最近的进展，那么是时候修改约束条件了。只有当您认为达到一个特定部分的最后几个测试用例可能会花费太长时间来进行约束随机模拟时，您才应该考虑编写一个定向测试。即便如此，你也应该继续为设计的其他部分使用随机刺激，以防这种“背景噪音”发现漏洞。 9.覆盖类型 覆盖率是度量完成设计验证的进度的通用术语。当您试图覆盖所有合法组合时，您的模拟将慢慢地描绘出设计的画布。覆盖工具在模拟过程中收集信息，然后对其进行后处理以生成覆盖报告。您可以使用这个报告来寻找覆盖漏洞，然后修改现有的测试，或者创建新的测试来填补这些漏洞。这个迭代过程继续进行，直到您对覆盖级别感到满意为止。 9.3.1 代码覆盖率 度量验证进度的最简单方法是使用代码覆盖率。给你测量有多少行代码被执行(行覆盖率),通过代码路径和表达式被执行(路径覆盖),这一位变量的值0或1(切换覆盖),和一个状态机的状态和转换被访问(FSM)。您不需要编写任何额外的HDL代码。该工具通过分析源代码和添加隐藏代码来收集统计数据，自动地为你的设计提供工具。然后运行所有的测试，代码覆盖工具会创建一个数据库。 大多数模拟器都包含代码覆盖工具。后处理工具将数据库转换成可读的形式。最终结果是对您的测试在多大程度上执行了设计代码的度量。请注意，您主要关心的是分析设计代码，而不是测试台。未经测试的设计代码可能会隐藏硬件缺陷，或者可能只是冗余代码。 代码覆盖率衡量的是您的测试对设计规范的“实现”的执行程度，而不是验证计划。仅仅因为您的测试达到了100%的代码覆盖率，您的工作就没有完成。如果你犯了一个测试没有发现的错误怎么办?更糟糕的是，如果您的实现缺少一个特性怎么办?示例9.1中的模块是用于d触发器的。你能看出错误吗? 样例9.1缺失路径的不完整d触发器模型 重置逻辑被意外地遗漏了。一个代码覆盖工具会报告每一行都被执行了，但是模型没有被正确地实现。回到描述重置行为的功能规范，并确保您的验证计划包括验证这一点的需求。然后在复位期间收集设计的功能覆盖期信息。 9.3.2 功能覆盖 验证的目标是确保设计在其真实环境(MP3播放器、网络路由器或手机)中正确运行。设计说明书详细说明了设备应该如何操作，而验证计划则列出了如何刺激、验证和测量该功能。当您收集关于所覆盖功能的度量时，您正在执行“设计”覆盖。例如，d触发器的验证计划不仅会提到它的数据存储，还会提到它如何重置到已知状态。在您的测试检查这两个设计特性之前，您不会有100%的功能覆盖率。 功能覆盖率与设计意图相联系，有时称为“规范覆盖率”，而代码覆盖率则度量您对RTL代码的测试情况，称为“实现覆盖率”。“这是两种截然不同的指标。考虑一下，如果设计中缺少代码块会发生什么情况。代码覆盖率不能捕获这个错误，并且可以报告您已经执行了100%的行，但是功能覆盖率将显示功能不存在。 9.3.3 虫率 测量覆盖率的一种间接方法是看新bug被发现的速率，如图9.3所示。在项目的整个生命周期中，您应该跟踪每周发现的bug数量。在一开始，当您创建测试工作台时，您可能会通过检查发现许多bug。在阅读设计规范时，您可能会发现不一致之处，希望在编写RTL之前解决这些问题。一旦测试平台启动并运行，当你检查系统中的每个模块时，就会发现大量的bug。随着设计接近尾声，bug率下降，有望降至零。然而，您还没有完成。每当比率下降时，就需要找到不同的方法来创建极端情况。 图9.3项目期间的Bug率 根据许多因素，例如项目阶段、最近的设计更改、正在集成的模块、人员更改，甚至假期计划，每周的bug率都会有所不同。汇率的意外变化可能是潜在问题的信号。 如图9.3所示，即使在设计完成后，甚至在设计交付给客户后，仍然不断地发现bug是很常见的。 9.3.4 断言的报道 断言是一段声明性代码，用于检查设计信号之间的关系，可以是一次，也可以是一段时间。这些可以通过设计和测试工作台进行模拟，或者通过正式的工具进行验证。有时，您可以使用SystemVerilog过程代码编写等价的检查，但是使用SystemVerilog断言(SVA)更容易表示许多断言。 断言可以有局部变量并执行简单的数据检查。如果您需要检查一个更复杂的协议，例如确定一个包是否成功地完全通过路由器，过程代码通常更适合这项工作。在程序编码或使用SVA的序列之间有很大的重叠。参见Vijayaraghavan和Ramanadhan (2005)， Cohen等人(2005)，以及VMM书中的第3章和第7章，Bergeron等人(2006)，以获得关于SVA的更多信息。 最常见的断言查找错误，比如两个互斥的信号，或者一个请求从来没有被授予。这些错误检查应在检测到问题时立即停止模拟。断言还可以检查仲裁算法、fifo和其他硬件。它们是用assert属性语句编码的。 有些断言可能会查找感兴趣的信号值或设计状态，例如成功的总线事务。这些都是用cover属性语句编码的。您可以通过使用asser- tion覆盖来度量这些断言在测试期间被触发的频率。覆盖属性观察信号序列，而覆盖组(如下所述)在模拟过程中采样数据值和事务。这两个构造重叠，因为在序列完成时可以触发覆盖组。此外，序列可以收集覆盖组可以使用的信息。 9.4. 功能覆盖策略 在编写第一行测试代码之前，您需要预测哪些是关键的设计特性、边界用例和可能的故障模式。这就是您如何编写验证计划。不要只从数据值的角度考虑问题;相反，要考虑设计中编码了哪些信息。这个计划应该说明重要的设计状态。 9.4.1 收集信息，而不是数据 一个经典的例子是FIFO。如何确定已经彻底测试了1K的FIFO内存?你可以测量读和写索引中的值， 但是有超过一百万种可能的组合。即使您能够模拟那么多周期，您也不会想要阅读覆盖率报告。 在更抽象的级别上，FIFO可以保存0到N-1个可能的值。那么，如果您只是比较读和写索引，以衡量FIFO有多满或有多空呢?你仍然有1K的保险值。如果您的测试工作台将100个条目推入FIFO，然后再推入100个，您真的需要知道FIFO是否曾经有150个值吗?只要能成功读出所有的值就行。FIFO的边角情况是满的和空的。如果你可以让FIFO从空(重置后的状态)到满，再回到空，你就覆盖了所有的关卡。其他有趣的状态还包括通过时的指数 在所有1和所有0之间。这些案例的覆盖报告很容易理解。 您可能已经注意到，有趣的状态与FIFO大小无关。同样，要看信息，而不是数据值。 具有大范围(超过几十个可能的值)的设计信号应该被分解为更小的范围，再加上边缘情况。例如，你的DUT可能有一个32位的地址总线，但是你当然不需要收集40亿个样本。检查自然分区，如内存和IO空间。对于计数器，选择一些有趣的值，并始终尝试将计数器值从所有的1回滚到0。 9.4.2 只衡量你将要使用的东西 收集功能覆盖率数据是很昂贵的，所以只测量您将分析和使用来改进您的测试的数据。当模拟器监控信号的功能覆盖时，您的模拟可能运行得更慢，但是这种方法比收集波形轨迹和测量代码覆盖的开销更低。模拟完成后，数据库被保存到磁盘。使用多个测试用例和多个种子，您可以用功能覆盖数据和报告填充磁盘驱动器。但是，如果您从来没有查看过最终的覆盖报告，那么就不要执行最初的度量。 有几种方法可以控制覆盖数据:在编译、实例化或触发时。您可以使用模拟供应商提供的开关、条件编译或抑制覆盖率数据的收集。最后一个是不太理想的，因为后处理报告充满了覆盖率为0%的部分，这使得找到少数启用的部分变得更加困难。 9.4.3 测量完整性 就像家庭度假时，你的孩子坐在后座上，你的经理不断地问你:“我们到了吗?”“你怎么知道你已经对设计进行了全面测试?您需要查看所有的覆盖率度量，并考虑bug率，以确定您是否到达了目的地。 在项目开始时，代码和功能覆盖率都很低。在您开发测试时，使用不同的随机种子反复运行它们，直到您不再看到功能覆盖率的增加值。创建额外的约束和 探索新领域的测试。保存高覆盖率的测试/种子组合，这样您就可以在回归测试中使用它们。 图9.4覆盖率比较 低 高 代码覆盖率 如果功能覆盖率很高，但是代码覆盖率很低，如图9.4左上角所示，该怎么办?您的测试没有执行完整的设计，可能来自一个不充分的验证计划。也许是时候回到硬件规范并更新您的验证计划了。然后您需要添加更多的功能覆盖点来定位未测试的功能。 更困难的情况是代码覆盖率高，但功能覆盖率低。即使你的测试台给设计一个很好的锻炼，你也不能把它放在所有有趣的状态。首先，查看设计是否实现了所有指定的功能。如果它存在，但是您的测试无法达到它，您可能需要一个正式的验证工具，可以提取设计的状态并创建适当的刺激。 目标是提高代码覆盖率和功能覆盖率。然而，先不要计划你的假期。感染率的趋势是什么?仍然会出现重大的bug吗?更糟糕的是，它们是被故意发现的，还是您的测试平台偶然发现了一个没有人预料到的状态的特定组合?另一方面，低bug率可能意味着你现有的策略已经失去了动力，你应该寻找不同的方法。尝试不同的方法 比如设计块和错误生成器的新组合。 9.5. 简单的功能覆盖示例 为了测量功能覆盖率，您从验证计划开始，并为模拟编写一个可执行版本。在您的系统Verilog testbench中，采样变量和表达式的值。这些样本点被称为掩蔽点。同时采样的多个覆盖点(例如在事务完成时)被放在一个覆盖组中。 样例9.2有一个事务，有8种形式。testbench随机生成dst变量，验证计划要求尝试每个值。 示例9.2简单对象的函数覆盖 样例9.2创建一个随机事务并将其驱动到接口。testbench使用CovDst2覆盖组采样dst字段的值。8个可能的值，32个随机事务——你的testbench生成了它们吗?示例9.3和示例9.4包含了来自VCS的部分覆盖率报告。由于随机性的存在，每个模拟器都会给出不同的结果。 如您所见，testbench生成的dst值为1、2、3、4、5、6和7，但从未生成0。“至少”列指定需要多少次命中才能认为一个容器被覆盖。关于at_least选项，请参阅9.10.3节。 为了提高功能覆盖率，最简单的策略是运行更多的模拟周期，或者尝试新的随机种子。在示例9.2中，下一个随机事务(#33)的dst值为0，覆盖率为100%。或者，如果您使用不同的种子开始模拟，那么对于这种简单的情况，您可能在更少的事务中达到100%。在一个真正的设计中，你可能会看到覆盖的停滞期 覆盖点越来越多，但有一些顽固的点永远不会被击中，不管你跑了多长时间，不管种子价值如何。在这种情况下，您可能必须尝试一种新的策略，因为测试工作台没有创建适当的刺激。任何报道报告中最重要的部分都是没有命中的点。 示例9.3一个简单对象的覆盖率报告 示例9.4简单对象的覆盖率报告，100%覆盖率 本书对如何计算覆盖率给出了一个粗略的解释。LRM在四页中对覆盖率计算进行了非常详细的解释，在整个章节中有更多的细节。请查阅它以获得最准确的细节。 9.6. 封面组的剖析 覆盖组类似于类——定义它一次，然后实例化它一次或多次。它包含覆盖点、选项、正式参数和可选触发器。一个覆盖组包含一个或多个数据点，所有数据点都是同时配置的。 您应该创建非常清晰的覆盖组名称，明确表示您所度量的内容，如果可能的话，参考验证计划。Parity_ Errors_In_Hexaword_Cache_Fills这个名称可能看起来有些冗长，但是当您试图读取包含几十个覆盖组的覆盖率报告时，您将会欣赏这些额外的细节。您还可以使用comment选项来获得额外的描述性信息，如9.9.2节所示。 覆盖组可以在类或程序或模块级别定义。它可以采样任何可见变量，如程序/模块变量，接口信号，或设计中的任何信号(使用层次引用)。类中的封面组可以抽样该类中的变量，也可以抽样嵌入对象中的数据值。 不要在数据类(如事务)中定义覆盖组，因为这样做会在收集覆盖年龄数据时造成额外的开销。想象一下，你正试图追踪酒吧里顾客喝了多少啤酒。你会试着跟着每一瓶酒从装货区流过，越过吧台，进入每一瓶吗 儿子吗?不，相反，你可以让每位顾客检查啤酒的种类和数量，如van der Schoot(2006)所示。 在SystemVerilog中，您应该在适当的抽象级别定义覆盖组。这个级别可以位于测试台和设计之间的边界，在读写数据的事务中，在环境配置类中，或者在任何需要的地方。任何交易的抽样必须等待到DUT实际接收到它。如果您在事务的中间注入了一个错误，导致它在传输中被中止，那么您需要更改处理它的方式，以实现功能覆盖。您需要使用仅为错误处理而创建的另一个掩蔽点。 一个类可以包含多个覆盖组。这种方法允许您拥有可以根据需要启用和禁用的单独组。此外，每个组可能有一个单独的触发器，允许您从许多源收集数据。 封面组必须实例化以收集数据。如果您忘记了，那么在运行时不会打印关于空句柄的错误消息，但是覆盖率报告将不会包含任何提到覆盖组的内容。该规则适用于定义在类内部或外部的覆盖组。 9.6.1 在类中定义覆盖组 覆盖组可以在程序、模块或类中定义。在任何情况下，都必须显式实例化它以开始抽样。如果封面组在类中定义，则称为嵌入式封面组。在这种情况下，在构造它时不使用单独的名称;用原来的封面组名就行了。必须在类的构造函数中构造嵌入式覆盖组，这与可以在任何时候构造的非嵌入式覆盖组相反。 样例9.5与本章的第一个样例非常相似，只是它在一个事务处理类中嵌入了一个覆盖组，因此不需要单独的实例名。 样例9.5类中的函数覆盖率 9.7. 触发一个掩护组 功能覆盖的两个主要部分是被采样的数据值和被采样的时间。当有新的值准备好时(比如事务完成时)，您的testbench会触发覆盖组。这可以直接通过示例函数完成，如示例9.5中所示，或者通过在covergroup定义中使用覆盖率事件。覆盖事件可以使用@来阻塞信号或事件。 如果您希望从过程代码显式地触发覆盖率，如果没有任何现有信号或事件告诉您何时进行采样，或者一个覆盖组有多个实例单独触发，则使用sample。 如果您希望利用现有的事件或信号来触发覆盖率，请使用covergroup声明中的覆盖率事件。 9.7.1 使用回调采样 将功能覆盖集成到您的测试台中更好的方法之一是使用回调，正如最初在8.7节中所示。这种技术允许您构建一个灵活的测试平台，而不限制何时收集覆盖率。您可以决定验证计划中的每个点在什么地方和什么时候采样值。如果你需要一个额外的“钩子”在环境中回调，你总是可以以一种不显眼的方式添加一个，因为回调只会在测试注册回调对象的模拟过程中“触发”。您可以为每个覆盖组创建许多单独的回调，而开销很小。如8.7.4节所述，回调优于使用邮箱将testbench连接到coverage对象。您可能需要多个邮箱来从测试台上的不同位置收集事务。邮箱需要一个事务处理程序来接收事务，而多个邮箱会导致您在多个线程之间来回切换。使用被动回调代替主动事务处理。 示例8.26 - 8.28显示了一个驱动程序类，它有两个回调点，分别在事务传输之前和之后。样例8.26显示了基本回调类，样例8.28有一个带有扩展回调类的测试，它将数据发送到记分板。使用基本回调类Driver_cbs的自己的扩展Driver_cbs_coverage来调用post_tx中覆盖组的示例任务。将覆盖回调类的实例推入驱动程序的回调队列中，您的覆盖代码会在正确的时间触发覆盖组。示例9.6和9.7定义并使用回调Driver_cbs_coverage。 UVM建议通过监视DUT来收集覆盖，并通过分析端口(类似于邮箱)将事务发送到覆盖组件。 示例9.7函数覆盖的回调 9.7.2 包含用户定义的样例参数列表的覆盖组 在样例9.5中，封面组在类内部定义的事务对象中示例了一个变量。如果封面组是在类的外部定义的，则可以通过定义自己的参数列表通过sample方法传递变量。现在您可以从testbench中的任何地方采样变量。 在示例9.8中，覆盖组也被扩展为覆盖低数据位。run方法的最后一条语句将传递目标地址和高速模式的配置变量。 样例9.8定义样例方法的参数列表 9.7.3 用事件触发器覆盖组 在示例9.9中，当testbench触发时，对CovDst9覆盖组进行采样 trans_ready事件。 样本9.9带有触发器的覆盖组 与直接调用示例方法相比，使用事件的优点是您可以使用现有的事件，例如由断言触发的事件，如示例9.11所示。 9.7.4 在系统Verilog断言上触发 如果您已经有一个寻找有用事件(如完整事务)的SVA，那么您可以添加一个事件触发器来唤醒覆盖组，如9.10所示。 带有SystemVerilog断言的示例9.10模块 9。11样本触发了一个有安全措施的掩护组 9.8. 数据采集 如何收集覆盖信息?当您在覆盖点中指定一个变量或表达式时，SystemVerilog会创建许多“bins”来记录每个值被看到的次数。这些箱子是衡量功能覆盖率的基本单位。如果对一个位变量进行取样，则最多创建两个bins。您可以想象，每当覆盖组被触发时，System Verilog都会在一个或另一个bin中丢弃一个令牌。在每次模拟结束时，都会创建一个数据库，其中包含所有带有令牌的bins。然后运行一个分析工具，它读取所有数据库，并生成一个包含设计的每个部分的覆盖率和总覆盖率的报告。 9.8.1 单个垃圾箱和全部覆盖 要计算一个点的覆盖范围，首先必须确定可能值的总数，也称为域。每个容器可以有一个值，也可以有多个值 值。覆盖率是采样值的数量除以域中的容器数量。 掩蔽点是一个3位变量，其域为0:7，通常被分为8个箱。如果在模拟过程中，对属于7个箱子的值进行抽样，报告将显示7/8或87.5%的覆盖率。所有这些点结合起来显示整个组的覆盖率，然后所有组结合起来给出所有模拟数据库的覆盖率百分比。 这是单个模拟的状态。您需要随着时间的推移跟踪覆盖率。查找趋势，以便查看在何处运行更多模拟或添加新的约束或测试。现在，您可以更好地预测何时完成设计的验证。 9.8.2 自动创建垃圾箱 正如您在示例9.3的报告中看到的，System Verilog自动为掩蔽点创建箱子。它查看采样表达式的域，以确定可能值的范围。对于N位宽的表达式，有2N个可能的值。对于3位变量dst，有8个可能的值。枚举类型的范围见9.6.8节。枚举数据类型的域是命名值的数目。您还可以像9.6.5节中那样显式地定义bins。 9.8.3 限制自动垃圾箱创建的数量 封面组选项auto_bin_max指定要自动创建的最大垃圾箱数量，默认为64个垃圾箱。如果覆盖点变量或表达式中的值域大于此选项，System Verilog将该范围划分为auto_bin_max bins。例如，一个16位变量有65,536个可能的值，因此64个bin中每个bin包含1024个值。 在现实中，您可能会发现这种方法不切实际，因为很难在一堆自动生成的箱子中找到缺失覆盖的针。将这个限制降低到8或16，或者更好的是，如章节9.6.5所示显式地定义bins。 示例9.12采用了本章的第一个示例，并添加了一个覆盖点选项，将auto_bin_max设置为两个箱子。被采样的变量仍然是dst，对于一个有8个可能值的域，dst是3位宽的。第一个容器存放范围的下半部分，即0-3，另一个存放范围的上半部分，即4-7。 示例9.12使用auto_bin_max设置为2 来自VCS的覆盖率报告显示了这两个区域。这个模拟实现了100%的覆盖率，因为8个dst值被映射到两个箱子。由于两个箱子都有采样值，你的覆盖率是100%，如示例9.13所示。 示例9.13 auto_bin_max设置为2的报告 示例9.12仅使用auto_bin_max作为覆盖点的选项。您还可以使用它作为整个组的选项，如示例9.14所示。 示例9.14对所有覆盖点使用auto_bin_max 9.8.4 抽样表达式 您可以对表达式进行示例，但总是要检查覆盖率报告，以确保您获得了您期望的值。您可能需要调整计算表达式的宽度，如2.16节所示。例如，采样3位报头长度(0:7)加上4位有效载荷长度(0:15)只创建24或16个垃圾箱，这可能不够，如果你的事务实际上可以从0到22字节长。 示例9.15在掩蔽点中使用表达式 示例9.15有一个采样总包长度的覆盖组。封面点有一个标签，使它更容易阅读封面报告。此外，表达式有一个额外的虚拟常量，因此事务长度以5位精度计算，对于最多32个自动生成的bins。 对随机数据包的长期运行表明，len16的覆盖率为100%，但这只覆盖了16个垃圾箱。(cover point只有16个bin，因为在Verilog中3位和4位的值之和只有4位。)掩护点len32在32个垃圾桶中有72%的覆盖率。(将5位值加到bin32的表达式中会得到5位结果。)这两个覆盖点都不正确，因为最大长度的范围是0:22(0+0:7+15)。自动生成的垃圾箱不能工作，因为最大长度不是2的幂。您需要一种精确定义箱子的方法。 9.8.5 用户定义的垃圾箱发现一个Bug 自动生成的bins可以用于匿名数据值，例如计数器值、地址或2的幂值。对于其他值，您应该显式地命名箱子，以提高准确性并简化覆盖率报告分析。System Verilog自动为枚举类型创建bin名称，但对于其他变量，您需要为感兴趣的状态命名。指定bins最简单的方法是使用[]语法，如示例9.16所示。 样例9.16为事务长度定义bins 在抽样许多随机事务后，该组的覆盖率为95.83%。快速浏览一下示例9.17中的报告就会发现这个问题——23(17十六进制)的长度从未出现过。最长的头部是7，最长的有效载荷是15，总共是22，不是23!如果您将bins声明更改为使用0:22，覆盖率将跳转到100%。用户定义的垃圾箱在测试中发现了一个错误。 示例9.17事务长度的覆盖报告 9.8.6 命名盖点箱 示例9.18对一个4位变量kind进行了采样，该变量有16个可能的值。第一个箱子被称为零，并计算这种类型在抽样时为0的次数。接下来的4个值(1-3和5)都被分组到一个单独的容器中，即lo。hi_8、hi_9、hi_a、hi_b、hi_c、hi_d、hi_e、hi_f分别放在8个桶中。注意hi bin表达式中的$是如何用作所采样变量的最大值的速记符号的。最后，misc保存所有之前没有选择的值:4、6和7。 示例9.18指定bin名称 注意，关于coverpoint的额外信息是用花括号:{}分组的。这是因为bin规范是声明性代码，而不是按begin…end分组的程序代码。最后，最后的花括号后面没有分号，就像结尾一样。 现在您可以很容易地在示例9.19中看到哪些垃圾箱没有命中-在本例中是hi_8。 示例9.19显示bin名称的报告 当您定义箱子时，您将限制用于覆盖率的值为您感兴趣的那些。SystemVerilog不再自动创建箱子，它将忽略不属于预定义箱子的值。更重要的是，只有您创建的箱子才用于计算函数覆盖率。你得到100%的覆盖率，只有当你得到命中在每个指定的垃圾箱。 不属于任何指定bin的值将被忽略。如果采样值(如事务长度)不是2的幂，则此规则很有用。如果您正在指定bin，您可以使用默认的bin指示符来捕获您可能已经忘记的值。然而，LRM说在覆盖率计算中不使用默认垃圾箱。 在示例9.18中，hi的范围使用右边的美元符号($)来指定上限。这是一个非常有用的快捷方式-现在你可以让编译器计算 一个范围的限制。您可以使用范围左侧的美元符号来指定下限。在示例9.20中，bin neg的范围内的$表示距离0最远的负数:32h8000_0000，或-2,147,483,648，而bin pos中的$表示最大的正数，32 ' h7fff_ffff，或2,147,483,647。 示例9.20使用$指定范围 9.8.7 条件覆盖 您可以使用iff关键字为掩蔽点添加条件。这样做的最常见的原因是在复位期间关闭覆盖，这样杂散触发器就会被忽略。样例9.21只在rst为0时采集dst值，其中rst为active-high。 9.21条件覆盖-在重置期间禁用 另外，您还可以使用start和stop函数来控制覆盖组的单个实例，如示例9.22所示。 示例9.22使用stop和start函数 9.8.8 为枚举类型创建箱子 对于枚举类型，SystemVerilog为每个值创建一个bin，如示例9.23中所示。 示例9.23枚举类型的函数覆盖 下面是来自VCS的覆盖率报告的一部分，示例9.24显示了枚举类型的箱子。 示例9.24包含枚举类型的覆盖率报告 如果想将多个值分组到一个容器中，就必须定义自己的容器。除非使用默认说明符定义一个bin，否则枚举值之外的任何bin都将被忽略。当您收集枚举类型的覆盖率时，auto_bin_max不适用。 9.8.9 过渡覆盖 您可以为掩蔽点指定状态转换。这样，您不仅可以知道看到了哪些有趣的值，还可以知道这些序列。例如，您可以检查dst是否从0到1、2或3，如示例9.25中所示。 样例9.25为覆盖点指定转换 您可以使用范围快速指定多个转换。表达式(1,2 = > 3, 4)创建了四个转换(1 = > 3)(1 = > 4)(2 = > 3)和(2 = > 4)。 您可以指定任何长度的转换。注意，您必须对转换中的每个状态采样一次。所以(0 => 1 => 2)和(0 => 1 => 1 => 2)是不同的。 或者(0 => 1 => 1 => 1 => 2).如果你需要重复值，如在最后一个序列中，你可以使用简写形式:(0 => 1[*3]=> 2).如果要将值1重复3、4或5次，使用1[*3:5]。 9.8.10 通配符状态和转换 您可以使用通配符关键字创建多个状态和转换。任意X Z或?在表达式中被视为0或1的通配符。示例9.26创建了一个掩蔽点，该掩蔽点带有一个存放偶数值和一个存放奇数值的容器。 示例9.26用于掩护点的通配符箱 9.8.11 忽视价值观 对于一些掩蔽点，你永远不会得到所有可能的值。例如，一个3位变量可以仅存储6个值，即0-5。如果您使用自动创建的箱子，您永远不会超过75%的覆盖率。有两种方法可以解决这个问题。您可以显式地定义您想要覆盖的箱子，如9.6.5节所示。另外，您可以让SystemVerilog自动创建bins，然后使用ignore_bins来告诉哪些值应该从函数覆盖计算中排除，就像示例9.27中那样。 示例9.27覆盖点与ignore_bins 原来的3位变量low_ports_0_5的范围是0:7。ignore_ bins排除了最后两个bins，这将范围缩小到0:5。所以这一组的总覆盖率是有样本的箱数，除以总箱数，这里是5。 示例9.28覆盖点与自动bin max和忽略垃圾箱 如果显式或使用auto_bin_max选项定义垃圾箱，然后忽略它们，被忽略的垃圾箱不会对覆盖率的计算产生影响。在示例9.28中，最初使用auto_bin_max选项创建了四个垃圾箱:0:1、2:3、4:5和6:7。然而，最上面的垃圾箱被ignore_bins删除，所以最后只创建了三个垃圾箱。这个覆盖点可以覆盖0%，33%，66%，或100%。 9.8.12 非法的垃圾箱 一些采样值不仅应该被忽略，而且如果看到它们也应该导致错误。这最好在testbench的监视器代码中完成，但也可以通过使用illegal_bins标记bin来完成，如示例9.29所示。使用它来捕获测试的错误检查错过的状态。这也会双重检查你的bin创建的准确性:如果一个非法的值被覆盖组发现，这是testbench或者你的bin定义的问题。 示例9.29使用illegal_bins的覆盖点 9.8.13 状态机的报道 您应该注意到，如果在状态机上使用了覆盖组，那么您可以使用bins来列出特定的状态，以及弧的转换。然而，这并不意味着您应该使用SystemVerilog的功能覆盖率来度量状态机覆盖率。你必须手动提取状态和弧线。即使您第一次正确地执行了此操作，您也可能会错过将来对设计代码的更改。相反，使用代码覆盖工具自动提取状态寄存器、状态和弧，避免可能的错误。 然而，一个自动工具准确地提取信息编码，错误和所有。您可能希望使用功能覆盖手动监视小型、关键的状态机。 9.9. 交叉覆盖 覆盖点记录单个变量或表达式的观测值。您可能不仅想知道发生了什么总线事务，还想知道在这些事务期间发生了什么错误，以及它们的源和目标。为此，您需要交叉覆盖来度量同时在两个或多个覆盖点上看到的值。请注意，当您测量一个具有N个值的变量和另一个具有M个值的变量的交叉覆盖时，SystemVerilog需要NM个交叉箱来存储所有的组合。 9.9.1 基本交叉覆盖例子 前面的示例已经测量了事务类型和目标端口号的覆盖范围，但是将两者结合起来又如何呢?你在每个港口都试过各种交易了吗?SystemVerilog中的交叉构造记录一组中两个或多个覆盖点的组合值。交叉语句只接受覆盖点或简单的变量名。如果您想在对象中使用表达式、层次名称或变量(如handle)。变量时，必须首先在带有标签的coverpoint中指定表达式，然后在cross语句中使用标签。 样例9.30为tr.kind和tr.dst创建覆盖点。然后将这两点交叉表示所有的组合。SystemVerilog总共创建128个箱子(8个16)。注意:即使是简单的交叉也会导致大量的垃圾箱。 样本9.30基本交叉覆盖 一个随机测试平台创建了56个事务，并生成了示例9.31中的覆盖率报告。注意，即使所有可能的种类和dst值都产生了，也只有1/3的杂交组合被看到。这是一个非常典型的结果。还要注意，集团的总覆盖范围是交叉覆盖加上覆盖年龄和dst。 示例9.31基本交叉覆盖的覆盖摘要报告 9.9.2 标记交叉覆盖箱 如果您想要更易于阅读的交叉覆盖bin名称，您可以像示例9.32中所演示的那样标记单个覆盖点bin，并且SystemVerilog在创建交叉bin时将使用这些名称。 示例9.32指定交叉覆盖的bin名称 如果您定义了包含多个值的箱子，覆盖率统计信息就会改变。在下面的报告中，垃圾箱的数量已从128个减少到80个。这是因为kind有10个bins: 0、lo、hi_8、hi_9、9hi_a、hi_b、hi_c、hi_d、hi_e和hi_f。请记住，使用默认值定义其值的misc bin不会添加到覆盖总数中。覆盖率的百分比从87.5%跃升到90.91%，如示例9.33所示，因为罗仓中的任何单个值，如2，允许将该仓标记为covered，即使没有看到其他值，如1或3。 带有标签箱的交叉覆盖报告 9.9.3 不包括交叉覆盖箱 要减少垃圾箱的数量，请使用ignore_bins。使用交叉覆盖，您可以使用binsof指定覆盖点，使用intersect指定一组值，这样一个ignore_bins构造可以清除许多单独的bins。 样品9.34不包括交叉覆盖的箱子 示例9.34中的第一个ignore_bins只是排除了dst为7和任何kind值的bins。由于kind是一个4位值，因此该语句排除了12个bins，因为misc的值4-7不计算，因为是默认值。第二个ignore_bins选择性更强，忽略dst为0和kind为9、10或11的bins，总共有3个bins。ignore_bins可以使用在各个覆盖点中定义的bins。ignore_bins lo使用bin名称来排除kind。这是1 2 3。垃圾箱必须是在编译时定义的名称，比如0和lo。hi_8, hi_9, hi_a，…hi_f和任何自动生成的bins都没有可以在编译时在其他语句中使用的名称，例如ignore_bins;这些名字是 在运行时或报告生成期间创建。 注意，binsof使用了圆括号()，而intersect指定了一个范围，因此使用了花括号{}。 9.9.4 从总覆盖度量中排除覆盖点 一个组的总覆盖范围基于所有简单覆盖点和交叉覆盖。如果仅对要在交叉语句中使用的coverpoint中的变量或表达式进行抽样，则应该将其权重设置为0，这样它就不会对总覆盖率产生影响。 样品9.35指定交叉覆盖权重 有两种类型的选项:特定于covergroup实例的选项，以及为整个covergroup类型指定选项的选项。特定于实例的选项类似于局部变量，使用option关键字指定，如option中所示。示例9.12中的auto_bin_max=2。备选项是用type_option关键字指定的，并且与封面组绑定，就像类中的静态变量一样。在示例9.35中，type_option。权重应用于此组的所有实例。LRM详细解释了它们之间的区别，本书展示了最常见的选项及其用法。 9.9.5 合并来自多个域的数据 交叉覆盖的一个问题是，您可能需要从不同的定时域采样值。您可能想知道您的处理器是否在缓存填充过程中收到过中断。中断硬件与缓存硬件是分开的，并且可能使用不同的时钟，这使得很难知道什么时候触发覆盖组。另一方面，你要确保你已经测试过这种情况，因为以前的设计有这种类型的错误。 解决方案是创建一个独立于缓存或中断硬件的定时域。将信号复制到临时变量中，然后将它们抽样到一个新的覆盖组中，以衡量交叉覆盖。 9.9.6 交叉覆盖的替代品 当你的交叉覆盖定义变得更加详细时，你可能会花费相当多的时间来指定哪些箱子应该被使用，哪些应该被忽略。你可能有两个随机的位a和b，它们有三种有趣的状态，{a==0, b==0}， {a==1, b==0}， {b==1}。 示例9.36展示了如何在覆盖点中命名容器，然后使用这些容器收集交叉覆盖。 示例9.36使用bin名称的交叉覆盖 示例9.37收集了相同的交叉覆盖，但是现在使用binof来指定交叉覆盖值。 样品9.37箱交叉覆盖 或者，您可以制作一个覆盖点，对值的连接进行示例。 然后，您只需使用不那么复杂的覆盖点语法定义bins。 示例9.38使用连接模拟交叉覆盖 如果您已经为单个覆盖点定义了容器，并且想要使用它们来构建交叉覆盖容器，请使用示例9.36中的样式。如果您需要构建交叉覆盖箱，但没有预定义的覆盖点箱，请使用示例9.37。如果您想要tersest格式，请使用示例9.38。 9.10. 一般覆盖组 当你开始写封面组的时候，你会发现有些是非常相似的。SystemVerilog允许您创建一个通用的覆盖组，以便在实例化它时可以指定一些惟一的详细信息。 9.10.1 按值传递覆盖组参数 示例9.39显示了一个使用参数将范围分成两部分的封面组。只需将中点值传递给覆盖组的新函数。 示例9.39 Covergroup，带有简单参数 9.10.2 通过引用传递覆盖组参数 您可以指定一个变量，通过引用传递进行采样。这里，您希望覆盖组在整个模拟过程中对值进行采样，而不仅仅是在调用构造函数时使用值。 9.40示例引用传递 像任务或函数一样，覆盖组的参数具有粘性方向。在9.40样例中，如果你忘记了输入方向-，mid参数将有ref方向。这个例子无法编译，因为你不能将常量(4或2)传入ref参数。 9.11. 覆盖选项 您可以使用选项在封面组中指定其他信息。有两种类型的选项:应用于特定封面组实例的实例选项和应用于封面组所有实例的类型选项，它们类似于类的静态数据成员。选项可以放在盖组，使他们适用于所有盖点在组，或他们可以放在一个单一的盖点，以更好的控制。您已经看到了auto_bin_max和weight选项。这里还有几个。 9.11.1 每个覆盖 如果您的testbench多次实例化一个覆盖组，默认情况下System- Verilog将所有实例中的覆盖数据组在一起。然而,如果你 有几个生成器，每个生成器创建非常不同的事务流，您将需要看到单独的报告。例如，一个生成器可能创建长事务，而另一个生成器创建短事务。示例9.41中的覆盖组可以在每个单独的生成器中实例化。它跟踪每个实例的覆盖范围，并拥有一个唯一的注释字符串，其中包含覆盖组实例的层次路径。 示例9.41指定每个实例的覆盖率 每个实例选项只能在覆盖组中给出，而不能在覆盖点或交叉点中给出。 9.11.2 覆盖集团发表评论 您可以向覆盖率报告中添加注释，使它们更容易分析。注释可以像从验证计划到报表解析器用于自动从大量数据中提取相关信息的标记的区号那样简单。如果您有一个只实例化一次的覆盖组，请使用type_选项，如示例9.42所示。 样例9.42为封面组指定注释 但是，如果您有多个实例，您可以给每个实例单独的注释，只要您还使用示例9.43中所示的per-instance选项。 样例9.43为覆盖组实例指定注释 9.11.3 报道阈值 对于设计，您可能没有足够的可见性来收集健壮的覆盖率信息。假设您正在验证DMA状态机是否可以处理总线错误。您不能访问它的当前状态，但是您知道传输所需的周期范围。所以如果你在这个范围内重复地造成错误，你可能已经覆盖了所有的状态。所以你可以设置选项。at_least to 8 or more指定在一个容器上命中8次后，您就确信您已经执行了该组合。 如果您定义选项。至少在覆盖组水平上，它适用于所有覆盖点。如果你在一个点内定义它，它只适用于这个点。 然而，正如样本9.2所示，即使在32次尝试之后，随机变量仍然没有达到所有可能的值。因此，只有在没有直接测量覆盖率的方法时才使用at_least，比如当测试台不能探测DUT细节时。 9.11.4 打印空箱子 默认情况下，覆盖率报告只显示带有示例的箱子。您的工作是验证验证计划中列出的所有内容，因此您实际上对没有示例的容器更感兴趣。使用选项cross_num_print_missing来告诉模拟和报告工具向您显示所有箱子，特别是没有击中的箱子。将其设置为一个较大的值，如示例9.44中所示，但不要大于您愿意读取的值。 报告所有箱子，包括空箱子 9.11.5 覆盖目标 覆盖组或点的目标是该组或点被认为完全覆盖的水平。默认的覆盖率是100%。如果你把这个级别设置为低于9.45样例中的100%，你要求的覆盖率低于完全覆盖，这可能是不可取的。此选项仅影响覆盖率报告。 示例9.45指定覆盖目标 9.12. 分析覆盖率数据 一般来说，假设你需要更多的种子和更少的约束。毕竟，运行更多的测试比构造新的约束更容易。如果不小心，新的约束很容易限制搜索空间。 如果你的掩蔽点只有0个或一个样本，你的约束可能根本就没有针对这些区域。您需要添加约束，将解算器“拉”到新的领域。在示例9.16中，事务长度分布不均匀。示例9.46显示了完整的类。这种情况类似于掷两个骰子并查看总价值时所看到的分布。 示例9.46包长度的原始类 这个类的问题是len的权重不均匀。看看覆盖率报告，注意到低值和高值是如何很少被触及的。图9.5是来自报告的值的图表。 160 140 120 One hundred. 80 60 40 20. 0 0 5 10 15 20. 25 包长度 图9.5数据包长度的不均匀概率 如果你想让总长度均匀分布，使用solve…之前 约束如图9.47所示，并绘制在图9.6中。 示例9.47在包长度约束之前解决 120 One hundred. 80 60 40 20. 0 0 5 10 15 20. 25 包长度 图9.6之前求解…时数据包长度的偶概率 之前解决…的常规选择是dist约束。然而，这行不通，因为len也受到两个长度之和的限制。 9.13. 在模拟过程中测量覆盖率统计 您可以在模拟过程中实时查询功能覆盖级别。这允许您检查您是否达到了您的覆盖目标，并且可能控制一个随机测试。 在全球范围内，您可以获得所有覆盖群体的总覆盖率 $get_coverage，它返回一个介于0之间的实数。和100年。这个系统任务检查所有覆盖组。 您可以使用get_coverage()和get_ inst_coverage()方法来缩小度量范围。第一个函数使用覆盖组名和实例，以覆盖覆盖覆盖组的所有实例，例如CoverGroup::get_coverage()或cginst1 .get_coverage()。第二个函数返回特定覆盖组实例的覆盖率，例如cgInst。get_inst_coverage()。您需要指定option。如果您想收集每个实例的覆盖率，则per_instance=1。 这些函数的最实际用途是在长期测试中监视覆盖率。如果覆盖级别在给定数量的事务或周期之后没有提高，那么测试应该停止。希望，另一个种子或测试将增加覆盖率。 虽然有一个能够根据功能覆盖结果执行一些复杂操作的测试是很好的，但是编写这类测试是非常困难的。每个测试+随机种子对可能会发现新的功能，但可能需要多次运行才能达到一个目标。如果一个测试发现它没有达到100%的覆盖率，它应该做什么?跑更多的周期?有多少?它是否应该改变所产生的刺激?如何将输入中的更改与功能覆盖级别关联起来?一个可靠的改变是随机种子，你应该在每次模拟中只做一次。否则，如果刺激依赖于多个随机种子，你如何重现设计漏洞? 如果您想创建自己的覆盖率数据库，您可以查询功能覆盖率统计信息。验证团队已经建立了他们自己的SQL数据库，这些数据库提供了来自模拟的功能覆盖数据。这种设置允许他们更好地控制数据，但需要在创建测试之外进行大量的工作。 一些正式的验证工具可以提取设计的状态，然后创建输入刺激以达到所有可能的状态。不要试图在你的测试台上复制这个! 9.14. 结论 当您从编写直接测试(手工制作每个刺激点)转换到受限随机测试时，您可能会担心测试不再受您的控制。通过度量覆盖率，特别是功能覆盖率，您可以通过了解哪些特性已被测试而重新获得控制权。 使用功能覆盖需要详细的验证计划和大量时间来创建覆盖组、分析结果和修改测试以创建适当的刺激。这可能看起来工作量很大，但比编写等效的定向测试所需要的工作量要少。此外，收集覆盖率所花费的时间可以帮助您更好地跟踪验证设计的进展。 9.15. 练习 对于下面的类，编写一个covergroup来收集测试计划需求的覆盖率，“必须测试所有ALU操作码”。“假设操作码在信号clk的正边缘有效。 将解决方案扩展到练习1，以覆盖测试计划需求，“Operand1应取最大值为负(−128)、零和最大值为正(127)。”为每一个值定义一个覆盖箱以及一个默认箱。将coverpoint标记为operand1_cp。 将解决方案扩展到练习2，以涵盖以下测试计划需求: “操作码应该采用ADD或SUB值”(提示:这是一个覆盖bin)。 “操作码应该采用添加的值和SUB的值”(提示:这是第二个覆盖bin)。 标记coverpoint opcode_cp。 将解决方案扩展到练习3，以覆盖测试计划需求，“Opcode必须不等于DIV”(提示:使用illegal_bins报告错误)。 将解决方案扩展到练习4，以收集测试计划需求的覆盖范围，“当operand1是最大的负值或最大的正值时，opcode应采用ADD或SUB值。“将交叉覆盖率加权为5。 假设你的covergroup被称为Covcode，并且covergroup的实例化名是ck，将练习4展开到: 显示由实例名称引用的coverpoint operand1_cp的覆盖范围。 显示由covergroup名称引用的coverpoint opcode_cp的覆盖范围。 "},"articles/chapter-10.html":{"url":"articles/chapter-10.html","title":"第十章　　高级接口","keywords":"","body":"第十章高级接口 在第4章中，您学习了如何将设计和测试工作台与接口连接起来。这些物理接口代表真实信号，类似于Verilog-1995中连接端口的电线。测试工作台通过端口静态地连接到这些接口。然而，对于许多设计，测试台需要动态地连接到设计。 例如，在一个网络交换机中，一个单一的驱动类可以连接到许多接口，每个接口对应于DUT的每个输入通道。你不需要为每个通道编写唯一的驱动程序——相反，你需要编写一个通用的驱动程序，实例化它N次，并让它连接到N个物理接口。在SystemVerilog中，可以通过使用虚拟接口来实现这一点，虚拟接口仅仅是物理接口的句柄或指针。虚拟接口更好的名称是“ref接口”。 您可能需要编写一个附加到您的设计的几种不同配置的测试平台。在另一个例子中，芯片可以具有多种配置。在一个，引脚可能驱动一个USB总线，然而在另一个相同的引脚可能驱动一个I2C串行总线。同样，您可以使用一个虚拟接口，这样您就可以在运行时决定在您的测试台中运行哪些驱动程序。 SystemVerilog接口不仅仅是信号——您可以在其中放入可执行代码。这可能包括读取和写入接口的例程、在接口内部运行代码的初始化和总是阻塞，以及不断检查信号状态的断言。但是，不要把testbench代码放在一个接口中。如SystemVerilog LRM所述，程序块是专门为构建测试平台而创建的，包括在反应区域中调度它们的执行。 10.1. 与ATM路由器的虚拟接口 虚拟接口最常见的用途是允许testbench中的对象使用通用句柄而不是实际名称引用复制接口中的项。虚拟接口是唯一能够将对象的动态世界与模块和接口的静态世界连接起来的机制。 10.1.1 只有物理接口的测试平台 第4章展示了如何建立一个接口来连接4x4 ATM路由器到一个测试工作台。示例10.1和10.2展示了接收和发送方向的ATM接口。 示例10.1 Rx接口与时钟块 带时钟块的10.2 Tx接口示例 这些接口可以在示例10.3中所示的程序块中使用。这个过程代码是用接口名(如Rx0和Tx0)硬编码的。注意，在这些示例中，top模块没有将时钟传递给testbench;相反，测试与接口中的时钟块同步，从而允许您在更高的抽象级别上工作。 示例10.3使用物理接口的Testbench 图10.1显示了测试台通过虚拟接口与设计通信。 Testbenchd0处方 Txm0d1d24 x4 ATM路由器m1平方米d3m3 前 图10.1带接口的路由器和测试台 顶级模块必须连接一系列接口才能在样例10.6中使用testbench。示例10.4中的模块实例化了一个接口数组，并将这个数组传递给testbench。因为DUT是用四个RX和四个TX接口编写的，所以需要将各个接口数组元素传递到DUT实例中。 示例10.4带有接口数组的顶级模块 10.1.2 带有虚拟接口的测试平台 一种好的OOP技术是创建一个使用句柄来引用对象的类，而不是使用硬编码的对象名称。在这种情况下，您可以创建单个驱动程序类和单个监视器类，让它们对数据的句柄进行操作，然后在运行时传递句柄。 与示例10.3一样，示例10.5中的程序块仍然将4个Rx和4个Tx接口作为端口传递，但它创建了一个虚拟接口数组vRx和vTx。这些现在可以传递到驱动程序和监视器的构造函数中。 示例10.5使用虚拟接口的Testbench 您也可以跳过虚拟接口数组变量，在端口列表中创建一个数组。这些接口被传递给构造函数，如示例10.6所示。 示例10.6使用虚拟接口的Testbench 示例10.7中的任务monitor::receive_cell与示例10.3中的任务receive_cell0相似，不同之处是它使用了虚拟接口名称Tx而不是物理接口Tx0。 示例10.7使用虚拟接口的监视类 在创建一个testbench时，一个常见的错误是在虚拟接口声明中忽略modport名称。示例10.5中的程序声明了Tx_if。TB Tx0在端口列表中，所以它只能将Tx0分配给用TB modport声明的虚拟接口。请参阅示例10.7中虚拟接口Tx的声明。 10.1.3 连接Testbench到端口列表中的接口 这本书展示了连接到DUT的端口列表中的接口的测试。这种风格对于总是使用端口中的信号连接模块的Verilog用户来说很舒服。示例10.8是顶级模块，也称为测试工具，它使用端口列表中的接口连接DUT和测试。 示例10.8使用端口列表中的接口测试线束 示例10.9显示了端口列表中带有接口的程序块。 示例10.9使用端口列表中的接口进行测试 如果在设计中添加新的接口会发生什么?示例10.10中的测试工具声明了新总线，并将其放入端口列表中。 示例10.10 Top模块，在测试的端口列表中有第二个接口 现在，您必须更改示例10.9中的测试，以在端口列表中包含另一个接口，以提供示例10.11中的测试。 示例10.11使用端口列表中的两个接口进行测试 向您的设计添加一个新的接口意味着您需要编辑所有现有的测试，以便它们可以插入到测试工具中。你怎样才能避免这项额外的工作呢?避免端口连接! 10.1.4 将测试连接到使用XMR的接口 您的测试需要连接到harness中的物理接口，因此使用交叉模块引用(XMR)和程序块中的虚拟接口，如示例10.12所示。您必须使用虚拟接口，这样才能在顶层模块中为它分配物理接口。 示例10.12使用虚拟接口和XMR测试 程序连接到示例10.13中所示的测试束。 示例10.13测试端口列表中没有接口的线束 VMM等方法推荐使用这种方法，以使测试代码更具可重用性。如果您向您的设计中添加一个新的接口，如示例10.14所示，那么测试管理将发生变化，但是现有的测试不必改变。 示例10.14使用第二个接口测试线束 样例10.14中的管理与样例10.12中的不知道新接口的测试以及样例10.15中的知道新接口的测试一起工作。 示例10.15使用两个虚拟接口和XMRs进行测试 有些方法有一个规则，使测试和利用之间的连接比传统端口稍微复杂一些，但这意味着即使设计发生变化，您也不必修改现有的测试。本书中的例子使用了端口列表中接口的简单风格，但您应该决定测试重用是否重要到足以改变您的编码风格。 10.2. 连接到多个设计配置 验证设计的一个常见挑战是它可能有几种配置。您可以为每个配置创建一个单独的测试平台，但是当您探索每个替代方案时，这可能会导致组合爆炸。相反，您可以使用虚拟接口动态连接到可选接口。 10.2.1 网的设计 示例10.16是由一个简单的复制组件，一个8位计数器构建的。这类似于DUT, DUT有一个设备，如网络芯片或处理器，在mesh配置中重复实例化。关键思想是，顶层模块创建一个接口和计数器数组。现在，testbench可以将其虚拟接口阵列连接到物理接口。 示例10.16显示了计数器接口X_if的代码。如果代码使用$monitor打印信号值，那么当信号发生变化时就会显示这些值。相反，always块等待直到时钟块改变，然后用$strobe在时间槽的末尾打印信号的值。结果是您现在在更高的抽象级别上工作，看到的是一个周期一个周期的值，而不是单个事件。 示例10.16 8位计数器接口 示例10.17中显示了一个简单的计数器。 示例10.17使用X_if接口的计数器模型 示例10.18中的顶级模块使用generate语句进行实例化 NUM_XI接口和计数器，但只有一个测试台。 示例10.18顶级模块，包含一个虚拟接口数组 在示例10.19中，testbench中的关键行是本地虚拟接口数组vxi被分配到指向顶层模块top.xi中的物理接口数组的地方。(注意，这个例子采用了一些捷径 第8章的建议。为了简化示例10.18，环境类已经与测试合并，而生成器、代理和驱动程序层已经压缩到驱动程序中。) 测试台假设至少有一个计数器，因此至少有一个X接口。如果设计的计数器为零，则必须使用动态数组来保存虚拟接口，因为固定大小的数组的大小不能为零。接口的实际数量作为参数从顶级模块传递。 样例10.19使用虚拟接口Counter testbench 当然，在这个简单的例子中，您可以直接将接口传递到驱动程序的构造函数中，而不是单独创建一个变量。 在示例10.20中，驱动程序类使用单个虚拟接口来驱动和采样计数器的信号。 示例10.20使用虚拟接口的驱动程序类 使用类型定义和虚拟接口 您可以通过替换\" virtual X_if \"来减少输入量，并确保始终使用正确的mod- port。TB”，使用接口、测试工作台和驱动程序的类型定义，如示例10.21到10.23所示。 示例10.21带有类型定义的接口 示例10.22 Testbench为虚拟接口使用typedef 示例10.23为虚拟接口使用typedef的驱动程序 10.2.2 使用端口传递虚拟接口阵列 前面的示例使用跨模块引用(XMR)传递虚拟接口数组。另一种方法是在端口中传递数组。由于顶部模块中的数组是静态的，所以只需要引用一次，因此XMR样式比使用通常用于传递更改值的端口更有意义。 示例10.24使用一个全局参数定义X个接口的数量。下面是top模块的一个片段。 使用虚拟接口数组的示例10.24 Testbench 示例10.25显示了使用虚拟接口的测试平台。它创建了一个虚拟接口数组，这样就可以将它们传递到驱动程序类的构造函数中，或者直接从端口传递接口。 样例10.25 Testbench通过带端口的虚拟接口 10.3. 参数化接口和虚拟接口 10.2节中的例子显示了一个8位计数器和匹配总线。如果你想改变柜台的宽度怎么办?Verilog-1995允许您参数化模块，并且系统Verilog通过参数化接口和虚拟接口扩展了这个概念。 首先，使用参数更新计数器(最初在示例10.17中显示)。这只需要更改前几行。样例10.26现在也将接口的编号作为参数传入。 示例10.26使用X_if接口的参数化计数器模型 接下来，示例10.27将位宽参数添加到示例10.16中的接口。 示例10.27 8位计数器的参数化接口 示例10.28显示了传递到testbench的参数。 示例10.28使用虚拟接口数组的参数化顶层模块 最后是testbench模块和驱动程序类，如示例10.29和10.30所示。这些虚拟接口必须参数化。的语法 这有点棘手，特别是当你有modport的时候。首先，从示例10.19更新的testbench。注意参数是如何在类型名和modport之间传递的。 样例10.29使用虚拟接口的参数化计数器testbench 示例10.30使用虚拟接口的驱动程序类 10.4. 接口中的过程代码 正如一个类既包含变量又包含例程一样，一个接口也可以包含例程、断言、初始块和always块等代码。回想一下，接口包括两个块之间通信的信号和功能。因此，总线的接口块可以包含信号和执行命令(如读或写)的例程。这些例程的内部工作对外部块是隐藏的，允许您推迟实际的实现。对这些例程的访问是使用modport语句控制的，就像信号一样。一个任务或函数被导入到modport中，这样它就可以被任何使用modport的block看到。 这些例程可以被设计和测试工作台使用。这种方法 确保两者使用相同的协议，消除测试工作台错误的共同来源。然而，并不是所有的合成工具都能处理接口中的例程。 在设计团队和测试团队之间共享代码的一个问题是，设计团队和验证团队之间的独立性丧失了。如果只有一个人实现了两部分的接口协议，谁来检查它? 您可以在接口中使用断言来验证协议。断言可以检查非法的组合，例如违反协议和未知值。它们可以显示状态信息并立即停止模拟，以便您可以轻松调试问题。当好的事务发生时，也可以触发断言。功能覆盖代码使用这种类型的断言来触发覆盖平均信息的收集。 10.4.1 并行协议接口 在创建系统时，您可能不知道是选择并行协议还是串行协议。示例10.31中的接口有两个任务，initiatorSend和targetRcv，它们使用接口信号在两个块之间发送事务。它通过两个8位总线并行地发送地址和数据。 示例10.31接口与任务并行协议 10.4.2 串行协议接口 示例10.32中的接口实现了发送和接收地址和数据值的串行接口。它具有与示例10.31相同的接口和例程名称，因此您可以在这两者之间进行交换，而不必更改任何设计或testbench代码。 示例10.32串行协议任务接口 10.4.3 接口代码的限制 接口中的任务对于RTL来说很好，因为RTL的功能是严格定义的。然而，对于任何类型的验证IP来说，这些任务都不是一个好的选择。接口及其代码不能基于配置进行扩展、重载或动态实例化。接口不能有私有数据。验证需要的任何代码 最大的灵活性和可配置性，因此应该使用在程序块中运行的类。 10.5. 结论 SystemVerilog中的接口构造提供了一种强大的技术，可以将块之间通信的连接性、计时和功能组合在一起。在本章中，您看到了如何创建一个连接到包含多个接口的许多不同设计配置的单个测试台。您的信号层代码可以在运行时通过虚拟接口连接到数量可变的物理接口。此外，接口可以有驱动信号和断言检查协议的例程，但将测试放在程序块中，而不是接口中。 在许多方面，接口可以类似于具有指针、封装和抽象的类。这使您可以创建一个接口，在比Verilog的传统端口和连接更高的级别上为系统建模。只需记住将testbench保存在program块中。 10.6. 练习 如注释所示，完成以下代码。 使用练习1的解决方案，按照注释的指示完成下面的代码。 修改下面的程序声明以使用跨模块引用(XMR)。假设包含接口的顶层模块名为top。 修改下面程序测试的实例化以使用跨模块引用(XMR)。 将解决方案扩展到练习3，创建NUM_RISC_BUS环境并创建NUM_RISC_BUS接口。 将解决方案扩展到练习3，为虚拟接口使用typedef。 修改下面的接口以使用一个参数ADDRESS_WIDTH。缺省情况下，寻址空间支持256个字。 "},"articles/chapter-11.html":{"url":"articles/chapter-11.html","title":"第十一章　一个完整的Testbench","keywords":"","body":"第11章 一个完整的SystemVerilog测试台 本章应用您所学到的有关SystemVerilog特性的许多概念来验证设计。testbench创建有约束的随机刺激，并收集功能覆盖。它的结构根据第8章的指导方针，所以你可以注入新的行为，而不需要修改低级块。 Sutherland[2006]所展示的设计是一个ATM交换机，他的SystemVerilog描述基于Janick Bergeron的验证协会的一个例子。Sutherland采用最初的Verilog设计，并使用SystemVerilog设计特性创建了一个可以从4×4配置到16×16的交换机。原始示例中的testbench使用$urandom创建ATM单元格，用ID值覆盖某些字段，通过设备发送它们，然后检查是否收到了相同的值。 整个示例，包括testbench和ATM交换机，可以从http://chris.spear.net/systemverilog下载。本章只展示了testbench代码。 11.1. 设计模块 图11.1所示的设计与试验台的整体连接遵循第四章的模式。 Testbench输入 设计 输出在测试 图11.1试验台设计环境 设计的顶层称为深蹲，如图11.2所示。模块有1..N个发送UNI格式的cell的Utopia Rx接口。在DUT内部，单元被存储，转换成NNI格式，并转发到Tx接口。转发是根据用传入单元的VPI字段寻址的查找表来完成的。该表通过管理接口进行编程。 图11.2深蹲设计方框图 示例11.1中的顶级模块为Rx和Tx端口定义了接口数组。 示例11.1顶级模块 示例11.2中的testbench程序通过端口列表传递接口和信号。关于端口与跨模块参考的讨论，请参阅第10.1.4节。实际的testbench代码在Environment类中。该程序通过环境的各个阶段。为了在更高的抽象级别上工作，testbench只使用接口中的时钟块与DUT同步，而不使用低级别时钟。 示例11.2 Testbench程序 testbench通过管理接口(也称为CPU接口)将控制信息加载到ATM交换机中，如示例11.3所示。在本章的示例中，该接口仅用于加载将VPI映射到转发掩码的查找表。 示例11.3 CPU管理接口 示例11.4展示了Utopia的接口，该接口通过发送和接收ATM小区与蹲式设计通信。该接口具有发送和接收路径的时钟块，以及用于设计和测试工作台连接到该接口的modports。 样本11.4乌托邦界面 11.2. Testbench块 环境类，如8.2.1节所示，是支持testbench结构的脚手架。在这个类中有您的分层测试工作台块，例如生成器、驱动程序、监视器和记分板。该环境还控制四个testbench步骤的顺序:生成随机配置、构建testbench环境、运行测试并等待测试完成，以及关闭系统并生成报告的收尾阶段。样例11.5显示了ATM环境类。它使用示例11.3中定义的虚拟接口vCPU_T。 示例11.5环境类头 使用$test$plusargs()系统任务，示例11.6中的环境类构造函数查找VCS switch +ntb_random_seed，它为模拟设置随机种子。系统任务$value$plusargs()从交换机中提取值。你的模拟器可能有不同的方式设置种子。在日志文件中打印种子是很重要的，这样如果测试失败，您就可以用相同的值再次运行它。 示例11.6环境类方法 样例11.6中构建的方法Environment::使用回调类将记分板连接到驱动程序和监视器，如样例11.7中的Scb_Driver_cbs所示。这个类将期望的值发送到记分板。基本驱动程序回调类Driver_cbs在示例11.20中显示。 示例11.7回调类连接驱动程序和记分牌 示例11.8中的回调类Scb_Monitor_cbs将监视器与记分板连接起来。基本监视器回调类Monitor_cbs在示例11.21中显示。 示例11.8回调类连接监视器和计分板 环境通过最后的回调类Cov_Monitor_cbs将监视器连接到覆盖率类，如示例11.9所示。 示例11.9回调类连接监视器和覆盖率 示例11.10显示了随机配置类头。它从nCells开始，这是一个用来表示流经系统的细胞总数的随机值。约束c_nCells_valid通过大于0来确保有效的单元格数，而c_nCells_reasonable将测试限制为合理的大小，即1000个单元格。如果您想要更长的测试，可以禁用或重写它。 接下来是一个动态位数组，in_use_Rx，用来指定进入交换机的哪个Rx通道是活动的。样例11.6在run方法中使用此方法，以便只运行活动通道。 数组cells_per_chan用于在活动通道上随机划分单元的总数。约束zero_unused_channels将非活动通道的单元格数设置为0。为了帮助求解器，在通道间划分单元之前，先解决了活动通道掩码。否则，一个通道只有在分配给它的细胞数为零时才会是不活动的，这是非常不可能的。 示例11.10环境配置类 单元重写和转发配置类型如示例11.11所示。 示例11.11单元配置类型 configuration类的方法如示例11.12所示 示例11.12配置类方法 ATM交换机接受UNI格式的单元格并发送NNI格式的单元格。这些单元通过OOP测试平台和结构设计发送，因此使用typedef定义它们。这两种格式的主要区别是，UNI的GFC和VPI字段合并到NNI的VPI中。示例11.13到11.15中的定义来自Sutherland[2006]。 样本11.13 UNI cell格式 示例11.14 NNI单元格格式 UNI和NNI单元与字节内存合并，形成一个通用类型，见示例11.15。 样品11.15 ATMCellType testbench生成受约束的随机ATM单元，如示例11.16所示，它是从示例8.24中定义的BaseTr类扩展而来的。 示例11.16 UNI_cell定义 示例11.17显示了单元的方法。 示例11.17 UNI_cell方法 NNI_cell类几乎与UNI_cell相同，除了它没有GFC字段，也没有转换为UNI_cell的方法。 示例11.18展示了UNI cells随机原子发生器，如最初在8.2节中所示。生成器随机化单元的蓝图实例，然后将单元的副本发送给驱动程序。 示例11.18 UNI_generator类 示例11.19显示了将UNI单元发送到ATM交换机的驱动程序类。这个类使用了示例11.20中的驱动程序回调。注意这里有一个循环关系。驱动程序类有一个Driver_cbs对象队列，Driver_cbs中的pre_tx()和post_tx()方法被传递给驱动程序对象。当你编译这两个类时，你可能需要其中一个类型定义类驱动;在驱动_cbs类定义之前，或者定义类型驱动_cbs类之前;在驱动类定义之前。 示例11.19驱动程序类 示例11.20显示了驱动程序回调类，它具有简单的回调，在传输单元之前和之后调用。该类有默认使用的空任务。测试用例可以扩展这个类，在驱动中注入新的行为，而不需要改变驱动中的任何代码 示例11.20驱动程序回调类 示例11.21中的Monitor类有一个非常简单的回调，在接收到单元格后只调用一个任务。 示例11.21监视回调类 示例11.22显示了Monitor类。像驱动程序类一样，这个类使用 类型定义以打破与Monitor_cbs的循环编译依赖关系。 示例11.22 Monitor类 示例11.23中的计分板通过save_expected函数从驱动程序获得预期的单元格，并通过check_actual函数由监视器实际接收到单元格。函数save_expected()从回调Scb_Driver_cbs::post_tx()调用，如示例11.7所示。在示例11.8中，函数check_actual()从Scb_Monitor_cbs::post_rx()调用。 示例11.23记分牌类 示例11.24显示了用于收集函数覆盖率的类。由于cov- average只查看单个类中的数据，覆盖组是在Coverage类中定义和实例化的。数据值由类的sample()方法读取，然后调用封面组的sample()方法来记录这些值。 示例11.24功能覆盖类 样例11.25展示了包含驱动CPU接口的方法的CPU_driver类。 示例11.25 CPU_driver类 11.3. 替代测试 示例11.2显示了最简单的测试程序，并在很少的约束下运行。在验证期间，您将创建许多测试，这取决于要测试的主要功能。然后可以用不同的种子运行每个测试。 11.3.1 你的第一个测试，只有一个细胞 您运行的第一个测试可能只有一个单元格，例如Sample中的测试 11.26。您可以通过扩展Config类来添加新的约束，然后 在随机化之前向环境中注入一个新对象。一旦测试成功，您可以尝试两个单元格，然后重写对单元格数量的约束以运行更长的序列。 样品11.26用一个细胞测试 11.3.2 随机细胞下降 您可能会运行的下一个测试通过偶尔删除单元格来创建错误，如示例11.27所示。你需要为设置下降位的驱动程序做回调。然后，在测试中，在构建阶段构建驱动程序类之后注入这个新功能。 示例11.27使用驱动回调删除单元格的测试 11.4. 结论 本章将向您展示如何按照本书的指导原则构建一个分层测试平台。然后，只需修改单个文件并注入新的行为，就可以创建新的测试，利用回调等钩子和多个环境阶段。 testbench能够达到ATM交换机100%的功能覆盖率，至少对于基本覆盖组来说是这样。您可以使用这个示例来研究更多关于SystemVerilog testbench的内容。 11.5. 练习 1. 在示例11.2中，为什么clk没有被传入程序测试的端口列表? 2. 在示例11.6中，可以用numRx替换Rx.size()吗?为什么或为什么不? 3. 对于下面的示例11.6中的代码片段，解释为每个语句创建了什么。 在示例11.9中，句柄cov指向什么覆盖对象? 在示例11.17中，函数UNI_cell::copy假设对象UNI_cell的句柄指向一个类UNI_cell的对象，如下图所示。为下面的函数调用绘制dst句柄所指向的对象。 处理 副本(); 复制(处理); 在示例11.18中，为什么需要$cast () ? 在样例11.19和11.20中，为什么需要typedef声明? 在示例11.19中，为什么先使用peek()，然后再使用get()? 在示例11.23中，错误信息是\"…cell not found…\"在函数中每次调用时都打印check_actual ?为什么或为什么不? 为什么类环境，记分牌，和CPU_driver都定义一个句柄类配置?是否创建了类配置的3个对象? "},"articles/chapter-12.html":{"url":"articles/chapter-12.html","title":"第十二章　与C/C++的接口","keywords":"","body":"第十二章 C/C++ 接口 在Verilog中，您可以使用编程语言接口与C例程通信。随着三代的PLI: TF(任务/功能)，ACC(访问)，和VPI(验证程序接口)，您可以创建延迟计算器，连接和同步多个模拟器，并添加调试工具，如波形显示。然而，PLI最大的优点也是它最大的缺点。如果您只是想使用PLI连接一个简单的C例程，您需要编写几十行代码，并理解许多不同的概念，如与多个模拟阶段同步、调用帧和实例指针。此外，为了保护Verilog数据结构不受破坏，PLI在Verilog和C域之间复制数据时给模拟增加了开销。 SystemVerilog引入了直接编程接口(DPI)，这是一种与C、c++或任何其他外语进行接口的更简单的方法。使用import语句声明或“导入”C例程之后，就可以像调用任何SystemVerilog例程一样调用它。此外，您的C代码可以调用SystemVerilog例程。通过DPI，您可以连接读取刺激、包含参考模型或仅用新功能扩展SystemVerilog的C代码。目前SystemVerilog只支持到C语言的接口。c++代码必须包装成C语言的样子。 如果您有一个不消耗时间的SystemC模型，并且希望连接到SystemVerilog，那么您可以使用DPI。使用耗时方法的SystemC模型最好与内置在您最喜欢的模拟器中的实用程序连接。 上半年,本章以数据为中心,展示了如何通过不同的数据类型SystemVerilog和C .下半年之间控制中心,展示——荷兰国际集团(ing)如何通过控制之间来回SystemVerilog和C,而实际的C代码很简单,阶乘函数,斐波纳契数列,计数器,他们很容易理解,这样你就可以很快替代自己的代码。 12.1. 通过简单的值 本章的前几个例子向您展示了如何在SystemVerilog和C之间传递整型值，以及如何声明例程及其参数的机制。后面的部分将展示如何传递数组和结构。 12.1.1 传递整数和实数值 SystemVerilog和C之间可以传递的最基本数据类型是int，即2状态32位类型。示例12.1展示了SystemVerilog代码，该代码调用了一个C阶乘例程，如示例12.2所示。 示例12.1 SystemVerilog代码调用C阶乘例程 import语句声明SystemVerilog例程的阶乘是用外国语言(如c)实现的。修饰符“DPI-C”指定这是一个直接编程接口例程，语句的其余部分描述例程参数。 示例12.1使用直接映射到C int类型的SystemVerilog int数据类型传递32位带符号的值。SystemVerilog int总是32位，而C中int的宽度取决于操作系统。示例12.2中的C函数接受一个整数作为输入，因此DPI按值传递参数。 示例12.2 C factorial函数 12.1.2 进口申报 import声明定义了C任务或函数的原型，但使用的是SystemVerilog类型。带返回值的C函数被映射到SystemVerilog 函数。void C函数可以映射到SystemVerilog任务或void函数。如果导入的C函数的名称与SystemVerilog名称冲突，则可以使用新名称导入该函数。在示例12.3中，C函数expect被映射到SystemVerilog名称fexpect，因为名称expect是SystemVerilog中的保留关键字。名称expect成为一个全局符号，用于与C代码链接，而fexpect是一个本地SystemVerilog符号。在本例的后半部分中，C函数stat在SystemVerilog中被赋予一个新名称file_exists。SystemVerilog不支持重载例程，例如，一次使用真实参数导入expect，另一次使用int。 样例12.3修改导入函数的名称 可以在SystemVerilog代码中的任何地方导入例程，在这些地方可以声明例程，包括程序内部、模块、接口、包和$unit(编译单元空间)。导入的例程将是声明它的声明空间的本地例程。如果您需要在代码中的几个位置调用导入例程，请将import语句放在需要导入的包中。对import语句的任何更改都本地化到包中。 12.1.3 参数的方向 导入的C例程可以有零个或多个参数。默认情况下，参数方向是输入(数据从SystemVerilog到C)，但也可以是输出和inout。不支持方向ref。函数可以返回一个简单的值，比如一个整数或实数，也可以不返回任何值。样例12.4展示了如何指定参数方向。 示例12.4参数指示 您可以通过将任何输入参数声明为const(如示例12.5中所示)来减少在C代码中出现错误的机会，这样C编译器就会为任何对输入的写操作给出一个错误。 带有const参数的阶乘例程 12.1.4 参数类型 通过DPI传递的每个变量都有两个匹配的定义:一个用于SystemVerilog端，一个用于C端。使用兼容类型是您的责任。SystemVerilog模拟器无法比较类型，因为它无法读取C代码。(VCS编译器会生成vc_hdrs.h，而Questa会为你导入的任何例程创建包含C头的include .h。你可以使用这个文件作为匹配类型的指南。) 表12.1显示了SystemVerilog与C例程的输入和输出之间的数据类型映射。C结构在包含文件svdpi.h中定义。数组映射将在第12.4节和第12.5节讨论，结构将在第12.6节讨论。 表12.1 SystemVerilog和C的数据类型映射 SystemVerilogC(输入)C(输出)字节字符char *shortint短整型短int *intintint *longint长长的int长int *shortreal浮动浮*真正的双双*字符串const char *char * *string [N]const char * *char * *位svBit或unsigned charsvBit*或unsigned char*逻辑,注册svLogic或unsigned charsvLogic*或unsigned char*位(N: 0)const svBitVecVal *svBitVecVal *注册(N: 0)逻辑(N: 0)const svLogicVecVal *svLogicVecVal *无浆[]数组const svOpenArrayHandlesvOpenArrayHandlechandleconst void *void * 注意，有些映射是不精确的。例如，SystemVerilog中的一个位映射到C中的svBit，它最终映射到svdpi.h包含文件中的unsigned char。因此，您可能会将非法的值写入上位。 LRM限制导入函数的结果为“小值”，包括:void、byte、shortint、int、longint、real、shortreal、chandle和string，以及bit和logic类型的单个位值。函数不能返回像bit[6:0]这样的向量，因为这需要返回指向svBitVecVal结构体的指针。 12.1.5 导入数学库例程 样例12.6展示了如何在不使用C包装器的情况下直接调用C math库中的许多函数，从而减少了需要编写的代码量。Verilog真实类型映射到C double类型。 样例12.6导入C数学函数 12.2. 连接到一个简单的C例程 您的C代码可能包含一个模拟模型，比如一个处理器，它与Verilog模型一起实例化。或者，您的代码可以是一个参考模型，在事务或周期级别与Verilog模型进行比较。本章的许多考试展示了用C或c++编写的7位计数器。尽管计数器非常简单，但它具有与复杂模型相同的部分，包括输入、输出、调用之间的内部值存储，以及需要支持多个实例。计数器为7位，用于显示硬件类型与C类型不匹配时发生的情况。 12.2.1 具有静态存储器的计数器 示例12.7是一个7位计数器的C代码。计数存储在一个静态变量中，就像您在考虑模拟之前编写模型时所做的那样。 示例12.7计数器例程使用静态变量 reset和load信号是2状态的单比特信号，所以它们作为svBit被传递，减少为unsigned char。您的代码可以用两种方式声明值，但要确保安全，请使用SystemVerilog DPI类型。输入i是2状态的，7位宽，作为svBitVecVal传递。注意，它是作为const指针传递的，这意味着底层的值可以更改，但不能更改指针的值，例如使其指向另一个值。同样，reset和load输入也被标记为const。在本例中，7位计数器值存储在一个char中，因此必须屏蔽上面的位。 h文件包含SystemVerilog DPI结构和方法的定义。本章剩下的C代码示例没有使用#include语句，除非它们对讨论很重要。 示例12.8显示了SystemVerilog程序，该程序为7位计数器导入并调用C函数。 示例12.8带有静态存储的7位计数器的Testbench 12.2.2 Chandle数据类型 chandle数据类型允许您在SystemVerilog代码中存储C或c++指针。chandle变量的宽度足以在编译代码的机器上保存指针，即32位或64位。样品12.7中的计数器只要是设计中唯一的计数器就可以正常工作。您可以将示例12.8中的counter7调用包装在一个模块中，并在设计中实例化多个副本。然而，由于计数器的值存储在C静态中，因此每个实例共享单个值。如果需要调用C代码的模块的多个实例，C代码需要将其变量存储在静态变量之外的其他地方。更好的方法是分配存储，并向其传递一个句柄，以及输入和输出信号值。示例12.9显示了一个在结构c7中存储7位计数的计数器。对于一个简单的计数器来说，这有点小题大做了，但是如果您正在为一个更大的设备创建一个模型，您可以从这个示例进行构建。 示例12.9使用实例存储的计数器例程 例程counter7_new构造了计数器实例。这将返回一个chandle，它必须被传递到对counter7的后续调用中。计数器的值存储在c7类型的结构体中。函数counter7_new调用malloc分配该结构体，并将结果转换为一个本地指针c。 C代码使用PLI任务io_printf来显示调试消息。当您同时调试C和SystemVerilog代码时，这个例程很有帮助，因为它写入相同的输出(包括日志文件)，就像$display一样，包括 模拟器的日志文件。例程在veriuser.h中定义。 示例12.10中此计数器的测试工作台与静态计数器在几个方面有所不同。首先，计数器必须在使用之前构造好。接下来，计数器在时钟边缘被调用，而不是与刺激同步。为简单起见，在时钟走高时调用计数器，在时钟走低时应用刺激，以避免任何竞争条件。 示例12.10 Testbench，用于每个实例存储的7位计数器 12.2.3 包装值表示 字符串\"DPI-C\"1指定您正在使用打包值的规范表示。这种表示将SystemVerilog变量存储为一个或多个元素的C数组。2状态变量使用svBitVecVal类型存储。2状态数组与该类型的多个元素一起存储。 早期版本的LRM使用“DPI”，但现在已经过时，不应该使用。 31:0未使用的39:32 图12.1 40位2状态变量的存储 由于性能的原因。SystemVerilog模拟器在调用DPI例程后可能不会屏蔽较高的位，因此SystemVerilog变量可能会损坏。确保你的C代码正确处理这些值。 如果需要在位和字之间进行转换，请使用SV_PACKED_ DATA_NELEMS宏。例如，要将40位转换为两个32位的单词(如图12.1所示)，请使用SV_PACKED_DATA_NELEMS(40)。 12.2.4 4-State值 SystemVerilog中的每个4状态位存储在模拟器中，使用两个称为 aval和bval，见表12.2 表12.2 4状态位编码 4-state价值bval保兑000101Z10X11 单个位的4状态变量，如逻辑f，存储在无符号字节中，aval位存储在最低有效位中，bval位存储在更高的位中。因此，值1'b0在C中被视为0x0, 1'b1是0x1, 1'bz是0x2, 1'bx是0x3。像logic [31:0] lword这样的4状态向量使用32位对svLogicVecVal存储，如图12.2所示，其中包含aval和bval位。32位变量lword存储在单个svLogicVecVal中。大于32位的变量存储在多个svLogicVecVal元素中，第一个元素包含32个最低有效位，下一个元素包含下一个32位，直到最高有效位。一个40位的逻辑变量被存储为最低32位的svLogicVecVal，最高8位的svLogicVecVal(图12.2)。这个最大值中未使用的24位是未确定的，您需要负责屏蔽或扩展符号位。svLogicVecVal类型等价于s_vpi_vecval，它用于表示诸如此类的4种状态类型 作为VPI中的逻辑。 保兑31:0bval 31:0未使用的保兑39:32未使用的bval 39:32 图12.2 40位四态变量的存储 注意那些没有使用位下标或使用单个位声明的参数。声明为输入逻辑a的参数存储在unsigned char中。参数输入逻辑[0:0]b是svLogicVecVal，即使它只包含一个比特。 样例12.11显示了一个4状态计数器的import语句。与示例12.10的唯一区别是位类型现在是逻辑类型。 样例12.11用于检查Z或X值的计数器的Testbench 前面示例12.9中显示的计数器假设所有输入都是两种状态。示例12.12扩展了这段代码，在reset、load和i时检查Z和X的值。实际的计数仍然保持为2状态值。 示例12.12检查Z和X值的计数器例程 如果你想因为在导入的例程中发现一个条件而强制终止模拟，你可以调用VPI例程vpi_ control(vpiFinish, 0).这个例程和常量在包含文件vpi_user.h中定义。值vpiFinish告诉模拟器在导入的例程返回后执行$finish。 12.2.5 从2状态转换为4状态 如果您有一个使用2种状态类型的DPI应用程序，并且希望将其转换为使用4种状态类型，请遵循以下指导原则。 在SystemVerilog端，将导入声明从使用2状态类型(如bit和int)更改为4状态类型(如logic和integer)。确保在函数调用中使用了4个状态变量。 在C端，将参数声明从svBitVecVal切换到svLog- icVecVal。对参数的任何引用都必须使用.aval后缀to 正确访问数据。当您从一个4状态变量中读取数据时，检查bval位，看看是否有Z或X值。当写入4状态变量时，除非需要写入Z或X值，否则清除bval位。 12.3. 连接到c++ 您可以使用DPI将用C或c++编写的例程连接到SystemVerilog。有几种使用DPI的c++代码通信的方式，这取决于您的模型的抽象级别。 12.3.1 c++中的计数器 示例12.13显示了一个7位计数器的c++类，具有2状态输入。它连接到示例12.10中的SystemVerilog testbench和示例12.14中的c++包装器代码。 示例12.13计数器类 12.3.2 静态方法 DPI只能调用在链接时已知的C或c++函数。因此，SystemVerilog代码不能在对象中调用c++例程，因为链接器运行时对象不存在。 那么，如果需要调用c++类中的方法，该怎么办呢?解决方案，如示例12.14所示，是创建一个具有固定地址的函数，然后可以与c++动态对象和方法通信。第一个例程counter7_new为该计数器构造一个对象，并返回该对象的句柄。第二个静态例程counter7使用对象句柄调用执行计数器逻辑的c++方法。 样例12.14静态方法和链接 extern \" C \"代码告诉c++编译器，发送给连接器的外部信息应该使用C调用约定，而不是执行名称mangling。你可以把它放在SystemVerilog调用的每个例程之前，或者把extern \"C\"{…}围绕一组方法。 从测试工作台的角度来看，c++计数器看起来与在每个实例存储中存储值的计数器是一样的，如示例12.9所示，因此您可以使用相同的测试工作台(示例12.10)。 12.3.3 与事务级c++模型通信 前面的C / c++代码示例是在信号级别与SystemVerilog通信的低级模型。这是没有效率的;例如，即使数据或控制输入没有改变，计数器也会在每个时钟周期被调用。当您为处理器和网络设备等复杂设备创建模型时，请在事务级别与它们通信以获得更快的模拟。 示例12.15中的c++计数器模型有一个事务级接口，与方法通信，而不是信号和时钟。 示例12.15 c++计数器与方法通信 诸如reset、load和count之类的动态c++方法被包装在使用从SystemVerilog传递的对象句柄的静态方法中，如示例12.16所示。 示例12.16 c++事务级计数器的静态包装器 事务级计数器的OOP接口被携带到测试台中。样例12.17包含SystemVerilog导入语句和包装c++对象的类。这允许您将c++句柄隐藏在类内部。 请注意，counter7_get()函数返回的是int(32位，带符号)，而不是bit[6:0]，因为后者需要返回一个指向svBitVecVal的指针，如表12.1所示。导入的函数不能返回指针。它只能返回void、byte、shortint、int、longint、real、shortreal、chandle和string类型的值，以及bit和logic类型的单个位值。 示例12.17 c++模型使用方法的Testbench 12.4. 简单的数组共享 到目前为止，您已经看到了在SystemVerilog和C之间传递标量和向量的示例。典型的C模型可能读取一个值数组，执行一些计算，并返回另一个带有结果的数组。 12.4.1 一维数组- 2状态 示例12.18展示了一个例程，它计算斐波那契数列中的前20个值。它由示例12.19中的SystemVerilog代码调用。 例程12.18 C计算斐波那契数列 注意，在C语言中，您也可以将参数声明为指针， *数据或数组，数据[20]。在这个例子中，它们是可以互换的。 示例12.19 Fibonacci例程的Testbench 注意，斐波那契值数组是在SystemVerilog中分配和存储的，即使它是在C中计算的。没有办法在C中分配数组并在SystemVerilog中引用它。 12.4.2 一维数组- 4种状态 示例12.20展示了示例12.21中带有testbench的4状态数组的斐波那契C例程。 示例12.20 C例程用4状态数组计算斐波那契数列 示例12.21带有4状态数组的斐波那契例程的Testbench 第12.2.5节介绍如何将一个2状态应用程序转换为4状态应用程序。 12.5. 开放的数组 在SystemVerilog和C之间共享数组时，有两个选项。对于最快的模拟，您可以逆向工程System- Verilog中的元素布局，并编写您的C代码来使用这个映射。这种方法是脆弱的，这意味着如果任何数组大小发生变化，就必须重写和调试C代码。一种更健壮的方法是使用“开放数组”及其相关的SystemVerilog例程来操作它们。这允许您编写可以操作任意大小数组的通用C例程。 12.5.1 基本开放数组 示例12.22和12.23展示了如何在SystemVerilog和C之间传递一个带有打开数组的简单数组。在SystemVerilog import语句中使用空方括号[]来指定传递的是一个开放数组。 示例12.22 Testbench代码使用一个开放数组调用一个C例程 你的C代码用svOpenArray- handle类型的句柄引用这个开放数组。这指向一个结构，其中包含关于数组的信息，例如声明的字范围。您可以通过调用svGetArrayPtr来定位实际的数组元素。请注意，svSize()是一个开放数组查询方法，将在下一节中描述。 示例12.23 C代码，使用基本的开放数组 12.5.2 开放数组的方法 正如svdpi.h中定义的那样，有许多DPI方法可以访问它们的内容和范围。这些操作只适用于声明为svOpenArray- Handle的开放数组句柄，而不适用于svBitVecVal或svLogicVecVal之类的指针。表12.3中的方法提供了有关开放数组大小的信息。 表12.3 Open array查询功能 函数 描述 int svLeft (h, d) 维数d的左界 int svRight (h, d) 维度d的右界 int svLow (h, d) 维数d的下限 int svHigh (h, d) 维数d的高界 int svIncrement (h, d) If left >= right, 1, else−1 int svSize (h, d) d维元素个数:svHigh−svLow+1 int svDimensions (h) 开放数组的维度数 int svSizeOfArray (h) 以字节为单位的数组总大小 在表12.3中，变量h是一个svOpenArrayHandle, d是一个int，维度从d=1开始编号。 表12.4中的函数返回整个数组或单个元素的C存储位置。 表12.4打开阵列定位器功能 函数 返回指针: void * svGetArrayPtr (h) 存储整个数组void 数组中的一个元素 1维数组中的一个元素 2维数组中的一个元素 三维阵列中的一个元素 12.5.3 传递未设置大小的开放数组 示例12.24使用一个二维数组调用C代码。C代码使用svLow和svHigh方法来查找数组范围，在本例中，它不遵循通常的0..size-1。 示例12.24 Testbench使用多维开放数组调用C代码 这调用了示例12.25中的C代码，该代码使用open array方法读取数组。例程svLow(handle, dimension)返回指定维度的最低索引号。所以svLow(h,1)对于使用范围[6:1]声明的数组返回1。同样，svHigh(h, 1)返回6。你应该使用svLow和svHigh与C for循环。 方法svLeft和svRight返回数组声明的左下标和右下标，范围[6:1]分别为6和1。在示例12.25的中心，调用svGetArrElemPtr2返回一个指向二维数组中的元素的指针。 示例12.25 C代码，带有多维开放数组 12.5.4 在DPI中打包开放数组 DPI中的开放数组被视为具有单个打包维度和一个或多个未打包维度。您可以传递具有多个打包维度的数组，只要这些维度打包到与单个元素大小相同的元素中即可 正式的论证。例如，如果你在import语句中有正式的参数bit[63:0] b64[]，你可以传入实际的参数bit[1:0][0:3][6:−1]bpack[9:1]。样例12.26展示了带有打开数组的SystemVerilog代码。 示例12.26用于打包开放数组的Testbench 示例12.27 C代码使用了打包的开放数组 注意，示例12.27中的C代码使用%llx打印64位值，并将svGetArrayElemPtr1的结果转换为long long int。 12.6. 分享复合类型 此时，您可能想知道如何在SystemVerilog和c之间传递对象。类属性的布局在两种语言之间不匹配，因此不能直接共享对象。相反，您必须在每个节点上创建类似的结构 边，加上pack和unpack方法来在两种格式之间进行转换。所有这些就绪之后，就可以共享复合类型了。 12.6.1 在SystemVerilog和C之间传递结构 下面的示例共享一个简单的像素结构，该像素由三个字节打包成一个单词。示例12.28显示了C结构。注意，C将char作为有符号变量处理，这可能会给您带来意想不到的结果，因此该结构将char标记为unsigned。字节的顺序与SystemVerilog相反，因为这段代码是为Intel x86处理器编写的，它是小端的，这意味着最低有效字节存储在比最高有效字节更低的地址中。Sun SPARC是大端，因此字节的存储顺序与SystemVerilog相同:r、g、b。 示例12.28 C代码共享一个结构 样例12.29中的SystemVerilog testbench有一个包含单个像素的打包结构，以及封装像素操作的类。RGB_T结构被打包，因此SystemVerilog将把字节存储在连续的位置。如果没有包装修饰符，每个8位值将存储在单独的单词中。 示例12.29用于共享结构的Testbench 12.6.2 在SystemVerilog和C之间传递字符串 使用DPI，您可以将字符串从C传递回SystemVerilog。您可能需要传递一个字符串作为结构的符号值，或者获取表示C代码内部状态的字符串以进行调试。 将字符串从C传递给SystemVerilog的最简单方法是让C函数返回一个指向静态字符串的指针，如示例12.30所示。字符串必须是 在C中声明为静态，而不是本地字符串。非静态变量存储在堆栈中，并在函数返回时回收。 示例12.30从C语言返回一个字符串 静态存储的一个危险是多个并发调用可能最终共享存储。例如，打印多个像素的SystemVerilog $display语句可能多次调用上述打印例程。根据SystemVerilog编译器对这些调用的排序，以后对print()的调用可能会覆盖以前调用的结果，除非SystemVerilog编译器复制了该字符串。注意，SystemVerilog调度程序永远不会中断对导入例程的调用。样例12.31将字符串存储在堆中以支持并发调用。 示例12.31在C语言中从堆返回一个字符串 12.7. 纯和上下文导入方法 导入的方法分为纯方法、上下文方法和泛型方法。纯函数严格根据输入计算输出，没有外部交互。具体来说，纯函数不访问任何全局变量或静态变量，不执行任何文件操作，也不与函数外部的任何东西交互，比如操作 系统，进程，共享内存，套接字，等等。如果结果不需要，SystemVerilog编译器可能会优化对纯函数的调用，或者用使用相同参数的前一次调用的结果替换调用。样本12.5中的阶乘函数和样本12.6中的sin函数都是纯函数，因为它们的结果只基于它们的输入。样例12.32展示了如何导入纯函数。 示例12.32导入纯函数 导入的例程可能需要知道调用它的上下文，以便它可以调用PLI TF、ACC或VPI方法，或已导出的SystemVerilog任务。使用这些方法的context属性，如示例12.33所示。 示例12.33导入的上下文任务 导入的例程可能使用全局存储，所以它不是纯的，但可能没有任何PLI引用，所以它不需要上下文例程的开销。Sutherland(2004)对这些方法使用术语“通用”，因为SystemVerilog LRM没有特定的名称。默认情况下，导入的例程是通用的，就像本章中的许多例子一样。 由于模拟器需要记录调用上下文，因此调用上下文导入例程会有开销，所以只有在需要时才将例程声明为上下文。另一方面，如果一个通用导入例程调用导出的任务或访问SystemVerilog数据对象的PLI例程，那么模拟器可能会崩溃。 上下文感知的PLI例程需要知道它是从哪里被调用的，这样它才能访问与该位置相关的信息。 12.8. 从C通信到SystemVerilog 到目前为止的示例已经向您展示了如何从SystemVerilog模型调用C代码。DPI还允许您从C代码调用SystemVerilog例程。SystemVerilog例程可以是用C语言记录操作结果的简单任务，也可以是表示部分硬件模型的耗时任务。 12.8.1 一个简单的导出函数 样例12.34显示了一个导入上下文函数和导出System- Verilog函数的模块。 示例12.34导出SystemVerilog功能 样例12.34中的export声明看起来很直白，因为LRM禁止放入返回值声明或任何参数。你甚至不能给出通常的空括号。出口申报单中的这一信息与出口申报单中的 在模块末尾的函数声明中的信息，因此，如果您更改了函数，可能会失去同步。 样例12.35显示了调用导出函数的C代码。 示例12.35从C调用导出的SystemVerilog函数 本例打印C代码中的行，然后是SystemVerilog的$display输出，如示例12.36所示。 示例12.36简单导出的输出 12.8.2 函数调用SystemVerilog函数 虽然您的大部分测试台架应该在SystemVerilog中，但您可能有C或其他语言的遗留测试台架，或者您想要重用的应用程序。本节创建一个SystemVerilog内存模型，该模型由从外部文件读取事务的C代码激发。 内存模型的第一个版本(如示例12.38和12.37所示)只使用函数进行编码，因此一切都以零时间运行。中的C代码 示例12.37打开文件，读取命令，并调用导出的函数。为了简洁，错误检查已经被移除。 示例12.37 C代码读取简单的命令文件并调用导出函数 SystemVerilog代码调用打开文件的C任务read_file。文件中唯一的命令设置内存大小，因此C代码调用一个导出函数。 示例12.38 SystemVerilog模块，用于简单的内存模型 注意，在示例12.38中，export语句没有任何参数，因为该信息已经在函数声明中了。 命令文件很简单，只需要一个命令就可以构造一个包含100个元素的内存，如示例12.39所示。 示例12.39用于简单内存模型的命令文件 12.8.3 C任务调用SystemVerilog任务 真正的内存模型有一些操作，比如读和写，这些操作会消耗时间，因此必须用任务来建模。 样例12.40显示了内存模型的第二个版本的SystemVerilog代码。与示例12.38相比，它有几个改进。有两个新任务，mem_read和mem_write，它们分别需要20ns和10ns来完成。导入的例程read_file现在是SystemVerilog任务，因为它正在调用其他消耗时间的任务。import语句现在指定read_file是一个上下文任务，因为在调用它时，模拟器需要创建一个单独的堆栈。 示例12.40 SystemVerilog模块的内存模型导出的任务 样例12.41中的C代码主要扩展了case语句，该语句对命令进行解码并调用导出的任务，根据lrm2，这些任务声明为extern int 示例12.41 C代码读取命令文件并调用导出函数 示例12.42中的命令文件有新命令，这些命令写两个位置，然后读回其中一个位置，并包含预期的值。 VCS在C语言中将导出的任务声明为void函数。 示例12.42用于简单内存模型的命令文件 12.8.4 调用对象中的方法 您可以导出SystemVerilog方法，但类中定义的方法除外。这个限制类似于导入静态C方法的限制，如12.3.2节所示，因为当SystemVerilog详细阐述代码时对象不存在。解决方案是在SystemVerilog和C代码之间传递对对象的引用。然而，与C指针不同，SystemVerilog句柄不能通过DPI传递。您可以使用句柄数组，并在两种语言之间传递数组索引。 下面的示例建立在先前版本的内存之上。示例12.44中的SystemVerilog代码有一个封装内存的类。现在您可以拥有多个内存，每个内存在一个单独的对象中。示例12.43中的命令文件创建了两个内存，M0和M1。然后，它对两个内存中的初始化位置执行几次写操作，最后尝试读回这些值。请注意，位置12用于这两个内存。 示例12.43带有OOP内存的导出方法的命令文件 示例12.44中的SystemVerilog代码为文件中的每个M命令构造一个新对象。导出的函数mem_build调用内存构造函数。然后，它将内存对象的句柄存储在SystemVerilog队列中，并将队列索引idx返回给C代码，如示例12.45所示。句柄存储在队列中，这样您就可以动态地添加新的内存。导出的任务mem_read和mem_write现在有了一个额外的参数，即内存句柄在队列中的索引。 示例12.44 SystemVerilog模块与内存模型类 使用OOP内存调用导出任务的示例12.45 C代码 12.8.5 语境的意义 导入例程的上下文是定义它的位置，例如 $单元、模块、程序或包作用域，就像普通的SystemVerilog例程一样。如果在两个不同的作用域中导入例程，相应的C代码将在发生import语句的上下文中执行。这类似于在两个单独的模块中分别定义SystemVerilog run()任务。每个任务访问自己模块中的变量，没有歧义。 样例12.46表明，如果向样例12.34添加第二个模块，该模块导入相同的C代码并导出自己的函数，C例程将调用不同的SystemVerilog方法，这取决于导入和导出语句的上下文。 示例12.46第二个模块，用于简单的导出示例 示例12.47中的输出显示，一个C例程调用两个单独的SystemVerilog方法，这取决于调用C例程的位置。 带有两个模块的简单示例的输出 12.8.6 为导入的例程设置范围 正如SystemVerilog代码可以调用本地作用域中的例程一样，导入的C例程也可以调用其默认上下文之外的例程。使用svGetScope例程获得当前作用域的句柄，然后在调用svGetScope时使用该句柄，使C代码认为它位于另一个上下文中。示例12.48展示了两个方法的C代码。第一个方法save_my_scope()保存从SystemVerilog端调用它的范围。第二个例程c_display()将其作用域设置为保存的作用域，打印一条消息，然后调用函数sv_display()。 示例12.48 C代码获取和设置上下文 C代码调用svGetNameFromScope()，它返回当前作用域的字符串。这个作用域被打印两次，一次是第一次调用C代码的作用域，另一次是先前保存的作用域。例程svGetScopeFromName()接受一个带有SystemVerilog作用域的字符串，并返回一个指向svScope句柄的指针，该句柄可以与svSetScope()一起使用。 在示例12.49中的SystemVerilog代码中，第一个模块block调用一个保存上下文的C例程。当模块top调用c_display()时，例程将scope设为block，因此它调用block模块中的sv_display()例程，而不是top模块。 样例12.49模块调用获取和设置上下文的方法 这将产生示例12.50中所示的输出。 示例12.50 svSetScope代码的输出 您可以使用这个范围的概念来允许C模型知道它是从哪里实例化的，并区分每个实例。例如，一个内存模型可能被实例化多次，并且需要为每个实例分配唯一的存储空间。 12.9. 连接其他语言 本章已经展示了使用C和c++的DPI。只需一点工作，你就可以连接其他语言。最简单的方法是调用Verilog $system()任务。如果需要命令的返回值，可以使用Unix system()函数和WEXITSTATUS宏。示例12.51中的SystemVerilog代码为system()调用了一个C包装器。 示例12.51 SystemVerilog代码为Perl调用C包装器 样例12.52是调用system()并转换返回值的C包装器。 示例12.52 Perl脚本的C包装器 示例12.53是一个Perl脚本，它打印一条消息并返回一个值。 示例12.53从C和SystemVerilog调用的Perl脚本 现在可以运行示例12.54中的Unix命令来运行模拟并调用hello.pl脚本。 12.11运动 453 示例12.54 VCS命令行运行Perl脚本 12.10. 结论 直接编程接口允许您调用C例程,好像他们只是另一个SystemVerilog常规,通过SystemVerilog类型直接进入这开销低于PLI,构建参数列表,并一直跟踪调用上下文,更不用说有4 C例程的复杂性为每个系统的任务。 此外，使用DPI，您的C代码可以调用SystemVerilog例程，允许外部应用程序控制模拟。使用PLI，您将需要触发器变量和更多的参数列表，并且您必须担心多个调用和耗时任务带来的细微错误。 DPI最困难的部分是将SystemVerilog类型映射到C语言，特别是当您有两种语言之间共享的结构和类时。如果您能够掌握这个问题，那么几乎可以将任何应用程序连接到SystemVerilog。 12.11. 练习 创建一个C函数，shift_c，它有两个输入参数:一个32位的无符号输入值i和一个移动量n的整数。输入i移动了n位。当n为正时，值向左移动，当n为负时，值向右移动，当n为0时，不进行移动。函数返回移位后的值。创建一个SystemVerilog模块，调用C函数并测试每个特性。提供输出。 展开练习1，向shift_c添加第三个参数，一个加载标志ld。当ld为真时，i被移动n位，然后加载到内部32位寄存器中。当ld为假时，寄存器移位n位。在这些操作之后，函数返回寄存器的值。创建一个SystemVerilog模块，调用C函数并测试每个特性。提供输出。 展开练习2，创建shift_c函数的多个实例。C中的每个实例都需要一个唯一的标识符，所以请使用存储内部寄存器的地址。当函数shift_c被调用时，打印这个地址和参数。实例化函数两次，并调用每个实例两次。提供输出。 展开练习3中的C代码，显示shift_c函数被调用的总次数，即使该函数被实例化了不止一次。 展开练习4以提供在实例化时初始化存储值的能力。 展开练习5，将shift_c函数封装在一个类中。 对于示例12.24和12.25中的代码，以下开放数组方法返回什么? 修改练习1，这样函数调用导出的SystemVerilog void函数shift_sv来代替在C中移动值。 展开练习8，为文本12.8.4节中演示的两个不同的SystemVerilog对象调用SystemVerilog函数shift_sv。假设SystemVerilog函数shift_build已经导出到C代码中。 将练习8扩展到: 创建一个SystemVerilog类Shift，其中包含函数shift_sv(将结果存储在类级变量中)和一个shift_print函数(显示存储的结果)。 定义并导出SystemVerilog函数shift_build。 支持创建多个Shift对象，这些对象的句柄存储在一个队列中。 创建一个构建多个Shift对象的testbench。演示每个对象在执行计算后持有一个单独的结果。 "}}